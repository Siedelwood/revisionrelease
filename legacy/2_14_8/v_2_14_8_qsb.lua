-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia Core                                                         # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Hier werden wichtige Basisfunktionen bereitgestellt. Diese Funktionen sind
-- auch in der Minimalkonfiguration der QSB vorhanden und essentiell für alle
-- anderen Bundles.
--
-- @set sort=true
--

API = API or {};
QSB = QSB or {};
QSB.Version = "Version 2.14.8 08/12/2022";
QSB.HumanPlayerID = 1;
QSB.Language = "de";

Core = Core or {
    Data = {}
};

ParameterType = ParameterType or {};
g_QuestBehaviorVersion = 1;
g_QuestBehaviorTypes = {};

---
-- AddOn Versionsnummer
-- @local
--
g_GameExtraNo = 0;
if Framework then
    g_GameExtraNo = Framework.GetGameExtraNo();
elseif MapEditor then
    g_GameExtraNo = MapEditor.GetGameExtraNo();
end

-- Logging ---------------------------------------------------------------------

QSB.Logging = {
    DisplayLoggingLevel = 4,
    FileLoggingLevel = 2,
    Levels = {
        Debug = 1;
        Info = 2;
        Warning = 3;
        Error = 4;
        Off = 5;
    },
}

LEVEL_DEBUG = QSB.Logging.Levels.Debug;
LEVEL_INFO = QSB.Logging.Levels.Info;
LEVEL_WARNING = QSB.Logging.Levels.Warning;
LEVEL_ERROR = QSB.Logging.Levels.Error;
LEVEL_OFF = QSB.Logging.Levels.Off;

-- API Stuff --

---
-- Kopiert eine komplette Table und gibt die Kopie zurück. Tables können
-- nicht durch Zuweisungen kopiert werden. Verwende diese Funktion. Wenn ein
-- Ziel angegeben wird, ist die zurückgegebene Table eine Vereinigung der 2
-- angegebenen Tables.
-- Die Funktion arbeitet rekursiv.
--
-- <p><b>Alias:</b> CopyTableRecursive</p>
--
-- @param[type=table] _Source Quelltabelle
-- @param[type=table] _Dest   (optional) Zieltabelle
-- @return[type=table] Kopie der Tabelle
-- @within Anwenderfunktionen
-- @usage Table = {1, 2, 3, {a = true}}
-- Copy = API.InstanceTable(Table)
--
function API.InstanceTable(_Source, _Dest)
    _Dest = _Dest or {};
    assert(type(_Source) == "table")
    assert(type(_Dest) == "table")

    for k, v in pairs(_Source) do
        if type(v) == "table" then
            _Dest[k] = _Dest[k] or {};
            for kk, vv in pairs(API.InstanceTable(v)) do
                _Dest[k][kk] = _Dest[k][kk] or vv;
            end
        else
            _Dest[k] = _Dest[k] or v;
        end
    end
    return _Dest;
end
CopyTableRecursive = API.InstanceTable;

---
-- Sucht in einer eindimensionalen Table nach einem Wert. Das erste Auftreten
-- des Suchwerts wird als Erfolg gewertet.
--
-- Es können praktisch alle Lua-Werte gesucht werden, obwohl dies nur für
-- Strings und Numbers wirklich sinnvoll ist.
--
-- <p><b>Alias:</b> Inside</p>
--
-- @param             _Data Gesuchter Eintrag (multible Datentypen)
-- @param[type=table] _Table Tabelle, die durchquert wird
-- @return[type=booelan] Wert gefunden
-- @within Anwenderfunktionen
-- @usage Table = {1, 2, 3, {a = true}}
-- local Found = API.TraverseTable(3, Table)
--
function API.TraverseTable(_Data, _Table)
    for k,v in pairs(_Table) do
        if v == _Data then
            return true;
        end
    end
    return false;
end
Inside = API.TraverseTable;

---
-- Schreibt ein genaues Abbild der Table ins Log. Funktionen, Threads und
-- Metatables werden als Adresse geschrieben.
--
-- @param[type=table]  _Table Tabelle, die gedumpt wird
-- @param[type=string] _Name Optionaler Name im Log
-- @within Anwenderfunktionen
-- @local
-- @usage Table = {1, 2, 3, {a = true}}
-- API.DumpTable(Table)
--
function API.DumpTable(_Table, _Name)
    local Start = "{";
    if _Name then
        Start = _Name.. " = \n" ..Start;
    end
    Framework.WriteToLog(Start);

    for k, v in pairs(_Table) do
        if type(v) == "table" then
            Framework.WriteToLog("[" ..k.. "] = ");
            API.DumpTable(v);
        elseif type(v) == "string" then
            Framework.WriteToLog("[" ..k.. "] = \"" ..v.. "\"");
        else
            Framework.WriteToLog("[" ..k.. "] = " ..tostring(v));
        end
    end
    Framework.WriteToLog("}");
end

---
-- Konvertiert alle Strings, Booleans und Numbers einer Tabelle in
-- einen String. Die Funktion ist rekursiv, d.h. es werden auch alle
-- Untertabellen mit konvertiert. Alles was kein Number, Boolean oder
-- String ist, wird als Adresse geschrieben.
--
-- @param[type=table] _Table Table zum konvertieren
-- @return[type=string] Converted table
-- @within Anwenderfunktionen
-- @local
--
function API.ConvertTableToString(_Table)
    assert(type(_Table) == "table");
    local TableString = "{";
    for k, v in pairs(_Table) do
        local key;
        if (tonumber(k)) then
            key = ""..k;
        else
            key = "\""..k.."\"";
        end

        if type(v) == "table" then
            TableString = TableString .. "[" .. key .. "] = " .. API.ConvertTableToString(v) .. ", ";
        elseif type(v) == "number" then
            TableString = TableString .. "[" .. key .. "] = " .. v .. ", ";
        elseif type(v) == "string" then
            TableString = TableString .. "[" .. key .. "] = \"" .. v .. "\", ";
        elseif type(v) == "boolean" or type(v) == "nil" then
            TableString = TableString .. "[" .. key .. "] = " .. tostring(v) .. ", ";
        else
            TableString = TableString .. "[" .. key .. "] = \"" .. tostring(v) .. "\", ";
        end
    end
    TableString = TableString .. "}";
    return TableString
end

---
-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am
-- Bildschirm und ist nicht statisch.
--
-- <p><b>Alias:</b> GUI_Note</p>
--
-- @param[type=string] _Message Anzeigetext
-- @within Anwenderfunktionen
-- @local
--
function API.Note(_Message)
    _Message = API.ConvertPlaceholders(API.Localize(_Message));
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[GUI.AddNote("%s")]], _Message
        ));
        return;
    end
    GUI.AddNote(_Message);
end
GUI_Note = API.Note;

---
-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am
-- Bildschirm und verbleibt dauerhaft am Bildschirm.
--
-- <p><b>Alias:</b> GUI_StaticNote</p>
--
-- @param[type=string] _Message Anzeigetext
-- @within Anwenderfunktionen
--
function API.StaticNote(_Message)
    _Message = API.ConvertPlaceholders(API.Localize(_Message));
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[GUI.AddStaticNote("%s")]], _Message
        ));
        return;
    end
    GUI.AddStaticNote(_Message);
end
GUI_StaticNote = API.StaticNote;

---
-- Löscht alle Nachrichten im Debug Window.
--
-- @within Anwenderfunktionen
--
function API.ClearNotes()
    if not GUI then
        Logic.ExecuteInLuaLocalState('GUI.ClearNotes()');
        return;
    end
    GUI.ClearNotes();
end

---
-- Schreibt eine Nachricht in das Nachrichtenfenster unten in der Mitte.
--
-- <p><b>Alias:</b> GUI_NoteDown</p>
--
-- @param[type=string] _Message Anzeigetext
-- @within Anwenderfunktionen
--
function API.Message(_Message)
    _Message = API.Localize(_Message);
    if not GUI then
        Logic.ExecuteInLuaLocalState('Message("' .._Message.. '")');
        return;
    end
    Message(_Message);
end
GUI_NoteDown = API.Message;

---
-- Ermittelt den lokalisierten Text anhand der eingestellten Sprache der QSB.
--
-- Wird ein normaler String übergeben, wird dieser sofort zurückgegeben.
--
-- @param _Message Anzeigetext (String oder Table)
-- @return[type=string] Message
-- @within Anwenderfunktionen
-- @local
--
function API.Localize(_Message)
    if type(_Message) == "table" then
        local MessageText = _Message[QSB.Language];
        if MessageText then
            return MessageText;
        end
        if _Message.en then
            return _Message.en;
        end
        return tostring(_Message);
    end
    return tostring(_Message);
end

---
-- Schreibt eine Nachricht mit dem angegebenen Level auf den Bildschirm
-- und ins Log.
--
-- <p><b>Alias:</b> error</p>
--
-- @param[type=string] _Message Anzeigetext
-- @param[type=string] _Level   Fehlerlevel
-- @within Logging
--
function API.Log(_Message, _Level)
    if Core then
        Core:LogToScreen(_Message, _Level);
        Core:LogToFile(_Message, _Level);
    end
end
log = API.Error;

---
-- Schreibt eine Debug-Nachricht mit dem angegebenen Level auf den Bildschirm
-- und ins Log.
--
-- <p><b>Alias:</b> error</p>
--
-- @param[type=string] _Message Anzeigetext
-- @within Logging
--
function API.Debug(_Message)
    if Core then
        Core:LogToScreen(_Message, LEVEL_DEBUG);
        Core:LogToFile(_Message, LEVEL_DEBUG);
    end
end
debug = API.Debug;

---
-- Schreibt eine Ifon-Nachricht mit dem angegebenen Level auf den Bildschirm
-- und ins Log.
--
-- <p><b>Alias:</b> error</p>
--
-- @param[type=string] _Message Anzeigetext
-- @within Logging
--
function API.Info(_Message)
    if Core then
        Core:LogToScreen(_Message, LEVEL_INFO);
        Core:LogToFile(_Message, LEVEL_INFO);
    end
end
info = API.Info;

---
-- Schreibt eine Warnungsmeldung mit dem angegebenen Level auf den Bildschirm
-- und ins Log.
--
-- <p><b>Alias:</b> error</p>
--
-- @param[type=string] _Message Anzeigetext
-- @within Logging
--
function API.Error(_Message)
    if Core then
        Core:LogToScreen(_Message, LEVEL_ERROR);
        Core:LogToFile(_Message, LEVEL_ERROR);
    end
end
error = API.Error;

---
-- Schreibt eine Fehlermeldung mit dem angegebenen Level auf den Bildschirm
-- und ins Log.
--
-- <p><p><b>Alias:</b> warn</p></p>
--
-- @param[type=string] _Message Anzeigetext
-- @within Logging
--
function API.Warn(_Message)
    if Core then
        Core:LogToScreen(_Message, LEVEL_WARNING);
        Core:LogToFile(_Message, LEVEL_WARNING);
    end
end
warn = API.Warn;

---
-- Setzt das Level fest ab dem auf den Bildschirm und ins Log geschrieben wird.
--
-- @param[type=string] _Screen Level Bildschirm
-- @param[type=string] _File   Level Datei
-- @within Logging
--
function API.SetLoggingLevel(_Screen, _File)
    if GUI then
        return;
    end
    QSB.Logging.DisplayLoggingLevel = _Screen;
    QSB.Logging.FileLoggingLevel = _File;
    Logic.ExecuteInLuaLocalState(string.format([[
        QSB.Logging.DisplayLoggingLevel = %d
        QSB.Logging.FileLoggingLevel = %d
    ]], _Screen, _File));
end

-- Core Stuff --

---
-- Gibt die Systemzeit und das Datum formatiert als String zurück.
--
-- @return[type=string] Datum und Uhrzeit
-- @within Internal
-- @local
--
function Core:GetSystemTime()
    local DateTimeString = Framework.GetSystemTimeDateString();
    local Year = DateTimeString:sub(2, 5);
    local Month = DateTimeString:sub(7, 8);
    local Day = DateTimeString:sub(10, 11);
    local Hour = DateTimeString:sub(15, 16);
    local Minute = DateTimeString:sub(18, 19);
    local Second = DateTimeString:sub(22, 23);
    return Day.. "." ..Month.. "." ..Year.. " " ..Hour.. ":" ..Minute.. ":" ..Second;
end

---
-- Formatiert die Nachricht für die Logger.
--
-- @param[type=string]  _Text    Nachricht 
-- @param[type=number]  _Level   Scheregrad
-- @param[type=boolean] _IsFile  Formatiere für Log File
-- @param[type=string]  _Env     Umgebung
-- @return[type=string] Nachricht
-- @within Internal
-- @local
--
function Core:FormatLoggingMessage(_Text, _Level, _IsFile, _Env)
    local Date = self:GetSystemTime();
    local LevelText = "DEBUG";
    if _Level > 1 then
        LevelText = "INFO";
    end
    if _Level > 2 then
        LevelText = "WARN";
    end
    if _Level > 3 then
        LevelText = "ERROR";
    end

    local Prefix = "[" .._Env.. "] ";
    if _IsFile then
        Prefix = Prefix.. "[" ..Date.. "] ";
    end
    Prefix = Prefix ..LevelText.. ": ";
    return Prefix .. _Text;
end

---
-- Schreibt eine Log Meldung in die Logdatei.
--
-- @param[type=string]  _Text    Nachricht 
-- @param[type=number]  _Level   Scheregrad
-- @param[type=string]  _Env     Umgebung
-- @within Internal
-- @local
--
function Core:LogToFile(_Text, _Level, _Env)
    _Level = (tonumber(_Level) ~= nil and tonumber(_Level)) or 1;
    _Env = _Env or "Local";

    if QSB.Logging.FileLoggingLevel == QSB.Logging.Levels.Off then
        return;
    end
    if not GUI then
        _Env = "Global";
        Logic.ExecuteInLuaLocalState(string.format([[
            if not Core then
                return
            end
            Core:LogToFile("%s", "%d", "%s")
        ]], _Text, _Level, _Env));
        return;
    end
    if QSB.Logging.FileLoggingLevel <= _Level then
        local Text = Core:FormatLoggingMessage(_Text, _Level, true, _Env);
        Text = Text:gsub("{cr}", "\n");
        Framework.WriteToLog(Text);
    end
end
---
-- Schreibt eine Log Meldung auf den Bildschirm.
--
-- @param[type=string]  _Text    Nachricht 
-- @param[type=number]  _Level   Scheregrad
-- @param[type=string]  _Env     Umgebung
-- @within Internal
-- @local
--
function Core:LogToScreen(_Text, _Level, _Env)
    _Level = (tonumber(_Level) ~= nil and tonumber(_Level)) or 1;
    _Env = _Env or "Local";

    if QSB.Logging.DisplayLoggingLevel == QSB.Logging.Levels.Off then
        return;
    end
    if not GUI then
        _Env = "Global";
        Logic.ExecuteInLuaLocalState(string.format([[
            if not Core then
                return
            end
            Core:LogToScreen("%s", "%d", "%s")
        ]], _Text, _Level, _Env));
        return;
    end
    if QSB.Logging.DisplayLoggingLevel <= _Level then
        local Text = Core:FormatLoggingMessage(_Text, _Level, false, _Env);
        if _Level == 4 then
            GUI.AddStaticNote(Text);
        else
            GUI.AddNote(Text);
        end
    end
end

-- Überschreiben ---------------------------------------------------------------

-- API Stuff --

---
-- Wandelt underschiedliche Darstellungen einer Boolean in eine echte um.
--
-- Jeder String, der mit j, t, y oder + beginnt, wird als true interpretiert.
-- Alles andere als false.
--
-- Ist die Eingabe bereits ein Boolean wird es direkt zurückgegeben.
--
-- <p><b>Alias:</b> AcceptAlternativeBoolean</p>
--
-- @param _Value Wahrheitswert
-- @return[type=boolean] Wahrheitswert
-- @within Anwenderfunktionen
-- @local
--
-- @usage local Bool = API.ToBoolean("+")  --> Bool = true
-- local Bool = API.ToBoolean("no") --> Bool = false
--
function API.ToBoolean(_Value)
    return Core:ToBoolean(_Value);
end
AcceptAlternativeBoolean = API.ToBoolean;

---
-- Registriert eine Funktion, die nach dem laden ausgeführt wird.
--
-- <b>Alias</b>: AddOnSaveGameLoadedAction
--
-- @param[type=function] _Function Funktion, die ausgeführt werden soll
-- @within Anwenderfunktionen
-- @usage SaveGame = function()
--     API.Note("foo")
-- end
-- API.AddSaveGameAction(SaveGame)
--
function API.AddSaveGameAction(_Function)
    if GUI then
        log("API.AddSaveGameAction: Can not be used from the local script!", LEVEL_ERROR);
        return;
    end
    return Core:AppendFunction("Mission_OnSaveGameLoaded", _Function)
end
AddOnSaveGameLoadedAction = API.AddSaveGameAction;

-- Core Stuff --

Core.Data.Overwrite = {
    StackedFunctions = {},
    AppendedFunctions = {},
    Fields = {},
};

---
-- Erweitert eine Funktion um eine andere Funktion.
--
-- Jede hinzugefügte Funktion wird vor der Originalfunktion ausgeführt. Es
-- ist möglich, eine neue Funktion an einem bestimmten Index einzufügen. Diese
-- Funktion ist nicht gedacht, um sie direkt auszuführen. Für jede Funktion
-- im Spiel sollte eine API-Funktion erstellt werden.
--
-- Wichtig: Die gestapelten Funktionen, die vor der Originalfunktion
-- ausgeführt werden, müssen etwas zurückgeben, um die Funktion an
-- gegebener Stelle zu verlassen.
--
-- @param[type=string]   _FunctionName Name der erweiterten Funktion
-- @param[type=function] _StackFunction Neuer Funktionsinhalt
-- @param[type=number]   _Index Reihenfolgeindex
-- @within Internal
-- @local
--
function Core:StackFunction(_FunctionName, _StackFunction, _Index)
    if not self.Data.Overwrite.StackedFunctions[_FunctionName] then
        self.Data.Overwrite.StackedFunctions[_FunctionName] = {
            Original = self:GetFunctionInString(_FunctionName),
            Attachments = {}
        };

        local batch = function(...)
            local ReturnValue;
            for i= 1, #self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments, 1 do
                local Function = self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments[i];
                ReturnValue = {Function(unpack(arg))};
                if #ReturnValue > 0 then
                    return unpack(ReturnValue);
                end
            end
            ReturnValue = {self.Data.Overwrite.StackedFunctions[_FunctionName].Original(unpack(arg))};
            if ReturnValue then
                return unpack(ReturnValue);
            end
        end
        self:ReplaceFunction(_FunctionName, batch);
    end

    _Index = _Index or #self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments+1;
    table.insert(self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments, _Index, _StackFunction);
end

---
-- Erweitert eine Funktion um eine andere Funktion.
--
-- Jede hinzugefügte Funktion wird nach der Originalfunktion ausgeführt. Es
-- ist möglich eine neue Funktion an einem bestimmten Index einzufügen. Diese
-- Funktion ist nicht gedacht, um sie direkt auszuführen. Für jede Funktion
-- im Spiel sollte eine API-Funktion erstellt werden.
--
-- @param[type=string]   _FunctionName Name der erweiterten Funktion
-- @param[type=function] _AppendFunction Neuer Funktionsinhalt
-- @param[type=number]   _Index Reihenfolgeindex
-- @within Internal
-- @local
--
function Core:AppendFunction(_FunctionName, _AppendFunction, _Index)
    if not self.Data.Overwrite.AppendedFunctions[_FunctionName] then
        self.Data.Overwrite.AppendedFunctions[_FunctionName] = {
            Original = self:GetFunctionInString(_FunctionName),
            Attachments = {}
        };

        local batch = function(...)
            local ReturnValue = self.Data.Overwrite.AppendedFunctions[_FunctionName].Original(unpack(arg));
            for i= 1, #self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments, 1 do
                local Function = self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments[i];
                ReturnValue = {Function(unpack(arg))};
            end
            if ReturnValue then
                return unpack(ReturnValue);
            end
        end
        self:ReplaceFunction(_FunctionName, batch);
    end

    _Index = _Index or #self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments+1;
    table.insert(self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments, _Index, _AppendFunction);
end

---
-- Überschreibt eine Funktion mit einer anderen.
--
-- Funktionen in einer Tabelle werden überschrieben, indem jede Ebene des
-- Tables mit einem Punkt angetrennt wird.
--
-- @param[type=string]   _FunctionName Name der erweiterten Funktion
-- @param[type=function] _AppendFunction Neuer Funktionsinhalt
-- @local
-- @within Internal
-- @usage A = {foo = function() API.Note("bar") end}
-- B = function() API.Note("muh") end
-- Core:ReplaceFunction("A.foo", B)
-- -- A.foo() == B() => "muh"
--
function Core:ReplaceFunction(_FunctionName, _Function)
    assert(type(_FunctionName) == "string");
    local ref = _G;

    local s, e = _FunctionName:find("%.");
    while (s ~= nil) do
        local SubName = _FunctionName:sub(1, e-1);
        SubName = (tonumber(SubName) ~= nil and tonumber(SubName)) or SubName;

        ref = ref[SubName];
        _FunctionName = _FunctionName:sub(e+1);
        s, e = _FunctionName:find("%.");
    end

    local SubName = (tonumber(_FunctionName) ~= nil and tonumber(_FunctionName)) or _FunctionName;
    ref[SubName] = _Function;
end

---
-- Sucht eine Funktion mit dem angegebenen Namen.
--
-- Ist die Funktionen innerhalb einer Table, so sind alle Ebenen bis zum
-- Funktionsnamen mit anzugeben, abgetrennt durch einen Punkt.
--
-- @param[type=string] _FunctionName Name der erweiterten Funktion
-- @return[type=function] Referenz auf die Funktion
-- @within Internal
-- @local
--
function Core:GetFunctionInString(_FunctionName)
    assert(type(_FunctionName) == "string");
    local ref = _G;

    local s, e = _FunctionName:find("%.");
    while (s ~= nil) do
        local SubName = _FunctionName:sub(1, e-1);
        SubName = (tonumber(SubName) ~= nil and tonumber(SubName)) or SubName;

        ref = ref[SubName];
        _FunctionName = _FunctionName:sub(e+1);
        s, e = _FunctionName:find("%.");
    end

    local SubName = (tonumber(_FunctionName) ~= nil and tonumber(_FunctionName)) or _FunctionName;
    return ref[SubName];
end

-- Quests ----------------------------------------------------------------------

-- API Stuff --

---
-- Gibt die ID des Quests mit dem angegebenen Namen zurück. Existiert der
-- Quest nicht, wird nil zurückgegeben.
--
-- <p><b>Alias:</b> GetQuestID</p>
--
-- @param[type=string] _Name Name des Quest
-- @return[type=number] ID des Quest
-- @within Anwenderfunktionen
--
function API.GetQuestID(_Name)
    if type(_Name) == "number" then
        return _Name;
    end
    for k, v in pairs(Quests) do
        if v and k > 0 then
            if v.Identifier == _Name then
                return k;
            end
        end
    end
end
GetQuestID = API.GetQuestID;

---
-- Prüft, ob zu der angegebenen ID ein Quest existiert. Wird ein Questname
-- angegeben wird dessen Quest-ID ermittelt und geprüft.
--
-- <p><b>Alias:</b> IsValidQuest</p>
--
-- @param[type=number] _QuestID ID oder Name des Quest
-- @return[type=boolean] Quest existiert
-- @within Anwenderfunktionen
--
function API.IsValidQuest(_QuestID)
    return Quests[_QuestID] ~= nil or Quests[API.GetQuestID(_QuestID)] ~= nil;
end
IsValidQuest = API.IsValidQuest;

---
-- Lässt eine Liste von Quests fehlschlagen.
--
-- Der Status wird auf Over und das Resultat auf Failure gesetzt.
--
-- <p><b>Alias:</b> FailQuestsByName</p>
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.FailAllQuests(...)
    for i=1, #arg, 1 do
        API.FailQuest(arg[i]);
    end
end
FailQuestsByName = API.FailAllQuests;

---
-- Lässt den Quest fehlschlagen.
--
-- Der Status wird auf Over und das Resultat auf Failure gesetzt.
--
-- <p><b>Alias:</b> FailQuestByName</p>
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.FailQuest(_QuestName, _NoMessage)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest then
        if not _NoMessage then
            API.Note("fail quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Fail();
    end
end
FailQuestByName = API.FailQuest;

---
-- Startet eine Liste von Quests neu.
--
-- <p><b>Alias:</b> StartQuestsByName</p>
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.RestartAllQuests(...)
    for i=1, #arg, 1 do
        API.RestartQuest(arg[i]);
    end
end
RestartQuestsByName = API.RestartAllQuests;

---
-- Startet den Quest neu.
--
-- Der Quest muss beendet sein um ihn wieder neu zu starten. Wird ein Quest
-- neu gestartet, müssen auch alle Trigger wieder neu ausgelöst werden, außer
-- der Quest wird manuell getriggert.
--
-- Alle Änderungen an Standardbehavior müssen hier berücksichtigt werden. Wird
-- ein Standardbehavior in einem Bundle verändert, muss auch diese Funktion
-- angepasst oder überschrieben werden.
--
-- <p><b>Alias:</b> RestartQuestByName</p>
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.RestartQuest(_QuestName, _NoMessage)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            API.Note("restart quest " .._QuestName);
        end

        if Quest.Objectives then
            local questObjectives = Quest.Objectives;
            for i = 1, questObjectives[0] do
                local objective = questObjectives[i];
                objective.Completed = nil
                local objectiveType = objective.Type;

                if objectiveType == Objective.Deliver then
                    local data = objective.Data;
                    data[3] = nil;
                    data[4] = nil;
                    data[5] = nil;

                elseif g_GameExtraNo and g_GameExtraNo >= 1 and objectiveType == Objective.Refill then
                    objective.Data[2] = nil;

                elseif objectiveType == Objective.Protect or objectiveType == Objective.Object then
                    local data = objective.Data;
                    for j=1, data[0], 1 do
                        data[-j] = nil;
                    end

                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 2 and objective.DestroyTypeAmount then
                    objective.Data[3] = objective.DestroyTypeAmount;
                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 3 then
                    objective.Data[4] = nil;

                elseif objectiveType == Objective.Distance then
                    if objective.Data[1] == -65565 then
                        objective.Data[4].NpcInstance = nil;
                    end

                elseif objectiveType == Objective.Custom2 and objective.Data[1].Reset then
                    objective.Data[1]:Reset(Quest, i);
                end
            end
        end

        local function resetCustom(_type, _customType)
            local Quest = Quest;
            local behaviors = Quest[_type];
            if behaviors then
                for i = 1, behaviors[0] do
                    local behavior = behaviors[i];
                    if behavior.Type == _customType then
                        local behaviorDef = behavior.Data[1];
                        if behaviorDef and behaviorDef.Reset then
                            behaviorDef:Reset(Quest, i);
                        end
                    end
                end
            end
        end

        resetCustom("Triggers", Triggers.Custom2);
        resetCustom("Rewards", Reward.Custom);
        resetCustom("Reprisals", Reprisal.Custom);

        -- Quest Output zurücksetzen
        if Quest.Visible_OrigDebug then
            Quest.Visible = Quest.Visible_OrigDebug;
            Quest.Visible_OrigDebug = nil;
        end
        if Quest.ShowEndMessage then
            Quest.ShowEndMessage = Quest.ShowEndMessage_OrigDebug;
            Quest.ShowEndMessage_OrigDebug = nil;
        end
        if Quest.QuestStartMsg_OrigDebug then
            Quest.QuestStartMsg = Quest.QuestStartMsg_OrigDebug;
            Quest.QuestStartMsg_OrigDebug = nil;
        end
        if Quest.QuestSuccessMsg_OrigDebug then
            Quest.QuestSuccessMsg = Quest.QuestSuccessMsg_OrigDebug;
            Quest.QuestSuccessMsg_OrigDebug = nil;
        end
        if Quest.QuestFailureMsg_OrigDebug then
            Quest.QuestFailureMsg = Quest.QuestFailureMsg_OrigDebug;
            Quest.QuestFailureMsg_OrigDebug = nil;
        end

        Quest.Result = nil;
        local OldQuestState = Quest.State;
        Quest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..Quest.Index..")");
        if OldQuestState == QuestState.Over then
            StartSimpleJobEx(_G[QuestTemplate.Loop], Quest.QueueID);
        end
        return QuestID, Quest;
    end
end
RestartQuestByName = API.RestartQuest;

---
-- Startet eine Liste von Quests.
--
-- <p><b>Alias:</b> StartQuestsByName</p>
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.StartAllQuests(...)
    for i=1, #arg, 1 do
        API.StartQuest(arg[i]);
    end
end
StartQuestsByName = API.StartAllQuests;

---
-- Startet den Quest sofort, sofern er existiert.
--
-- Dabei ist es unerheblich, ob die Bedingungen zum Start erfüllt sind.
--
-- <p><b>Alias:</b> StartQuestByName</p>
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.StartQuest(_QuestName, _NoMessage)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest then
        if not _NoMessage then
            API.Note("start quest " .._QuestName);
        end
        Quest:SetMsgKeyOverride();
        Quest:SetIconOverride();
        Quest:Trigger();
    end
end
StartQuestByName = API.StartQuest;

---
-- Unterbricht eine Liste von Quests.
--
-- <p><b>Alias:</b> StopQuestsByName</p>
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.StopAllQuests(...)
    for i=1, #arg, 1 do
        API.StopQuest(arg[i]);
    end
end
StopQuestsByName = API.StopAllQuests;

---
-- Unterbricht den Quest.
--
-- Der Status wird auf Over und das Resultat auf Interrupt gesetzt. Sind Marker
-- gesetzt, werden diese entfernt.
--
-- <p><b>Alias:</b> StopQuestByName</p>
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.StopQuest(_QuestName, _NoMessage)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest then
        if not _NoMessage then
            API.Note("interrupt quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Interrupt(-1);
    end
end
StopQuestByName = API.StopQuest;

---
-- Gewinnt eine Liste von Quests.
--
-- Der Status wird auf Over und das Resultat auf Success gesetzt.
--
-- <p><b>Alias:</b> WinQuestsByName</p>
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.WinAllQuests(...)
    for i=1, #arg, 1 do
        API.WinQuest(arg[i]);
    end
end
WinQuestsByName = API.WinAllQuests;

---
-- Gewinnt den Quest.
--
-- Der Status wird auf Over und das Resultat auf Success gesetzt.
--
-- <p><b>Alias:</b> WinQuestByName</p>
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.WinQuest(_QuestName, _NoMessage)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest then
        if not _NoMessage then
            API.Note("win quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Success();
    end
end
WinQuestByName = API.WinQuest;

-- Core Stuff --

---
-- Prüft, ob der Questname formal korrekt ist. Questnamen dürfen i.d.R. nur
-- die Zeichen A-Z, a-7, 0-9, Umlaute und _ enthalten.
--
-- @param[type=string] _Name Name des Quest
-- @return[type=boolean] Questname ist fehlerfrei
-- @within Internal
-- @local
--
function Core:CheckQuestName(_Name)
    return string.find(_Name, "^[A-Za-z0-9_ @ÄÖÜäöüß]+$") ~= nil;
end

---
-- Ändert den Text des Beschreibungsfensters eines Quests. Die Beschreibung
-- wird erst dann aktualisiert, wenn der Quest ausgeblendet wird.
--
-- @param[type=string] _Text Neuer Text
-- @param[type=table] _Quest Quest Table
-- @within Internal
-- @local
--
function Core:ChangeCustomQuestCaptionText(_Text, _Quest)
    if _Quest and _Quest.Visible then
        _Quest.QuestDescription = _Text;
        Logic.ExecuteInLuaLocalState([[
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/BGDeco",0)
            local identifier = "]].._Quest.Identifier..[["
            for i=1, Quests[0] do
                if Quests[i].Identifier == identifier then
                    local text = Quests[i].QuestDescription
                    XGUIEng.SetText("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/Text", "]].._Text..[[")
                    break
                end
            end
        ]]);
    end
end

-- Scripting Values ------------------------------------------------------------

-- API Stuff --

---
-- Rundet eine Dezimalzahl kaufmännisch ab.
--
-- <b>Hinweis</b>: Es wird manuell gerundet um den Rundungsfehler in der
-- History Edition zu umgehen.
--
-- <p><b>Alias:</b> Round</p>
--
-- @param[type=string] _Value         Zu rundender Wert
-- @param[type=string] _DecimalDigits Maximale Dezimalstellen
-- @return[type=number] Abgerundete Zahl
-- @within Anwenderfunktionen
--
function API.Round(_Value, _DecimalDigits)
    _DecimalDigits = _DecimalDigits or 2;
    _DecimalDigits = (_DecimalDigits < 0 and 0) or _DecimalDigits;
    local Value = tostring(_Value);
    if tonumber(Value) == nil then
        return 0;
    end
    local s,e = Value:find(".", 1, true);
    if e then
        local Overhead = nil;
        if Value:len() > e + _DecimalDigits then
            if _DecimalDigits > 0 then
                local TmpNum;
                if tonumber(Value:sub(e+_DecimalDigits+1, e+_DecimalDigits+1)) >= 5 then
                    TmpNum = tonumber(Value:sub(e+1, e+_DecimalDigits)) +1;
                    Overhead = (_DecimalDigits == 1 and TmpNum == 10);
                else
                    TmpNum = tonumber(Value:sub(e+1, e+_DecimalDigits));
                end
                Value = Value:sub(1, e-1);
                if (tostring(TmpNum):len() >= _DecimalDigits) then
                    Value = Value .. "." ..TmpNum;
                end
            else
                local NewValue = tonumber(Value:sub(1, e-1));
                if tonumber(Value:sub(e+_DecimalDigits+1, e+_DecimalDigits+1)) >= 5 then
                    NewValue = NewValue +1;
                end
                Value = NewValue;
            end
        else
            Value = (Overhead and (tonumber(Value) or 0) +1) or
                     Value .. string.rep("0", Value:len() - (e + _DecimalDigits))
        end
    end
    return tonumber(Value);
end
Round = API.Round;

-- Core Stuff --

QSB.HistoryEdition = false;
QSB.ScriptingValues = QSB.ScriptingValues or {
    Game = "Vanilla",
    Vanilla = {
        Destination = {X = 19, Y= 20},
        Health      = -41,
        Player      = -71,
        Size        = -45,
        Visible     = -50,
    },
    HistoryEdition = {
        Destination = {X = 17, Y= 18},
        Health      = -38,
        Player      = -68,
        Size        = -42,
        Visible     = -47,
    }
}

---
-- Überschreibt die Hotkey-Funktion, die das Spiel speichert. Durch die
-- Prüfung, ob Briefings oder Cutscenes aktiv sind, wird vermieden, dass
-- die History Edition automatisch speichert.
--
-- @within Internal
-- @local
--
function Core:SetupLocal_HistoryEditionAutoSave()
    KeyBindings_SaveGame_Orig_Core_SaveGame = KeyBindings_SaveGame;
    KeyBindings_SaveGame = function()
        -- In der History Edition wird diese Funktion aufgerufen, wenn der
        -- letzte Spielstand der Map älter als 15 Minuten ist. Wenn ein
        -- Briefing oder eine Cutscene aktiv ist, sollen keine Quicksaves
        -- erstellt werden.
        if not Core:CanGameBeSaved() then
            return;
        end
        KeyBindings_SaveGame_Orig_Core_SaveGame();
    end
end

---
-- Identifiziert anhand der um +3 Verschobenen PlayerID bei den Scripting
-- Values die infamous History Edition. Ob es sich um die History Edition
-- hält, wird in der Variable QSB.HistoryEdition gespeichert.
--
-- TODO: Es sollten mehr Kritieren als nur die PlayerID geprüft werden!
--
-- @within Internal
-- @local
--
function Core:IdentifyHistoryEdition()
    local EntityID = Logic.CreateEntity(Entities.U_NPC_Amma_NE, 100, 100, 0, 8);
    MakeInvulnerable(EntityID);
    if Logic.GetEntityScriptingValue(EntityID, -68) == 8 then
        Logic.ExecuteInLuaLocalState([[
            QSB = QSB or {}
            QSB.HistoryEdition = true
            QSB.ScriptingValues = QSB.ScriptingValues or {}
            QSB.ScriptingValues.Game = 'HistoryEdition'
        ]]);
        QSB = QSB or {};
        QSB.HistoryEdition = true;
        QSB.ScriptingValues.Game = "HistoryEdition";
    end
    DestroyEntity(EntityID);
end

---
-- Bestimmt das Modul b der Zahl a.
--
-- @param[type=number] a Zahl
-- @param[type=number] b Modul
-- @return[type=number] qmod der Zahl
-- @within Internal
-- @local
--
function Core:qmod(a, b)
    return a - math.floor(a/b)*b
end

---
-- Gibt den Integer als Bits zurück.
--
-- @param[type=number] num Bits
-- @return[type=table] Table mit Bits
-- @within Internal
-- @local
--
function Core:ScriptingValueBitsInteger(num)
    local t={}
    while num>0 do
        rest=self:qmod(num, 2) table.insert(t,1,rest) num=(num-rest)/2
    end
    table.remove(t, 1)
    return t
end

---
-- Stellt eine Zahl als eine Folge von Bits in einer Table dar.
--
-- @param[type=number] num Integer
-- @param[type=table]  t   Table
-- @return[type=table] Table mit Bits
-- @within Internal
-- @local
--
function Core:ScriptingValueBitsFraction(num, t)
    for i = 1, 48 do
        num = num * 2
        if(num >= 1) then table.insert(t, 1); num = num - 1 else table.insert(t, 0) end
        if(num == 0) then return t end
    end
    return t
end

---
-- Konvertiert eine Ganzzahl in eine Dezimalzahl.
--
-- @param[type=number] num Integer
-- @return[type=number] Integer als Float
-- @within Internal
-- @local
--
function Core:ScriptingValueIntegerToFloat(num)
    if(num == 0) then return 0 end
    local sign = 1
    if(num < 0) then num = 2147483648 + num; sign = -1 end
    local frac = self:qmod(num, 8388608)
    local headPart = (num-frac)/8388608
    local expNoSign = self:qmod(headPart, 256)
    local exp = expNoSign-127
    local fraction = 1
    local fp = 0.5
    local check = 4194304
    for i = 23, 0, -1 do
        if(frac - check) > 0 then fraction = fraction + fp; frac = frac - check end
        check = check / 2; fp = fp / 2
    end
    return fraction * math.pow(2, exp) * sign
end

---
-- Konvertiert eine Dezimalzahl in eine Ganzzahl.
--
-- @param[type=number] fval Float
-- @return[type=number] Float als Integer
-- @within Internal
-- @local
--
function Core:ScriptingValueFloatToInteger(fval)
    if(fval == 0) then return 0 end
    local signed = false
    if(fval < 0) then signed = true; fval = fval * -1 end
    local outval = 0;
    local bits
    local exp = 0
    if fval >= 1 then
        local intPart = math.floor(fval); local fracPart = fval - intPart;
        bits = self:ScriptingValueBitsInteger(intPart); exp = table.getn(bits); self:ScriptingValueBitsFraction(fracPart, bits)
    else
        bits = {}; self:ScriptingValueBitsFraction(fval, bits)
        while(bits[1] == 0) do exp = exp - 1; table.remove(bits, 1) end
        exp = exp - 1
        table.remove(bits, 1)
    end
    local bitVal = 4194304; local start = 1
    for bpos = start, 23 do
        local bit = bits[bpos]
        if(not bit) then break; end
        if(bit == 1) then outval = outval + bitVal end
        bitVal = bitVal / 2
    end
    outval = outval + (exp+127)*8388608
    if(signed) then outval = outval - 2147483648 end
    return outval;
end

-- Events ----------------------------------------------------------------------

-- API Stuff --

---
-- Gibt zurück, ob der Ladebildschirm sichtbar ist.
--
-- @return[type=boolean] Ladebildschirm ist sichtbar
-- @within Anwenderfunktionen
--
function API.IsLoadscreenVisible()
    return not Core.Data.LoadScreenHidden == true;
end

---
-- Pausiert einen laufenden Job.
--
-- <b>Hinweis</b>: Der Job darf nicht direkt mit Trigger.RequestTrigger
-- gestartet worden sein.
--
-- <b>Alias</b>: YieldJob
--
-- @param[type=number] _JobID Job-ID
-- @within Anwenderfunktionen
--
function API.YieldJob(_JobID)
    for k, v in pairs(Core.Data.EventJobs) do
        if Core.Data.EventJobs[k][_JobID] then
            Core.Data.EventJobs[k][_JobID].Enabled = false;
        end
    end
end
YieldJob = API.YieldJob;

---
-- Aktiviert einen angehaltenen Job.
--
-- <b>Hinweis</b>: Der Job darf nicht direkt mit Trigger.RequestTrigger
-- gestartet worden sein.
--
-- <b>Alias</b>: ResumeJob
--
-- @param[type=number] _JobID Job-ID
-- @within Anwenderfunktionen
--
function API.ResumeJob(_JobID)
    for k, v in pairs(Core.Data.EventJobs) do
        if Core.Data.EventJobs[k][_JobID] then
            Core.Data.EventJobs[k][_JobID].Enabled = true;
        end
    end
end
ResumeJob = API.ResumeJob;

---
-- Prüft ob der angegebene Job aktiv und eingeschaltet ist.
--
-- <b>Alias</b>: JobIsRunning
--
-- @param[type=number] _JobID Job-ID
-- @within Anwenderfunktionen
--
function API.JobIsRunning(_JobID)
    for k, v in pairs(Core.Data.EventJobs) do
        if Core.Data.EventJobs[k][_JobID] then
            if Core.Data.EventJobs[k][_JobID].Active == true and Core.Data.EventJobs[k][_JobID].Enabled == true then
                return true;
            end
        end
    end
    return false;
end
JobIsRunning = API.JobIsRunning;

---
-- Beendet einen aktiven Job endgültig.
--
-- <b>Alias</b>: ResumeJob
--
-- @param[type=number] _JobID Job-ID
-- @within Anwenderfunktionen
--
function API.EndJob(_JobID)
    for k, v in pairs(Core.Data.EventJobs) do
        if Core.Data.EventJobs[k][_JobID] then
            Core.Data.EventJobs[k][_JobID].Active = false;
            return;
        end
    end
end
EndJob = API.EndJob;

---
-- Erzeugt einen neuen Event-Job.
--
-- <b>Hinweis</b>: Nur wenn ein Event Job mit dieser Funktion gestartet wird,
-- können ResumeJob und YieldJob auf den Job angewendet werden.
--
-- <b>Hinweis</b>: Events.LOGIC_EVENT_ENTITY_CREATED funktioniert nicht!
--
-- <b>Hinweis</b>: Wird ein Table als Argument an den Job übergeben, wird eine
-- Kopie angeleigt um Speicherprobleme zu verhindern. Es handelt sich also um
-- eine neue Table und keine Referenz!
--
-- @param[type=number]   _EventType Event-Typ
-- @param _Function      Funktion (Funktionsreferenz oder String)
-- @param ...            Optionale Argumente des Job
-- @return[type=number] ID des Jobs
-- @within Anwenderfunktionen
--
function API.StartEventJob(_EventType, _Function, ...)
    local Function = _Function;
    if type(Function) == "string" then
        Function = _G[Function];
    end
    if type(Function) ~= "function" and type(_Function) == "string" then
        error(string.format("API.StartEventJob: Can not find function for name '%s'!", _Function));
        return;
    elseif type(Function) ~= "function" and type(_Function) ~= "string" then
        error("API.StartEventJob: Received illegal reference as function!");
        return;
    end

    Core.Data.EventJobID = Core.Data.EventJobID +1;
    local ID = Core.Data.EventJobID
    Core.Data.EventJobs[_EventType][ID] = {
        Function = Function,
        Arguments = API.InstanceTable(arg);
        Active = true,
        Enabled = true,
    }
    return ID;
end

---
-- Fügt eine Funktion als Job hinzu, die einmal pro Sekunde ausgeführt
-- wird. Die Argumente werden an die Funktion übergeben.
--
-- Die Funktion kann als Referenz, Inline oder als String übergeben werden.
--
-- <b>Alias</b>: StartSimpleJobEx
--
-- <b>Alias</b>: StartSimpleJob
--
-- @param _Function Funktion (Funktionsreferenz oder String)
-- @param ...       Liste von Argumenten
-- @return[type=number] Job ID
-- @within Anwenderfunktionen
--
-- @usage -- Führt eine Funktion nach 15 Sekunden aus.
-- API.StartJob(function(_Time, _EntityType)
--     if Logic.GetTime() > _Time + 15 then
--         MachWas(_EntityType);
--         return true;
--     end
-- end, Logic.GetTime(), Entities.U_KnightHealing)
--
-- -- Startet einen Job
-- StartSimpleJob("MeinJob");
--
function API.StartJob(_Function, ...)
    return API.StartEventJob(Events.LOGIC_EVENT_EVERY_SECOND, _Function, unpack(arg));
end
StartSimpleJob = API.StartJob;
StartSimpleJobEx = API.StartJob;

---
-- Fügt eine Funktion als Job hinzu, die zehn Mal pro Sekunde ausgeführt
-- wird. Die Argumente werden an die Funktion übergeben.
--
-- Die Funktion kann als Referenz, Inline oder als String übergeben werden.
--
-- <b>Alias</b>: StartSimpleHiResJobEx
--
-- <b>Alias</b>: StartSimpleHiResJob
--
-- @param _Function Funktion (Funktionsreferenz oder String)
-- @param ...       Liste von Argumenten
-- @return[type=number] Job ID
-- @within Anwenderfunktionen
--
function API.StartHiResJob(_Function, ...)
    return API.StartEventJob(Events.LOGIC_EVENT_EVERY_TURN, _Function, unpack(arg));
end
StartSimpleHiResJob = API.StartHiResJob;
StartSimpleHiResJobEx = API.StartHiResJob;

-- Core Stuff --

Core.Data.LoadScreenHidden = false;
Core.Data.EventJobID = 0;
Core.Data.EventJobs = {
    [Events.LOGIC_EVENT_DIPLOMACY_CHANGED]         = {},
    [Events.LOGIC_EVENT_ENTITY_CREATED]            = {},
    [Events.LOGIC_EVENT_ENTITY_DESTROYED]          = {},
    [Events.LOGIC_EVENT_ENTITY_HURT_ENTITY]        = {},
    [Events.LOGIC_EVENT_ENTITY_IN_RANGE_OF_ENTITY] = {},
    [Events.LOGIC_EVENT_EVERY_SECOND]              = {},
    [Events.LOGIC_EVENT_EVERY_TURN]                = {},
    [Events.LOGIC_EVENT_GOODS_TRADED]              = {},
    [Events.LOGIC_EVENT_PLAYER_DIED]               = {},
    [Events.LOGIC_EVENT_RESEARCH_DONE]             = {},
    [Events.LOGIC_EVENT_TRIBUTE_PAID]              = {},
    [Events.LOGIC_EVENT_WEATHER_STATE_CHANGED]     = {},
};

---
-- Führt alle Event Jobs des angegebenen Typen aus und prüft deren Status.
--
-- @param[type=number] _Type Typ des Jobs
-- @within Internal
-- @local
--
function Core:TriggerEventJobs(_Type)
    for k, v in pairs(self.Data.EventJobs[_Type]) do
        if type(v) == "table" then
            if v.Active == false then
                self.Data.EventJobs[_Type][k] = nil;
            else
                if v.Enabled then
                    if v.Function then
                        local Arguments = v.Arguments or {};
                        if v.Function(unpack(Arguments)) == true then
                            self.Data.EventJobs[_Type][k] = nil;
                        end
                    end
                end
            end
        end
    end
end

-- Ein Job, der eine Variable setzt, sobald der Loadscreen beendet ist.
function Core.EventJob_WaitForLoadScreenHidden()
    if XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then
        GUI.SendScriptCommand("Core.Data.LoadScreenHidden = true");
        Core.Data.LoadScreenHidden = true;
        return true;
    end
end

-- Folgende Jobs steuern den Trigger Fix. Prinzipiell wird für jede Art Trigger
-- ein bestimmter Trigger erstellt, der dann die eigentlichen Trigger aufruft
-- und ihren Zustand abfragt.

function Core.EventJob_OnDiplomacyChanged()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_DIPLOMACY_CHANGED);
end
CoreEventJob_OnDiplomacyChanged = Core.EventJob_OnDiplomacyChanged;


function Core.EventJob_OnEntityCreated()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_ENTITY_CREATED);
end
CoreEventJob_OnEntityCreated = Core.EventJob_OnEntityCreated


function Core.EventJob_OnEntityDestroyed()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_ENTITY_DESTROYED);
end
CoreEventJob_OnEntityDestroyed = Core.EventJob_OnEntityDestroyed;


function Core.EventJob_OnEntityHurtEntity()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_ENTITY_HURT_ENTITY);
end
CoreEventJob_OnEntityHurtEntity = Core.EventJob_OnEntityHurtEntity;


function Core.EventJob_OnEntityInRangeOfEntity()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_ENTITY_IN_RANGE_OF_ENTITY);
end
CoreEventJob_OnEntityInRangeOfEntity = Core.EventJob_OnEntityInRangeOfEntity;


function Core.EventJob_OnEverySecond()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_EVERY_SECOND);
end
CoreEventJob_OnEverySecond = Core.EventJob_OnEverySecond;


function Core.EventJob_OnEveryTurn()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_EVERY_TURN);
end
CoreEventJob_OnEveryTurn = Core.EventJob_OnEveryTurn;


function Core.EventJob_OnGoodsTraded()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_GOODS_TRADED);
end
CoreEventJob_OnGoodsTraded = Core.EventJob_OnGoodsTraded;


function Core.EventJob_OnPlayerDied()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_PLAYER_DIED);
end
CoreEventJob_OnPlayerDied = Core.EventJob_OnPlayerDied;


function Core.EventJob_OnResearchDone()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_RESEARCH_DONE);
end
CoreEventJob_OnResearchDone = Core.EventJob_OnResearchDone;


function Core.EventJob_OnTributePaied()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_TRIBUTE_PAID);
end
CoreEventJob_OnTributePaied = Core.EventJob_OnTributePaied;


function Core.EventJob_OnWatherChanged()
    Core:TriggerEventJobs(Events.LOGIC_EVENT_WEATHER_STATE_CHANGED);
end
CoreEventJob_OnWatherChanged = Core.EventJob_OnWatherChanged;

-- Hotkeys ---------------------------------------------------------------------

-- API Stuff --

---
-- Fügt eine Beschreibung zu einem selbst gewählten Hotkey hinzu.
--
-- Ist der Hotkey bereits vorhanden, wird -1 zurückgegeben.
--
-- @param[type=string] _Key         Tastenkombination
-- @param[type=string] _Description Beschreibung des Hotkey
-- @return[type=number] Index oder Fehlercode
-- @within Anwenderfunktionen
--
function API.AddHotKey(_Key, _Description)
    if not GUI then
        return;
    end
    g_KeyBindingsOptions.Descriptions = nil;
    table.insert(Core.Data.HotkeyDescriptions, {_Key, _Description});
    return #Core.Data.HotkeyDescriptions;
end

---
-- Entfernt eine Beschreibung eines selbst gewählten Hotkeys.
--
-- @param[type=number] _Index Index in Table
-- @within Anwenderfunktionen
--
function API.RemoveHotKey(_Index)
    if not GUI then
        return;
    end
    if type(_Index) ~= "number" or _Index > #Core.Data.HotkeyDescriptions then
        log("API.RemoveHotKey: No candidate found or Index is nil!", LEVEL_ERROR);
        return;
    end
    Core.Data.HotkeyDescriptions[_Index] = nil;
end

-- Core Stuff --

Core.Data.HotkeyDescriptions = {};

---
-- Überschreibt das Hotkey-Register, sodass eigene Hotkeys mit im Menü
-- angezeigt werden können.
-- @within Internal
-- @local
--
function Core:SetupLocal_HackRegisterHotkey()
    function g_KeyBindingsOptions:OnShow()
        if Game ~= nil then
            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 1);
        else
            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 0);
        end

        if g_KeyBindingsOptions.Descriptions == nil then
            g_KeyBindingsOptions.Descriptions = {};
            DescRegister("MenuInGame");
            DescRegister("MenuDiplomacy");
            DescRegister("MenuProduction");
            DescRegister("MenuPromotion");
            DescRegister("MenuWeather");
            DescRegister("ToggleOutstockInformations");
            DescRegister("JumpMarketplace");
            DescRegister("JumpMinimapEvent");
            DescRegister("BuildingUpgrade");
            DescRegister("BuildLastPlaced");
            DescRegister("BuildStreet");
            DescRegister("BuildTrail");
            DescRegister("KnockDown");
            DescRegister("MilitaryAttack");
            DescRegister("MilitaryStandGround");
            DescRegister("MilitaryGroupAdd");
            DescRegister("MilitaryGroupSelect");
            DescRegister("MilitaryGroupStore");
            DescRegister("MilitaryToggleUnits");
            DescRegister("UnitSelect");
            DescRegister("UnitSelectToggle");
            DescRegister("UnitSelectSameType");
            DescRegister("StartChat");
            DescRegister("StopChat");
            DescRegister("QuickSave");
            DescRegister("QuickLoad");
            DescRegister("TogglePause");
            DescRegister("RotateBuilding");
            DescRegister("ExitGame");
            DescRegister("Screenshot");
            DescRegister("ResetCamera");
            DescRegister("CameraMove");
            DescRegister("CameraMoveMouse");
            DescRegister("CameraZoom");
            DescRegister("CameraZoomMouse");
            DescRegister("CameraRotate");

            for k,v in pairs(Core.Data.HotkeyDescriptions) do
                if v then
                    v[1] = (type(v[1]) == "table" and API.Localize(v[1])) or v[1];
                    v[2] = (type(v[2]) == "table" and API.Localize(v[2])) or v[2];
                    table.insert(g_KeyBindingsOptions.Descriptions, 1, v);
                end
            end
        end
        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ShortcutList);
        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ActionList);
        for Index, Desc in ipairs(g_KeyBindingsOptions.Descriptions) do
            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ShortcutList, Desc[1]);
            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ActionList,   Desc[2]);
        end
    end
end

-- Echtzeit --------------------------------------------------------------------

QSB.RealTime_SecondsSinceGameStart = 0;

-- API Stuff --

---
-- Gibt die real vergangene Zeit seit dem Spielstart in Sekunden zurück.
-- @return[type=number] Vergangene reale Zeit
-- @within Anwenderfunktionen
--
function API.RealTimeGetSecondsPassedSinceGameStart()
    return QSB.RealTime_SecondsSinceGameStart;
end

---
-- Wartet die angebene Zeit in realen Sekunden und führt anschließend das
-- Callback aus. Die Ausführung erfolgt asynchron. Das bedeutet, dass das
-- Skript weiterläuft.
--
-- Hinweis: Einmal gestartet, kann wait nicht beendet werden.
--
-- @param[type=number] _Waittime Wartezeit in realen Sekunden
-- @param[type=function] _Action Callback-Funktion
-- @param ... Liste der Argumente
-- @return[type=number] Vergangene reale Zeit
-- @within Anwenderfunktionen
--
function API.RealTimeWait(_Waittime, _Action, ...)
    StartSimpleJobEx( function(_StartTime, _Delay, _Callback, _Arguments)
        if (QSB.RealTime_SecondsSinceGameStart >= _StartTime + _Delay) then
            if #_Arguments > 0 then
                _Callback(unpack(_Arguments));
            else
                _Callback();
            end
            return true;
        end
    end, QSB.RealTime_SecondsSinceGameStart, _Waittime, _Action, {...});
end

-- Core Stuff --

-- Dieser Job ermittelt automatisch, ob eine Sekunde reale Zeit vergangen ist
-- und zählt eine Variable hoch, die die gesamt verstrichene reale Zeit hält.

function Core.EventJob_EventOnEveryRealTimeSecond()
    if not QSB.RealTime_LastTimeStamp then
        QSB.RealTime_LastTimeStamp = math.floor(Framework.TimeGetTime());
    end
    local CurrentTimeStamp = math.floor(Framework.TimeGetTime());

    -- Eine Sekunde ist vergangen
    if QSB.RealTime_LastTimeStamp ~= CurrentTimeStamp then
        QSB.RealTime_LastTimeStamp = CurrentTimeStamp;
        QSB.RealTime_SecondsSinceGameStart = QSB.RealTime_SecondsSinceGameStart +1;
    end
end

-- Entities --------------------------------------------------------------------

-- Mögliche (zufällige) Siedler getrennt in männlich und weiblich.
QSB.PossibleSettlerTypes = {
    Male = {
        Entities.U_BannerMaker,
        Entities.U_Baker,
        Entities.U_Barkeeper,
        Entities.U_Blacksmith,
        Entities.U_Butcher,
        Entities.U_BowArmourer,
        Entities.U_BowMaker,
        Entities.U_CandleMaker,
        Entities.U_Carpenter,
        Entities.U_DairyWorker,
        Entities.U_Pharmacist,
        Entities.U_Tanner,
        Entities.U_SmokeHouseWorker,
        Entities.U_Soapmaker,
        Entities.U_SwordSmith,
        Entities.U_Weaver,
    },
    Female = {
        Entities.U_BathWorker,
        Entities.U_SpouseS01,
        Entities.U_SpouseS02,
        Entities.U_SpouseS03,
        Entities.U_SpouseF01,
        Entities.U_SpouseF02,
        Entities.U_SpouseF03,
    }
}

-- API Stuff --

---
-- Wählt aus einer Liste von Typen einen zufälligen Siedler-Typ aus. Es werden
-- nur Stadtsiedler zurückgegeben. Sie können männlich oder weiblich sein.
--
-- @return[type=number] Zufälliger Typ
-- @within Anwenderfunktionen
-- @local
--
function API.GetRandomSettlerType()
    local Gender = (math.random(1, 2) == 1 and "Male") or "Female";
    local Type   = math.random(1, #QSB.PossibleSettlerTypes[Gender]);
    return QSB.PossibleSettlerTypes[Gender][Type];
end

---
-- Wählt aus einer Liste von Typen einen zufälligen männlichen Siedler aus. Es
-- werden nur Stadtsiedler zurückgegeben.
--
-- @return[type=number] Zufälliger Typ
-- @within Anwenderfunktionen
-- @local
--
function API.GetRandomMaleSettlerType()
    local Type = math.random(1, #QSB.PossibleSettlerTypes.Male);
    return QSB.PossibleSettlerTypes.Male[Type];
end

---
-- Wählt aus einer Liste von Typen einen zufälligen weiblichen Siedler aus. Es
-- werden nur Stadtsiedler zurückgegeben.
--
-- @return[type=number] Zufälliger Typ
-- @within Anwenderfunktionen
-- @local
--
function API.GetRandomFemaleSettlerType()
    local Type = math.random(1, #QSB.PossibleSettlerTypes.Female);
    return QSB.PossibleSettlerTypes.Female[Type];
end

---
-- Sendet einen Handelskarren zu dem Spieler. Startet der Karren von einem
-- Gebäude, wird immer die Position des Eingangs genommen.
--
-- <p><b>Alias:</b> SendCart</p>
--
-- @param _position                        Position (Skriptname oder Positionstable)
-- @param[type=number] _player             Zielspieler
-- @param[type=number] _good               Warentyp
-- @param[type=number] _amount             Warenmenge
-- @param[type=number] _cartOverlay        (optional) Overlay für Goldkarren
-- @param[type=boolean] _ignoreReservation (optional) Marktplatzreservation ignorieren
-- @return[type=number] Entity-ID des erzeugten Wagens
-- @within Anwenderfunktionen
-- @usage -- API-Call
-- API.SendCart(Logic.GetStoreHouse(1), 2, Goods.G_Grain, 45)
-- -- Legacy-Call mit ID-Speicherung
-- local ID = SendCart("Position_1", 5, Goods.G_Wool, 5)
--
function API.SendCart(_position, _player, _good, _amount, _cartOverlay, _ignoreReservation)
    local eID = GetID(_position);
    if not IsExisting(eID) then
        return;
    end
    local ID;
    local x,y,z = Logic.EntityGetPos(eID);
    local resCat = Logic.GetGoodCategoryForGoodType(_good);
    local orientation = 0;
    if Logic.IsBuilding(eID) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID);
        orientation = Logic.GetEntityOrientation(eID)-90;
    end

    -- Macht Waren lagerbar im Lagerhaus
    if resCat == GoodCategories.GC_Resource or _good == Goods.G_None then
        local TypeName = Logic.GetGoodTypeName(_good);
        local Category = Logic.GetGoodCategoryForGoodType(_good);
        local SHID = Logic.GetStoreHouse(_player);
        local HQID = Logic.GetHeadquarters(_player);
        if SHID ~= 0 and Logic.GetIndexOnInStockByGoodType(SHID, _good) == -1 then
            local CreateSlot = true;
            if _good ~= Goods.G_Gold or (_good == Goods.G_Gold and HQID == 0) then
                info(
                    "API.SendCart: creating stock for " ..TypeName.. " in" ..
                    "storehouse of player " .._player.. "."
                );
                Logic.AddGoodToStock(SHID, _good, 0, true, true);
            end
        end
    end

    info("API.SendCart: Creating cart ("..
        tostring(_position) ..","..
        tostring(_player) ..","..
        Logic.GetGoodTypeName(_good) ..","..
        tostring(_amount) ..","..
        tostring(_cartOverlay) ..","..
        tostring(_ignoreReservation) ..
    ")");

    if resCat == GoodCategories.GC_Resource then
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_ResourceMerchant, x, y,orientation,_player)
    elseif _good == Goods.G_Medicine then
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Medicus, x, y,orientation,_player)
    elseif _good == Goods.G_Gold or _good == Goods.G_None or _good == Goods.G_Information then
        if _cartOverlay then
            ID = Logic.CreateEntityOnUnblockedLand(_cartOverlay, x, y,orientation,_player)
        else
            ID = Logic.CreateEntityOnUnblockedLand(Entities.U_GoldCart, x, y,orientation,_player)
        end
    else
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Marketer, x, y,orientation,_player)
    end
    info("API.SendCart: Executing hire merchant...");
    Logic.HireMerchant( ID, _player, _good, _amount, _player, _ignoreReservation)
    info("API.SendCart: Cart has been send successfully.");
    return ID
end
SendCart = API.SendCart;

---
-- Ersetzt ein Entity mit einem neuen eines anderen Typs. Skriptname,
-- Rotation, Position und Besitzer werden übernommen.
--
-- <b>Hinweis</b>: Die Entity-ID ändert sich und beim Ersetzen von
-- Spezialgebäuden kann eine Niederlage erfolgen.
--
-- <p><b>Alias:</b> ReplaceEntity</p>
--
-- @param _Entity      Entity (Skriptname oder ID)
-- @param[type=number] _Type     Neuer Typ
-- @param[type=number] _NewOwner (optional) Neuer Besitzer
-- @return[type=number] Entity-ID des Entity
-- @within Anwenderfunktionen
-- @usage API.ReplaceEntity("Stein", Entities.XD_ScriptEntity)
--
function API.ReplaceEntity(_Entity, _Type, _NewOwner)
    local eID = GetID(_Entity);
    if eID == 0 then
        return;
    end
    local pos = GetPosition(eID);
    local player = _NewOwner or Logic.EntityGetPlayer(eID);
    local orientation = Logic.GetEntityOrientation(eID);
    local name = Logic.GetEntityName(eID);
    DestroyEntity(eID);
    info("API.ReplaceEntity: Replacing entity " ..tostring(_Entity).. " to type " ..Logic.GetEntityTypeName(_Type).. ".");
    if Logic.IsEntityTypeInCategory(_Type, EntityCategories.Soldier) == 1 then
        return CreateBattalion(player, _Type, pos.X, pos.Y, 1, name, orientation);
    else
        return CreateEntity(player, _Type, pos, name, orientation);
    end
end
ReplaceEntity = API.ReplaceEntity;

---
-- Rotiert ein Entity, sodass es zum Ziel schaut.
--
-- <p><b>Alias:</b> LookAt</p>
--
-- @param _entity         Entity (Skriptname oder ID)
-- @param _entityToLookAt Ziel (Skriptname oder ID)
-- @param[type=number]    _offsetEntity Winkel Offset
-- @within Anwenderfunktionen
-- @usage API.LookAt("Hakim", "Alandra")
--
function API.LookAt(_entity, _entityToLookAt, _offsetEntity)
    local entity = GetEntityId(_entity);
    local entityTLA = GetEntityId(_entityToLookAt);
    if not IsExisting(entity) or not IsExisting(entityTLA) then
        warn("API.LookAt: One entity is invalid or dead!");
        return;
    end
    local eX, eY = Logic.GetEntityPosition(entity);
    local eTLAX, eTLAY = Logic.GetEntityPosition(entityTLA);
    local orientation = math.deg( math.atan2( (eTLAY - eY) , (eTLAX - eX) ) );
    if Logic.IsBuilding(entity) == 1 then
        orientation = orientation - 90;
    end
    _offsetEntity = _offsetEntity or 0;
    info("API.LookAt: Entity " ..entity.. " is looking at " ..entityTLA);
    Logic.SetOrientation(entity, API.Round(orientation + _offsetEntity));
end
LookAt = API.LookAt;

---
-- Lässt zwei Entities sich gegenseitig anschauen.
--
-- @param _entity         Entity (Skriptname oder ID)
-- @param _entityToLookAt Ziel (Skriptname oder ID)
-- @within Anwenderfunktionen
-- @usage API.Confront("Hakim", "Alandra")
--
function API.Confront(_entity, _entityToLookAt)
    API.LookAt(_entity, _entityToLookAt);
    API.LookAt(_entityToLookAt, _entity);
end

---
-- Bestimmt die Distanz zwischen zwei Punkten. Es können Entity-IDs,
-- Skriptnamen oder Positionstables angegeben werden.
--
-- Wenn die Distanz nicht bestimmt werden kann, wird -1 zurückgegeben.
--
-- <p><b>Alias:</b> GetDistance</p>
--
-- @param _pos1 Erste Vergleichsposition (Skriptname, ID oder Positions-Table)
-- @param _pos2 Zweite Vergleichsposition (Skriptname, ID oder Positions-Table)
-- @return[type=number] Entfernung zwischen den Punkten
-- @within Anwenderfunktionen
-- @usage local Distance = API.GetDistance("HQ1", Logic.GetKnightID(1))
--
function API.GetDistance( _pos1, _pos2 )
    if (type(_pos1) == "string") or (type(_pos1) == "number") then
        _pos1 = GetPosition(_pos1);
    end
    if (type(_pos2) == "string") or (type(_pos2) == "number") then
        _pos2 = GetPosition(_pos2);
    end
    if type(_pos1) ~= "table" or type(_pos2) ~= "table" then
        warn("API.GetDistance: Distance could not be calculated!");
        return -1;
    end
    local xDistance = (_pos1.X - _pos2.X);
    local yDistance = (_pos1.Y - _pos2.Y);
    return math.sqrt((xDistance^2) + (yDistance^2));
end
GetDistance = API.GetDistance;

---
-- Prüft, ob eine Positionstabelle eine gültige Position enthält.
--
-- Eine Position ist Ungültig, wenn sie sich nicht auf der Welt befindet.
-- Das ist der Fall bei negativen Werten oder Werten, welche die Größe
-- der Welt übersteigen.
--
-- <p><b>Alias:</b> IsValidPosition</p>
--
-- @param[type=table] _pos Positionstable {X= x, Y= y}
-- @return[type=boolean] Position ist valide
-- @within Anwenderfunktionen
--
function API.ValidatePosition(_pos)
    if type(_pos) == "table" then
        if (_pos.X ~= nil and type(_pos.X) == "number") and (_pos.Y ~= nil and type(_pos.Y) == "number") then
            local world = {Logic.WorldGetSize()}
            if _pos.Z and _pos.Z < 0 then
                return false;
            end
            if _pos.X <= world[1] and _pos.X >= 0 and _pos.Y <= world[2] and _pos.Y >= 0 then
                return true;
            end
        end
    end
    return false;
end
IsValidPosition = API.ValidatePosition;

---
-- Lokalisiert ein Entity auf der Map. Es können sowohl Skriptnamen als auch
-- IDs verwendet werden. Wenn das Entity nicht gefunden wird, wird eine
-- Tabelle mit XYZ = 0 zurückgegeben.
--
-- <p><b>Alias:</b> GetPosition</p>
--
-- @param _Entity Entity (Skriptname oder ID)
-- @return[type=table] Positionstabelle {X= x, Y= y, Z= z}
-- @within Anwenderfunktionen
-- @usage local Position = API.LocateEntity("Hans")
--
function API.LocateEntity(_Entity)
    if (type(_Entity) == "table") then
        return _Entity;
    end
    if (not IsExisting(_Entity)) then
        warn("API.LocateEntity: Entity (" ..tostring(_Entity).. ") does not exist!");
        return {X= 0, Y= 0, Z= 0};
    end
    local x, y, z = Logic.EntityGetPos(GetID(_Entity));
    return {X= API.Round(x), Y= API.Round(y), Z= API.Round(y)};
end
GetPosition = API.LocateEntity;

---
-- Aktiviert ein interaktives Objekt, sodass es benutzt werden kann.
--
-- Der State bestimmt, ob es immer aktiviert werden kann, oder ob der Spieler
-- einen Helden benutzen muss. Wird der Parameter weggelassen, muss immer ein
-- Held das Objekt aktivieren.
--
-- <p><b>Alias:</b> InteractiveObjectActivate</p>
--
-- @param[type=string] _ScriptName  Skriptname des IO
-- @param[type=number] _State       Aktivierungszustand
-- @within Anwenderfunktionen
-- @usage API.ActivateIO("Haus1", 0)
-- API.ActivateIO("Hut1")
--
function API.ActivateIO(_ScriptName, _State)
    _State = _State or 0;
    if GUI then
        GUI.SendScriptCommand('API.ActivateIO("' .._ScriptName.. '", ' .._State..')');
        return;
    end
    if not IsExisting(_ScriptName) then
        error("API.ActivateIO: Entity (" ..tostring(_ScriptName).. ") does not exist!");
        return;
    end
    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), true);
    for i = 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, _State);
    end
end
InteractiveObjectActivate = API.ActivateIO;

---
-- Deaktiviert ein Interaktives Objekt, sodass es nicht mehr vom Spieler
-- aktiviert werden kann.
--
-- <p><b>Alias:</b> InteractiveObjectDeactivate</p>
--
-- @param[type=string] _ScriptName Skriptname des IO
-- @within Anwenderfunktionen
-- @usage API.DeactivateIO("Hut1")
--
function API.DeactivateIO(_ScriptName)
    if GUI then
        GUI.SendScriptCommand('API.DeactivateIO("' .._ScriptName.. '")');
        return;
    end
    if not IsExisting(_ScriptName) then
        error("API.DeactivateIO: Entity (" ..tostring(_ScriptName).. ") does not exist!");
        return;
    end
    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), false);
    for i = 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, 2);
    end
end
InteractiveObjectDeactivate = API.DeactivateIO;

---
-- Ermittelt alle Entities in der Kategorie auf dem Territorium und gibt
-- sie als Liste zurück.
--
-- <p><b>Alias:</b> GetEntitiesOfCategoryInTerritory</p>
--
-- @param[type=number] _player    PlayerID [0-8] oder -1 für alle
-- @param[type=number] _category  Kategorie, der die Entities angehören
-- @param[type=number] _territory Zielterritorium
-- @within Anwenderfunktionen
-- @usage local Found = API.GetEntitiesOfCategoryInTerritory(1, EntityCategories.Hero, 5)
--
function API.GetEntitiesOfCategoryInTerritory(_player, _category, _territory)
    local PlayerEntities = {};
    local Units = {};
    if (_player == -1) then
        for i=0,8 do
            local NumLast = 0;
            repeat
                Units = { Logic.GetEntitiesOfCategoryInTerritory(_territory, i, _category, NumLast) };
                PlayerEntities = Array_Append(PlayerEntities, Units);
                NumLast = NumLast + #Units;
            until #Units == 0;
        end
    else
        local NumLast = 0;
        repeat
            Units = { Logic.GetEntitiesOfCategoryInTerritory(_territory, _player, _category, NumLast) };
            PlayerEntities = Array_Append(PlayerEntities, Units);
            NumLast = NumLast + #Units;
        until #Units == 0;
    end
    return PlayerEntities;
end
GetEntitiesOfCategoryInTerritory = API.GetEntitiesOfCategoryInTerritory;

---
-- Gibt dem Entity einen eindeutigen Skriptnamen und gibt ihn zurück.
-- Hat das Entity einen Namen, bleibt dieser unverändert und wird
-- zurückgegeben.
-- @param[type=number] _EntityID Entity ID
-- @return[type=string] Skriptname
-- @within Anwenderfunktionen
--
function API.EnsureScriptName(_EntityID)
    if type(_EntityID) == "string" then
        return _EntityID;
    else
        assert(type(_EntityID) == "number");
        local name = Logic.GetEntityName(_EntityID);
        if (type(name) ~= "string" or name == "" ) then
            QSB.GiveEntityNameCounter = (QSB.GiveEntityNameCounter or 0)+ 1;
            name = "EnsureScriptName_Name_"..QSB.GiveEntityNameCounter;
            Logic.SetEntityName(_EntityID, name);
        end
        return name;
    end
end
GiveEntityName = API.EnsureScriptName;

-- Placeholders ----------------------------------------------------------------

QSB.Placeholders = {
    Names = {},
    EntityTypes = {},
};

---
-- Farben, die als Platzhalter genutzt werden können.
--
-- Verwendung:
-- <pre>{YOUR_COLOR}</pre>
-- Ersetze YOUR_COLOR mit einer der gelisteten Farben.
--
-- @field red     Rot
-- @field blue    Blau
-- @field yellow  Gelp
-- @field green   Grün
-- @field white   Weiß
-- @field black   Schwarz
-- @field grey    Grau
-- @field azure   Azurblau
-- @field orange  Orange
-- @field amber   Bernstein
-- @field violet  Violett
-- @field pink    Rosa
-- @field scarlet Scharlachrot
-- @field magenta Magenta
-- @field olive   Olivgrün
-- @field sky     Ozeanblau
-- @field tooltip Tooltip-Blau
-- @field lucid   Transparent
--
QSB.Placeholders.Colors = {
    red     = "{@color:255,80,80,255}",
    blue    = "{@color:104,104,232,255}",
    yellow  = "{@color:255,255,80,255}",
    green   = "{@color:80,180,0,255}",
    white   = "{@color:255,255,255,255}",
    black   = "{@color:0,0,0,255}",
    grey    = "{@color:140,140,140,255}",
    azure   = "{@color:0,160,190,255}",
    orange  = "{@color:255,176,30,255}",
    amber   = "{@color:224,197,117,255}",
    violet  = "{@color:180,100,190,255}",
    pink    = "{@color:255,170,200,255}",
    scarlet = "{@color:190,0,0,255}",
    magenta = "{@color:190,0,89,255}",
    olive   = "{@color:74,120,0,255}",
    sky     = "{@color:145,170,210,255}",
    tooltip = "{@color:51,51,120,255}",
    lucid   = "{@color:0,0,0,0}"
};

-- API Stuff --

---
-- Ersetzt alle Platzhalter im Text oder in der Table.
--
-- Mögliche Platzhalter:
-- <ul>
-- <li>{name:xyz} - Ersetzt einen Skriptnamen mit dem zuvor gesetzten Wert.</li>
-- <li>{type:xyz} - Ersetzt einen Typen mit dem zuvor gesetzten Wert.</li>
-- </ul>
--
-- Außerdem werden einige Standardfarben ersetzt.
-- @see QSB.Placeholders.Colors
--
-- @param _Message Text oder Table mit Texten
-- @return Ersetzter Text
-- @within Anwenderfunktionen
--
function API.ConvertPlaceholders(_Message)
    if type(_Message) == "table" then
        for k, v in pairs(_Message) do
            _Message[k] = Core:ConvertPlaceholders(v);
        end
        return _Message;
    elseif type(_Message) == "string" then
        return Core:ConvertPlaceholders(_Message);
    else
        return _Message;
    end
end

---
-- Fügt einen Platzhalter für den angegebenen Namen hinzu.
--
-- Innerhalb des Textes wird der Plathalter wie folgt geschrieben:
-- <pre>{name:YOUR_NAME}</pre>
-- YOUR_NAME muss mit dem Namen ersetzt werden.
--
-- @param[type=string] _Name        Name, der ersetzt werden soll
-- @param[type=string] _Replacement Wert, der ersetzt wird
-- @within Anwenderfunktionen
--
function API.AddNamePlaceholder(_Name, _Replacement)
    if type(_Replacement) == "function" or type(_Replacement) == "thread" then
        log("API.AddNamePlaceholder: Only strings, numbers, or tables are allowed!", LEVEL_ERROR);
        return;
    end
    QSB.Placeholders.Names[_Name] = _Replacement;
end

---
-- Fügt einen Platzhalter für einen Entity-Typ hinzu.
--
-- Innerhalb des Textes wird der Plathalter wie folgt geschrieben:
-- <pre>{name:ENTITY_TYP}</pre>
-- ENTITY_TYP muss mit einem Entity-Typ ersetzt werden. Der Typ wird ohne
-- Entities. davor geschrieben.
--
-- @param[type=string] _Name        Scriptname, der ersetzt werden soll
-- @param[type=string] _Replacement Wert, der ersetzt wird
-- @within Anwenderfunktionen
--
function API.AddEntityTypePlaceholder(_Type, _Replacement)
    if Entities[_Type] == nil then
        log("API.AddEntityTypePlaceholder: EntityType does not exist!", LEVEL_ERROR);
        return;
    end
    QSB.Placeholders.EntityTypes[_Type] = _Replacement;
end

-- Core Stuff --

---
-- Ersetzt alle Platzhalter innerhalb des übergebenen Text.
-- @param[type=string] _Text Text mit Platzhaltern
-- @return[type=string] Ersetzter Text
-- @within Internal
-- @local
--
function Core:ConvertPlaceholders(_Text)
    local s1, e1, s2, e2;
    while true do
        local Before, Placeholder, After, Replacement, s1, e1, s2, e2;
        if _Text:find("{name:") then
            Before, Placeholder, After, s1, e1, s2, e2 = self:SplicePlaceholderText(_Text, "{name:");
            Replacement = QSB.Placeholders.Names[Placeholder];
            _Text = Before .. API.Localize(Replacement or "ERROR_PLACEHOLDER_NOT_FOUND") .. After;
        elseif _Text:find("{type:") then
            Before, Placeholder, After, s1, e1, s2, e2 = self:SplicePlaceholderText(_Text, "{type:");
            Replacement = QSB.Placeholders.EntityTypes[Placeholder];
            _Text = Before .. API.Localize(Replacement or "ERROR_PLACEHOLDER_NOT_FOUND") .. After;
        end
        if s1 == nil or e1 == nil or s2 == nil or e2 == nil then
            break;
        end
    end
    _Text = self:ReplaceColorPlaceholders(_Text);
    return _Text;
end

---
-- Zerlegt einen String in 3 Strings: Anfang, Platzhalter, Ende.
-- @param[type=string] _Text  Text
-- @param[type=string] _Start Anfang-Tag
-- @return[type=string] Text vor dem Platzhalter
-- @return[type=string] Platzhalter
-- @return[type=string] Text nach dem Platzhalter
-- @return[type=number] Anfang Start-Tag
-- @return[type=number] Ende Start-Tag
-- @return[type=number] Anfang Schluss-Tag
-- @return[type=number] Ende Schluss-Tag
-- @within Internal
-- @local
--
function Core:SplicePlaceholderText(_Text, _Start)
    local s1, e1 = _Text:find(_Start);
    local s2, e2 = _Text:find("}", e1);

    local Before      = _Text:sub(1, s1-1);
    local Placeholder = _Text:sub(e1+1, s2-1);
    local After       = _Text:sub(e2+1);
    return Before, Placeholder, After, s1, e1, s2, e2;
end

---
-- Ersetzt Platzhalter mit einer Farbe mit dem Wert aus der Wertetabelle.
-- @param[type=string] Text mit Platzhaltern
-- @return[type=string] Text mit ersetzten Farben
-- @see QSB.Placeholders.Colors
-- @within Internal
-- @local
--
function Core:ReplaceColorPlaceholders(_Text)
    for k, v in pairs(QSB.Placeholders.Colors) do
        _Text = _Text:gsub("{" ..k.. "}", v);
    end
    return _Text;
end

-- Interface -------------------------------------------------------------------

Core.Data.Interface = {
    SelectedEntities = {},

    ChatOptionsWasShown = false,
    MessageLogWasShown = false,
    PauseScreenShown = false,
    NormalModeHidden = false,
    BorderScrollDeactivated = false,
}

---
-- Zeigt den Pausebildschirm als schwarzen Hintergrund an. Wurde dieser schon
-- eingeblendet, macht die Funktion nichts.
-- @param[type=number] _Red   (Optional) Rotwert des Hintergrund
-- @param[type=number] _Green (Optional) Grünwert des Hintergrund
-- @param[type=number] _Blue  (Optional) Blauwert des Hintergrund
-- @param[type=number] _Alpha (Optional) Alphawert des Hintergrund
-- @within Internal
-- @local
--
function Core:InterfaceActivateBlackBackground(_Red, _Green, _Blue, _Alpha)
    _Red   = _Red or 0;
    _Green = _Green or 0;
    _Blue  = _Blue or 0;
    _Alpha = _Alpha or 255;
    if self.Data.Interface.PauseScreenShown then
        return;
    end
    self.Data.Interface.PauseScreenShown = true;

    XGUIEng.PushPage("/InGame/Root/Normal/PauseScreen", false)
    XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 1);
    XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, _Red, _Green, _Blue, _Alpha);
end

---
-- Blendet den Pausebildschirm aus und stellt Farbe und Transparenz wieder her.
-- Wurde dieser schon deaktiviert, macht die Funktion nichts.
-- @within Internal
-- @local
--
function Core:InterfaceDeactivateBlackBackground()
    if not self.Data.Interface.PauseScreenShown then
        return;
    end
    self.Data.Interface.PauseScreenShown = false;

    XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 0);
    XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, 40, 40, 40, 180);
    XGUIEng.PopPage();
end

function Core:InterfaceDeactivateBorderScroll(_PositionID)
    if self.Data.Interface.BorderScrollDeactivated then
        return;
    end
    self.Data.Interface.BorderScrollDeactivated = true;
    GameCallback_Camera_GetBorderscrollFactor_OrigCore = GameCallback_Camera_GetBorderscrollFactor;
	GameCallback_Camera_GetBorderscrollFactor = function() end;
    if _PositionID then
        Camera.RTS_FollowEntity(_PositionID);
    end
    Camera.RTS_SetZoomFactor(0.5000);
    Camera.RTS_SetZoomFactorMax(0.5001);
    Camera.RTS_SetZoomFactorMin(0.4999);
end

function Core:InterfaceActivateBorderScroll()
    if not self.Data.Interface.BorderScrollDeactivated then
        return;
    end
    self.Data.Interface.BorderScrollDeactivated = false;
	GameCallback_Camera_GetBorderscrollFactor = GameCallback_Camera_GetBorderscrollFactor_OrigCore;
    GameCallback_Camera_GetBorderscrollFactor_OrigCore = nil;
    Camera.RTS_FollowEntity(0);
    Camera.RTS_SetZoomFactor(0.5000);
    Camera.RTS_SetZoomFactorMax(0.5001);
    Camera.RTS_SetZoomFactorMin(0.0999);
    if BundleCamera and BundleCamera.Local.Data.ExtendedZoomActive then
        BundleCamera.Local:ActivateExtendedZoom();
    end
end

---
-- 
-- @within Internal
-- @local
--
function Core:OverrideInterfaceUpdateForCinematicMode()
    MissionTimerUpdate_Orig_CoreInterface = MissionTimerUpdate;
    MissionTimerUpdate = function()
        MissionTimerUpdate_Orig_CoreInterface();
        if self.Data.Interface.NormalModeHidden
        or self.Data.Interface.PauseScreenShown then
            XGUIEng.ShowWidget("/InGame/Root/Normal/MissionTimer", 0);
        end
    end

    MissionGoodOrEntityCounterUpdate_Orig_CoreInterface = MissionGoodOrEntityCounterUpdate;
    MissionGoodOrEntityCounterUpdate = function()
        MissionGoodOrEntityCounterUpdate_Orig_CoreInterface();
        if self.Data.Interface.NormalModeHidden
        or self.Data.Interface.PauseScreenShown then
            XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 0);
        end
    end

    MerchantButtonsUpdater_Orig_CoreInterface = GUI_Merchant.ButtonsUpdater;
    GUI_Merchant.ButtonsUpdater = function()
        MerchantButtonsUpdater_Orig_CoreInterface();
        if self.Data.Interface.NormalModeHidden
        or self.Data.Interface.PauseScreenShown then
            XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant", 0);
        end
    end

    if GUI_Tradepost then
        TradepostButtonsUpdater_Orig_CoreInterface = GUI_Tradepost.ButtonsUpdater;
        GUI_Tradepost.ButtonsUpdater = function()
            TradepostButtonsUpdater_Orig_CoreInterface();
            if self.Data.Interface.NormalModeHidden
            or self.Data.Interface.PauseScreenShown then
                XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost", 0);
            end
        end
    end
end

---
-- Blendet das normale Interface aus. Wurde das Interface schon ausgeblentet,
-- macht die Funktion nichts.
-- @within Internal
-- @local
--
function Core:InterfaceDeactivateNormalInterface()
    if self.Data.Interface.NormalModeHidden then
        return;
    end
    self.Data.Interface.NormalModeHidden = true;
    for k, v in pairs({GUI.GetSelectedEntities()}) do
        table.insert(self.Data.Interface.SelectedEntities, v);
    end
    GUI.ClearSelection();

    XGUIEng.PushPage("/InGame/Root/Normal/NotesWindow", false);
    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/TextMessages", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/BuildMenu", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/MapFrame", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopRight", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/Windows/Gold", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/Windows/Resources", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/Windows/Nutrition", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/Windows/Cleanliness", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/Windows/Clothes", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/Windows/Entertainment", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/Windows/Decoration", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/Windows/Prosperity", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/Windows/Military", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/UpdateFunction", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/Buttons", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestLogButton", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestTimers", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MissionTimer", 0);

    HideOtherMenus();
    if XGUIEng.IsWidgetShownEx("/InGame/Root/Normal/ChatOptions/Background") == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions", 0);
        self.Data.Interface.ChatOptionsWasShown = true;
    end
    if XGUIEng.IsWidgetShownEx("/InGame/Root/Normal/MessageLog/Name") == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog", 0);
        self.Data.Interface.MessageLogWasShown = true;
    end
    if g_GameExtraNo > 0 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost", 0);
    end
end

---
-- Blendet das normale Interface ein. Wurde das Interface schon eingeblentet,
-- macht die Funktion nichts.
-- @within Internal
-- @local
--
function Core:InterfaceActivateNormalInterface()
    if not self.Data.Interface.NormalModeHidden then
        return;
    end
    self.Data.Interface.NormalModeHidden = false;
    for k, v in pairs(self.Data.Interface.SelectedEntities) do
        GUI.SelectEntity(v);
    end
    self.Data.Interface.SelectedEntities = {};

    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);
    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/BuildMenu", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/MapFrame", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopRight", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/UpdateFunction", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/Buttons", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestLogButton", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestTimers", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message", 1);
    XGUIEng.PopPage();
    
    -- Debug Clock
    if AddOnQuestDebug and AddOnQuestDebug.Local.Data.GameClock then
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 1);
    end
    -- Timer
    if g_MissionTimerEndTime then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionTimer", 1);
    end
    -- Counter
    if g_MissionGoodOrEntityCounterAmountToReach then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 1);
    end
    -- Chat Options
    if self.Data.Interface.ChatOptionsWasShown then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions", 1);
        self.Data.Interface.ChatOptionsWasShown = false;
    end
    -- Message Log
    if self.Data.Interface.MessageLogWasShown then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog", 1);
        self.Data.Interface.MessageLogWasShown = false;
    end
    -- Handelsposten
    if g_GameExtraNo > 0 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost", 1);
    end
end

-- Main ------------------------------------------------------------------------

-- API Stuff --

---
-- Initialisiert alle verfügbaren Bundles und führt ihre Install-Methode aus.
--
-- Bundles werden immer getrennt im globalen und im lokalen Skript gestartet.
-- Diese Funktion muss zwingend im globalen und lokalen Skript ausgeführt
-- werden, bevor die QSB verwendet werden kann.
--
-- @within Anwenderfunktionen
--
function API.Install()
    Core:InitalizeBundles();
end

-- Core Stuff --

Core.Data.BundleInitializerList = {};
Core.Data.InitalizedBundles = {};

---
-- Initialisiert alle verfügbaren Bundles und führt ihre Install-Methode aus.
-- Bundles werden immer getrennt im globalen und im lokalen Skript gestartet.
-- @within Internal
-- @local
--
function Core:InitalizeBundles()
    if not QSB.InitializationFinished then
        -- Initialisierung
        if not GUI then
            QSB.Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";

            self:OverwriteBasePricesAndRefreshRates();
            self:CreateRandomSeedBySystemTime();
            self:SetupGobal_HackCreateQuest();
            self:SetupGlobal_HackQuestSystem();
            self:IdentifyHistoryEdition();

            Trigger.RequestTrigger(Events.LOGIC_EVENT_DIPLOMACY_CHANGED, "", "CoreEventJob_OnDiplomacyChanged", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_CREATED, "", "CoreEventJob_OnEntityCreated", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_DESTROYED, "", "CoreEventJob_OnEntityDestroyed", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_HURT_ENTITY, "", "CoreEventJob_OnEntityHurtEntity", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_IN_RANGE_OF_ENTITY, "", "CoreEventJob_OnEntityInRangeOfEntity", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", "CoreEventJob_OnEverySecond", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN, "", "CoreEventJob_OnEveryTurn", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_GOODS_TRADED, "", "CoreEventJob_OnGoodsTraded", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_PLAYER_DIED, "", "CoreEventJob_OnPlayerDied", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_RESEARCH_DONE, "", "CoreEventJob_OnResearchDone", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_TRIBUTE_PAID, "", "CoreEventJob_OnTributePaied", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_WEATHER_STATE_CHANGED, "", "CoreEventJob_OnWatherChanged", 1);
            
            StartSimpleJobEx(Core.EventJob_EventOnEveryRealTimeSecond);
        else
            QSB.Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";

            self:CreateRandomSeedBySystemTime();
            self:SetupLocal_HackRegisterHotkey();
            self:SetupLocal_HistoryEditionAutoSave();
            self:OverrideInterfaceUpdateForCinematicMode();

            Trigger.RequestTrigger(Events.LOGIC_EVENT_DIPLOMACY_CHANGED, "", "CoreEventJob_OnDiplomacyChanged", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_CREATED, "", "CoreEventJob_OnEntityCreated", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_DESTROYED, "", "CoreEventJob_OnEntityDestroyed", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_HURT_ENTITY, "", "CoreEventJob_OnEntityHurtEntity", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_IN_RANGE_OF_ENTITY, "", "CoreEventJob_OnEntityInRangeOfEntity", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", "CoreEventJob_OnEverySecond", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN, "", "CoreEventJob_OnEveryTurn", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_GOODS_TRADED, "", "CoreEventJob_OnGoodsTraded", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_PLAYER_DIED, "", "CoreEventJob_OnPlayerDied", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_RESEARCH_DONE, "", "CoreEventJob_OnResearchDone", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_TRIBUTE_PAID, "", "CoreEventJob_OnTributePaied", 1); 
            Trigger.RequestTrigger(Events.LOGIC_EVENT_WEATHER_STATE_CHANGED, "", "CoreEventJob_OnWatherChanged", 1);

            StartSimpleJobEx(Core.EventJob_EventOnEveryRealTimeSecond);
            StartSimpleHiResJobEx(Core.EventJob_WaitForLoadScreenHidden);
        end

        -- Aufruf der Module
        for k,v in pairs(self.Data.BundleInitializerList) do
            local Bundle = _G[v];
            if not GUI then
                if Bundle.Global ~= nil and Bundle.Global.Install ~= nil then
                    Bundle.Global:Install();
                    Bundle.Local = nil;
                end
            else
                if Bundle.Local ~= nil and Bundle.Local.Install ~= nil then
                    Bundle.Local:Install();
                    Bundle.Global = nil;
                end
            end
            self.Data.InitalizedBundles[v] = true;
            collectgarbage();
        end
        QSB.InitializationFinished = true;
    end
end

---
-- Fügt fehlende Einträge für Militäreinheiten bei den Basispreisen
-- und Erneuerungsraten hinzu, damit diese gehandelt werden können.
-- @within Internal
-- @local
--
function Core:OverwriteBasePricesAndRefreshRates()
    MerchantSystem.BasePrices[Entities.U_CatapultCart] = MerchantSystem.BasePrices[Entities.U_CatapultCart] or 1000;
    MerchantSystem.BasePrices[Entities.U_BatteringRamCart] = MerchantSystem.BasePrices[Entities.U_BatteringRamCart] or 450;
    MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] = MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] or 600;
    MerchantSystem.BasePrices[Entities.U_AmmunitionCart] = MerchantSystem.BasePrices[Entities.U_AmmunitionCart] or 180;
    MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] or 150;
    MerchantSystem.BasePrices[Entities.U_MilitarySword] = MerchantSystem.BasePrices[Entities.U_MilitarySword] or 150;
    MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] or 220;
    MerchantSystem.BasePrices[Entities.U_MilitaryBow] = MerchantSystem.BasePrices[Entities.U_MilitaryBow] or 220;

    MerchantSystem.RefreshRates[Entities.U_CatapultCart] = MerchantSystem.RefreshRates[Entities.U_CatapultCart] or 270;
    MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] = MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] or 190;
    MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] = MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] or 220;
    MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] = MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_RedPrince] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitarySword] = MerchantSystem.RefreshRates[Entities.U_MilitarySword] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitaryBow] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow] or 150;

    if g_GameExtraNo >= 1 then
        MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] or 220;
        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] or 150;
        MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] = MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] or 150;
        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_Khana] or 150;
    end
end

---
-- Überschreibt CreateQuest für die Anbindung an Symfonia.
-- @within Internal
-- @local
--
function Core:SetupGobal_HackCreateQuest()
    CreateQuest = function(_QuestName, _QuestGiver, _QuestReceiver, _QuestHidden, _QuestTime, _QuestDescription, _QuestStartMsg, _QuestSuccessMsg, _QuestFailureMsg)
        local Triggers = {};
        local Goals = {};
        local Reward = {};
        local Reprisal = {};
        local NumberOfBehavior = Logic.Quest_GetQuestNumberOfBehaviors(_QuestName);

        for i=0, NumberOfBehavior-1, 1 do
            -- Behavior ermitteln
            local BehaviorName = Logic.Quest_GetQuestBehaviorName(_QuestName, i);
            local BehaviorTemplate = GetBehaviorTemplateByName(BehaviorName);
            assert( BehaviorTemplate, "No template for name: " .. BehaviorName .. " - using an invalid QuestSystemBehavior.lua?!");
            local NewBehavior = {};
            Table_Copy(NewBehavior, BehaviorTemplate);
            local Parameter = Logic.Quest_GetQuestBehaviorParameter(_QuestName, i);
            for j=1,#Parameter do
                NewBehavior:AddParameter(j-1, Parameter[j]);
            end

            -- Füge als Goal hinzu
            if (NewBehavior.GetGoalTable ~= nil) then
                Goals[#Goals + 1] = NewBehavior:GetGoalTable();
                Goals[#Goals].Context = NewBehavior;
                Goals[#Goals].FuncOverrideIcon = NewBehavior.GetIcon;
                Goals[#Goals].FuncOverrideMsgKey = NewBehavior.GetMsgKey;
            end
            -- Füge als Trigger hinzu
            if (NewBehavior.GetTriggerTable ~= nil) then
                Triggers[#Triggers + 1] = NewBehavior:GetTriggerTable();
            end
            -- Füge als Reprisal hinzu
            if (NewBehavior.GetReprisalTable ~= nil) then
                Reprisal[#Reprisal + 1] = NewBehavior:GetReprisalTable();
            end
            -- Füge als Reward hinzu
            if (NewBehavior.GetRewardTable ~= nil) then
                Reward[#Reward + 1] = NewBehavior:GetRewardTable();
            end
        end

        -- Prüfe Mindestkonfiguration des Quest
        if (#Triggers == 0) or (#Goals == 0) then
            return;
        end

        -- Erzeuge den Quest
        if Core:CheckQuestName(_QuestName) then
            local QuestID = QuestTemplate:New(
                _QuestName,
                _QuestGiver or 1,
                _QuestReceiver or 1,
                Goals,
                Triggers,
                tonumber(_QuestTime) or 0,
                Reward,
                Reprisal,
                nil, nil,
                (not _QuestHidden or ( _QuestStartMsg and _QuestStartMsg ~= "") ),
                (not _QuestHidden or ( _QuestSuccessMsg and _QuestSuccessMsg ~= "") or ( _QuestFailureMsg and _QuestFailureMsg ~= "") ),
                _QuestDescription,
                _QuestStartMsg,
                _QuestSuccessMsg,
                _QuestFailureMsg
            );
            g_QuestNameToID[_QuestName] = QuestID;
        else
            Core:LogToFile("Quest '"..tostring(_QuestName).."': invalid questname! Contains forbidden characters!", LEVEL_ERROR);
            Core:LogToScreen("Quest '"..tostring(_QuestName).."': invalid questname! Contains forbidden characters!", LEVEL_ERROR);
        end
    end
end

---
-- Implementiert die vordefinierten Texte für Custom Behavior und den Aufruf
-- der :Interrupt Methode.
-- @within Internal
-- @local
--
function Core:SetupGlobal_HackQuestSystem()
    QuestTemplate.Trigger_Orig_QSB_Core = QuestTemplate.Trigger
    QuestTemplate.Trigger = function(_quest)
        QuestTemplate.Trigger_Orig_QSB_Core(_quest);
        for i=1,_quest.Objectives[0] do
            if _quest.Objectives[i].Type == Objective.Custom2 and _quest.Objectives[i].Data[1].SetDescriptionOverwrite then
                local Desc = _quest.Objectives[i].Data[1]:SetDescriptionOverwrite(_quest);
                Core:ChangeCustomQuestCaptionText(Desc, _quest);
                break;
            end
        end
    end

    QuestTemplate.Interrupt_Orig_QSB_Core = QuestTemplate.Interrupt;
    QuestTemplate.Interrupt = function(_quest)
        QuestTemplate.Interrupt_Orig_QSB_Core(_quest);
        for i=1, _quest.Objectives[0] do
            if _quest.Objectives[i].Type == Objective.Custom2 and _quest.Objectives[i].Data[1].Interrupt then
                _quest.Objectives[i].Data[1]:Interrupt(_quest, i);
            end
        end
        for i=1, _quest.Triggers[0] do
            if _quest.Triggers[i].Type == Triggers.Custom2 and _quest.Triggers[i].Data[1].Interrupt then
                _quest.Triggers[i].Data[1]:Interrupt(_quest, i);
            end
        end
    end
end

---
-- Prüft, ob das Spiel gerade gespeichert werden kann.
--
-- @return [boolean]  Speichern ist möglich
-- @within Internal
-- @local
--
function Core:CanGameBeSaved()
    -- Briefing ist aktiv
    if IsBriefingActive and IsBriefingActive() then
        return false;
    end
    -- Cutscene ist aktiv
    if IsCutsceneActive and IsCutsceneActive() then
        return false;
    end
    -- Die Map wird noch geladen
    if GUI and XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") ~= 0 then
        return false;
    end
    return true;
end

---
-- Prüft, ob das Bundle bereits initalisiert ist.
--
-- @param[type=string] _Bundle Name des Moduls
-- @return[type=boolean] Bundle initalisiert
-- @within Internal
-- @local
--
function Core:IsBundleRegistered(_Bundle)
    return self.Data.InitalizedBundles[_Bundle] == true;
end

---
-- Registiert ein Bundle, sodass es initialisiert wird.
--
-- @param[type=string] _Bundle Name des Moduls
-- @within Internal
-- @local
--
function Core:RegisterBundle(_Bundle)
    local text = string.format("Error while initialize bundle '%s': does not exist!", tostring(_Bundle));
    assert(_G[_Bundle] ~= nil, text);
    table.insert(self.Data.BundleInitializerList, _Bundle);
end

---
-- Registiert ein AddOn als Bundle, sodass es initialisiert wird.
--
-- Diese Funktion macht prinziplell das Gleiche wie Core:RegisterBundle und
-- existiert nur zur Übersichtlichkeit.
--
-- @param[type=string] _AddOn Name des Moduls
-- @within Internal
-- @local
--
function Core:RegisterAddOn(_AddOn)
    local text = string.format("Error while initialize addon '%s': does not exist!", tostring(_AddOn));
    assert(_G[_AddOn] ~= nil, text);
    table.insert(self.Data.BundleInitializerList, _AddOn);
end

---
-- Bereitet ein Behavior für den Einsatz im Assistenten und im Skript vor.
-- Erzeugt zudem den Konstruktor.
--
-- @param[type=table] _Behavior Behavior-Objekt
-- @within Internal
-- @local
--
function Core:RegisterBehavior(_Behavior)
    if GUI then
        return;
    end
    if _Behavior.RequiresExtraNo and _Behavior.RequiresExtraNo > g_GameExtraNo then
        return;
    end

    if not _G["b_" .. _Behavior.Name] then
        --self:LogToFile("AddQuestBehavior: can not find ".. _Behavior.Name .."!", LEVEL_ERROR);
        --self:LogToScreen("AddQuestBehavior: can not find ".. _Behavior.Name .."!", LEVEL_ERROR);
        Logic.ExecuteInLuaLocalState("GUI.AddStaticNote('" ..tostring(_Behavior.Name).. "')");
    else
        if not _G["b_" .. _Behavior.Name].new then
            _G["b_" .. _Behavior.Name].new = function(self, ...)
                local arg = {...}; -- Notwendiger Fix für LuaJ
                local behavior = API.InstanceTable(self);
                behavior.i47ya_6aghw_frxil = {};
                behavior.v12ya_gg56h_al125 = {};
                for i= 1, #arg, 1 do
                    table.insert(behavior.v12ya_gg56h_al125, arg[i]);
                    if self.Parameter and self.Parameter[i] ~= nil then
                        behavior:AddParameter(i-1, arg[i]);
                    else
                        table.insert(behavior.i47ya_6aghw_frxil, arg[i]);
                    end
                end
                return behavior;
            end
        end

        for i= 1, #g_QuestBehaviorTypes, 1 do
            if g_QuestBehaviorTypes[i].Name == _Behavior.Name then
                return;
            end
        end
        table.insert(g_QuestBehaviorTypes, _Behavior);
    end
end

---
-- Wandelt underschiedliche Darstellungen einer Boolean in eine echte um.
--
-- Jeder String, der mit j, t, y oder + beginnt, wird als true interpretiert.
-- Alles andere als false.
--
-- Ist die Eingabe bereits ein Boolean wird es direkt zurückgegeben.
--
-- @param[type=string] _Input Boolean-Darstellung
-- @return[type=boolean] Konvertierte Boolean
-- @within Internal
-- @local
--
function Core:ToBoolean(_Input)
    if type(_Input) == "boolean" then
        return _Input;
    end
    if string.find(string.lower(tostring(_Input)), "^[tjy\\+].*$") then
        return true;
    end
    return false;
end

---
-- Setzt den Random Seed für die Erzeugung von Zufallszahlen anhand der
-- aktuellen Systemzeit.
--
-- @return[type=number] Random Seed
-- @within Internal
-- @local
--
function Core:CreateRandomSeedBySystemTime()
    local DateTimeString = Framework.GetSystemTimeDateString();

    local s, e = DateTimeString:find(" ");
    local TimeString = DateTimeString:sub(e+2, DateTimeString:len()-1):gsub("'", "");
    TimeString = "1" ..TimeString;

    local RandomSeed = tonumber(TimeString);
    math.randomseed(RandomSeed);
    return RandomSeed;
end

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleBriefingSystem                                         # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht es Briefing zu verwenden.
--
-- Briefings dienen zur Darstellung von Dialogen oder zur näheren Erleuterung
-- der aktuellen Spielsituation. Mit Multiple Choice können dem Spieler mehrere
-- Auswahlmöglichkeiten gegeben, multiple Handlungsstränge gestartet
-- oder Menüstrukturen abgebildet werden. Mittels Sprüngen und Leerseiten
-- kann innerhalb des Multiple Choice Briefings navigiert werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleBriefingSystem = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Startet ein Briefing.
--
-- Für ein Briefing können verschiedene spezielle Einstellungen vorgenommen
-- werden. Jede dieser Einstellungen wird mit true aktiviert.
-- <table border="1">
-- <tr>
-- <td><b>Einstellung</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>HideBorderPins</td>
-- <td>Die Grenzsteine werden während des Briefing ausgeblendet</td>
-- </tr>
-- <tr>
-- <td>BarOpacity</td>
-- <td>Bestimmt die Opacity der Bars [0.0 - 1.0]</td>
-- </tr>
-- <tr>
-- <td>BigBars</td>
-- <td>Breite Bars in Briefings verwenden (Default true)</td>
-- </tr>
-- <tr>
-- <td>ShowSky</td>
-- <td>Der Himmel wird während des Briefing angezeigt</td>
-- </tr>
-- <tr>
-- <td>RestoreGameSpeed</td>
-- <td>Die Spielgeschwindigkeit wird nach Ende des Briefing zurückgesetzt</td>
-- </tr>
-- <tr>
-- <td>RestoreCamera</td>
-- <td>Die Kameraposition vor dem Briefing wird wiederhergestellt</td>
-- </tr>
-- <tr>
-- <td>SkippingAllowed</td>
-- <td>Das manuelle Springen zwischen Seiten wird erlaubt.</td>
-- </tr>
-- <tr>
-- <td>ReturnForbidden</td>
-- <td>Das Zurückspringen zur Vorherigen Seite wird deaktiviert. Wenn nicht
-- angegeben, dann standardmäßig deaktiviert.</td>
-- </tr>
-- </table>
--
-- <br><h5>Animationen entkoppeln</h5>
-- Es ist außerdem möglich, die Kameraanimation von den einzelnen Seiten des
-- Briefings zu entkoppeln. Das hat den Charme, dass Spielfiguren erzählen
-- und erzählen und die Kamera über die ganze Zeit die gleiche Animation
-- zeigt, was das Lesen angenehmer macht.
--
-- Animationen werden über die Animations-Table gesteuert. Diese wird direkt
-- an die Briefing Table angehangen. Die Animation wird die Kamera dann von
-- Position 1 zu Position 2 bewegen.
-- <p>Beispiel:</p>
-- <pre>
-- Briefing.PageAnimations = {
--    ["Page1"] = {
--        -- Position1, Rotation1, Zoom1, Angle1, Position2, Rotation2, Zoom2, Angle2, Animationsdauer
--        {"pos4", -60, 2000, 35, "pos4", -30, 2000, 25, 30}
--    },
--    ["Page3"] = {
--        PurgeOld = true,
--        {"pos2", -45, 6000, 35, "pos2", -45, 3000, 35, 30},
--    }
--};</pre>
-- Hier wird eine Animation für die Seite "Page1" definiert. Sobald die Seite
-- abgespielt wird startet die Animation. Wird Seite "Page3" erreicht, werden
-- alle laufenden Animationen abgebrochen (PurgeOld = true) und die neue
-- Animation hinzugefügt. Es können mehrere Animationen definiert werden,
-- welche nacheinander abgespielt werden.
--
-- Anstelle von Angle, Rotation und Zoom kann auch eine zweite Position
-- angegeben werden. Die Kamera befindet sich dann an der Position von
-- Position und schaut zur Position von LookAt. Es können Skriptnamen mit
-- Z-Offset oder XYZ-Koordinaten verwendet werden.
-- <p>Beispiel:</p>
--<pre>
-- Briefing.PageAnimations = {
--    ["Page1"] = {
--        -- Position1, LookAt1, Position2, Lookat2, Animationsdauer
--        {"pos1", "look1", "pos4", "look4", 30}
--    },
--};</pre>
--
-- Über Richtungsvektoren können besondere Kameraeffekte erzielt werden.
-- Wenn sich das LookAt-Entity bewegt und das Position still steht, wird
-- die LookAt-Entity von der fest stationierten Kamera verfolgt. Wenn die
-- Position z.B. ein sich bewegende Kutsche ist, und LookAt ein statisches
-- Entity, wie z.B. ein Gebäude, wird der Effekt erzielt, dass jemand aus
-- der Kutsche auf das Gebäude schaut.
--
-- Definiert man Animationen auf diese Weise, so muss man es für das <u>
-- gesamte Briefing</u> durchziehen. Angaben von Angle, Zoom und Co an
-- einzelnen Pages werden ignoriert.
--
-- <b>Alias</b>: StartBriefing
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=number] ID des Briefing
-- @within Anwenderfunktionen
--
function API.StartBriefing(_Briefing)
    if GUI then
        return -1;
    end
    if type(_Briefing) ~= "table" then
        error("_Briefing must be a table!");
        return -1;
    end
    if #_Briefing == 0 then
        error("API.StartBriefing: _Briefing does not contain pages!");
        return -1;
    end
    return BundleBriefingSystem.Global:StartBriefing(_Briefing);
end
StartBriefing = API.StartBriefing;

---
-- Startet das Briefing als Mission Start Briefing.
--
-- Diese Funktion setzt das mit ihr aufgerufene Briefing als das Mission Start
-- Briefing. Mit dem entsprechenden Trigger kann auf das Ende des Briefings
-- gewartet werden.
--
-- <b>Alias</b>: StartMissionBriefing
--
-- @param[type=function] _Function Funktion mit Briefing
-- @within Anwenderfunktionen
-- @see Trigger_MissionBriefing
--
function API.StartMissionBriefing(_Function)
    if GUI then
        return;
    end
    if type(_Function) ~= "function" then
        error("API.StartMissionBriefing: _Function must be a function!");
        return;
    end
    local ID = _Function();
    if type(ID) ~= "number" then
        error("API.StartMissionBriefing: _Function did not return an ID!");
        return;
    end
    BundleBriefingSystem.Global.Data.MissionStartBriefingID = ID;
end
StartMissionBriefing = API.StartMissionBriefing;

---
-- Prüft, ob ein Briefing einmal gestartet wurde und bis zum Ende kam.
--
-- <b>Alias</b>: IsBriefingFinished
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=boolean] Briefing ist beendet
-- @within Anwenderfunktionen
--
function API.IsBriefingFinished(_BriefingID)
    if GUI then
        return false;
    end
    return BundleBriefingSystem.Global.Data.FinishedBriefings[_BriefingID] == true;
end
IsBriefingFinished = API.IsBriefingFinished;

---
-- Prüft, ob aktuell ein Briefing aktiv ist.
--
-- <b>Alias</b>: IsBriefingActive
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=boolean] Briefing ist beendet
-- @within Anwenderfunktionen
--
function API.IsBriefingActive(_BriefingID)
    if GUI then
        return BundleBriefingSystem.Local.Data.BriefingActive == true;
    end
    return BundleBriefingSystem.Global.Data.BriefingActive == true;
end
IsBriefingActive = API.IsBriefingActive;

---
-- Ändert die Sichtbarkeit einer Antwort im aktuellen Briefing.
--
-- <b>Hinweis</b>: Außerhalb von Briefings hat die Funktion keinen Effekt!
--
-- <b>Alias</b>: SetAnswerVisibility
--
-- @param[type=number] _Page ID der Page
-- @param[type=number] _Answer ID der Antwort
-- @param[type=boolean] _Visible Sichtbarkeit
-- @within Internal
-- @local
--
function API.SetAnswerAvailability(_Page, _Answer, _Visible)
    if not GUI then
        -- PageID kann nur im globalen Skript bestimmt werden
        local PageID = BundleBriefingSystem.Global:GetPageIDByName(_Page);
        if PageID < 1 then
            error("Page '" ..tostring(_Page).. "' does not exist!");
            return;
        end
        Logic.ExecuteInLuaLocalState(string.format("API.SetAnswerAvailability(%d, %d, %s)", PageID, _Answer, tostring(not _Visible)));
        return;
    end
    BundleBriefingSystem.Local:SetMCAnswerState(_Page, _Answer, _Visible);
 end
 SetAnswerVisibility = API.SetAnswerAvailability;

---
-- Erzeugt die Funktionen zur Erstellung von Seiten in einem Briefing und bindet
-- sie an das Briefing. Diese Funktion muss vor dem Start eines Briefing
-- aufgerufen werden um Seiten hinzuzufügen.
-- <ul>
-- <li><a href="#AP">AP</a></li>
-- </ul>
--
-- <b>Alias</b>: AddPages
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=function] <a href="#AP">AP</a>
-- @within Anwenderfunktionen
--
-- @usage local AP = API.AddPages(Briefing);
--
function API.AddPages(_Briefing)
    if GUI then
        return;
    end
    _Briefing.GetPage = function(self, _NameOrID)
        local ID = BundleBriefingSystem.Global:GetPageIDByName(_NameOrID);
        return BundleBriefingSystem.Global.Data.CurrentBriefing[ID];
    end

    local AP = function(_Page)
        _Briefing.Length = (_Briefing.Length or 0) +1;
        if type(_Page) == "table" then
            _Page.__Legit = true;
            -- Sprache anpassen
            _Page.Title = API.ConvertPlaceholders(API.Localize(_Page.Title));
            _Page.Text = API.ConvertPlaceholders(API.Localize(_Page.Text));
            -- Lookat mappen
            if type(_Page.LookAt) == "string" or type(_Page.LookAt) == "number" then
                _Page.LookAt = {_Page.LookAt, 0}
            end
            -- Position mappen
            if type(_Page.Position) == "string" or type(_Page.Position) == "number" then
                _Page.Position = {_Page.Position, 0}
            end
            -- Dialogkamera
            if not _Page.Animations then
                if _Page.DialogCamera == true then
                    _Page.Angle = _Page.Angle or BundleBriefingSystem.Global.Data.DLGCAMERA_ANGLEDEFAULT;
                    _Page.Zoom = _Page.Zoom or BundleBriefingSystem.Global.Data.DLGCAMERA_ZOOMDEFAULT;
                    _Page.FOV = _Page.FOV or BundleBriefingSystem.Global.Data.DLGCAMERA_FOVDEFAULT;
                    _Page.Rotation = _Page.Rotation or BundleBriefingSystem.Global.Data.DLGCAMERA_ROTATIONDEFAULT;
                else
                    _Page.Angle = _Page.Angle or BundleBriefingSystem.Global.Data.CAMERA_ANGLEDEFAULT;
                    _Page.Zoom = _Page.Zoom or BundleBriefingSystem.Global.Data.CAMERA_ZOOMDEFAULT;
                    _Page.FOV = _Page.FOV or BundleBriefingSystem.Global.Data.CAMERA_FOVDEFAULT;
                    _Page.Rotation = _Page.Rotation or BundleBriefingSystem.Global.Data.CAMERA_ROTATIONDEFAULT;
                end
            end
            -- Anzeigezeit setzen
            if not _Page.Duration and not _Page.Animations then
                if _Page.FlyTo then
                    _Page.Duration = _Page.FlyTo.Duration;
                else
                    _Page.NoSkipping = false;
                    _Page.Duration = -1;
                end
            end
            -- Multiple Choice
            if _Page.MC then
                for i= 1, #_Page.MC do
                    _Page.MC[i][1] = API.Localize(_Page.MC[i][1]);
                    _Page.MC[i].ID = _Page.MC[i].ID or i;
                end
                _Page.NoSkipping = true;
                _Page.Duration = -1;
            end
            _Page.GetSelectedAnswer = function(self)
                if not self.MC or not self.MC.Selected then
                    return 0;
                end
                return self.MC.Selected;
            end
            table.insert(_Briefing, _Page);
        else
            table.insert(_Briefing, (_Page ~= nil and _Page) or -1);
        end
        return _Page;
    end

    local ASP = function(...)
        local PageName;
        if type(arg[4]) == "string" or type(arg[4]) == "table" then
            PageName = table.remove(arg, 1);
        end
        -- Position angleichen
        local Position = BundleBriefingSystem.Global:NormalizeZPosForEntity(table.remove(arg, 1));
        -- Rotation angleichen
        local Rotation = BundleBriefingSystem.Global:NormalizeRotationForEntity(Position[1]);
        -- Größe abgleichen
        local SizeSV = QSB.ScriptingValues[QSB.ScriptingValues.Game].Size;
        local Size = Logic.GetEntityScriptingValue(GetID(Position[1]), SizeSV);
        Position[2] = Position[2] * Core:ScriptingValueIntegerToFloat(Size);
    
        local Title  = table.remove(arg, 1);
        local Text   = table.remove(arg, 1);
        local DlgCam = table.remove(arg, 1);
        local Action;
        if type(arg[1]) == "function" then
            Action = table.remove(arg, 1);
        end
        return AP {
            Name         = PageName,
            Title        = Title,
            Text         = Text,
            Position     = Position,
            Zoom         = (DlgCam and 1000) or BundleBriefingSystem.Global.Data.CAMERA_ZOOMDEFAULT,
            Angle        = (DlgCam and 27) or BundleBriefingSystem.Global.Data.CAMERA_ANGLEDEFAULT,
            Rotation     = Rotation,
            Duration     = -1,
            Action       = Action
        }
    end
    
    return AP, ASP;
end
AddPages = API.AddPages;

---
-- Erstellt eine Seite für ein Dialog-Briefing.
--
-- <b>Achtung</b>: Diese Funktion wird von
-- <a href="#API.AddPages">API.AddPages</a> erzeugt und an
-- das Briefing gebunden.
--
-- <h5>Dialog Page</h5>
-- Eine Dialog Page ist eine einfache Seite, zu der es keine spezielle
-- Kameraanimation gibt. Sie kann für die Darstellung von Dialogen zwischen
-- Spielfiguren benutzt werden. Folgende Optionen stehen zur Verfügung:
-- <table border="1">
-- <tr>
-- <td><b>Einstellung</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Title</td>
-- <td>Der Titel, der oben angezeigt wird. Es ist möglich eine Table mit
-- deutschen und englischen Texten anzugeben.</td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>Der Text, der unten angezeigt wird. Es ist möglich eine Table mit
-- deutschen und englischen Texten anzugeben.</td>
-- </tr>
-- <tr>
-- <td>Position</td>
-- <td>Striptname des Entity, welches die Kamera ansieht. Es kann auch eine
-- Table angegeben werden. Dann ist der erste Wert die Position und der
-- zweite Wert das Z-Offset.</td>
-- </tr>
-- <tr>
-- <td>Duration</td>
-- <td>Bestimmt, wie lange die Page angezeigt wird. Wenn du es weglässt,
-- wird die Page solange angezeigt, bis der Spieler "Weiter" klickt.</td>
-- </tr>
-- <tr>
-- <td>DialogCamera</td>
-- <td>Eine Boolean, welche angibt, ob Nah- oder Fernsicht benutzt wird.</td>
-- </tr>
-- <tr>
-- <td>Action</td>
-- <td>Eine optional angebbare Funktion, die jedes Mal ausgeführt wird, sobald
-- die Seite angezeigt wird.</td>
-- </tr>
-- </table>
-- <p>Beispiel:</p>
-- <pre>AP {
--    Title        = "Marcus",
--    Text         = "Das ist eine simple Dialogseite",
--    Position     = "Marcus",
--    DialogCamera = true,
--};</pre>
-- Eine solche Seite wird immer im Winkel von -45° auf die Welt schauen.
-- 
-- <br><br><h5>Erweiterte Dialog Page</h5>
-- Will man die Kameraeinstellungen selbst vornehmen kann man einige oder alle
-- der folgenden Optionen ergänzen:
-- <table border="1">
-- <tr>
-- <td><b>Einstellung</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>Rotation</td>
-- <td>Die Rotation der Kamera gibt den Winkel an, indem die Kamera um das
-- Ziel gedreht wird.</td>
-- </tr>
-- <tr>
-- <td>Zoom</td>
-- <td>Zoom bestimmt die Entfernung der Kamera zum Ziel.</td>
-- </tr>
-- <tr>
-- <td>Angle</td>
-- <td>Der Angle gibt den Winkel an, in dem die Kamera gekippt wird.</td>
-- </tr>
-- <tr>
-- <td>FadeIn</td>
-- <td>Diese Option ermöglicht das Einblenden von schwarz.</td>
-- </tr>
-- <tr>
-- <td>FadeOut</td>
-- <td>Diese Option ermoglicht das Ausblenden zu schwarz.</td>
-- </tr>
-- <tr>
-- <td>FaderAlpha</td>
-- <td>Diese Option ermöglicht eine Seite komplett schwarz darzustellen. Du
-- kannst dies Einsetzen um von einem Punkt zum anderen zu springen und
-- "hinter dem Vorhang" Änderungen vorzunehmen, wie z.B. Entiries erzeugen.</td>
-- </tr>
-- </table>
--
-- <br><h5>Bedingtes Anzeigen</h5>
-- Hat man verschiedene Handlungsstränge oder sollen sich die Texte an die
-- Aktionen des Spielers anpassen, so kann es sein, dass man Pages anzeigen
-- oder überspringen will. Dafür kann man Pages einen Namen geben.
-- <pre>AP {
--    Name        = "ExamplePage1",
--    ...
--};</pre>
-- Mit diesem Namen kann eine Page direkt angesprungen werden.
-- <pre>AP("ExamplePage1")</pre>
--
-- <br><h5>Multiple Choice</h5>
-- In einem Dialog kann der Spieler auch zur Auswahl einer Option gebeten
-- werden. Dies wird als Multiple Choice bezeichnet. Schreibe die Optionen
-- in eine Subtable MC.
-- <pre>AP {
--    ...
--    MC = {
--        {"Antwort 1", "ExamplePage1"},
--        {"Antwort 2", Option2Clicked},
--    },
--};</pre>
-- Es kann der Name der Zielseite angegeben werden, oder eine Funktion, die
-- den Namen des Ziels zurück gibt. In der Funktion können vorher beliebige
-- Dinge getan werden, wie z.B. Variablen setzen.
--
-- Eine Antwort kann markiert werden, dass sie auch bei einem Rücksprung,
-- nicht mehrfach gewählt werden kann.
-- <pre>{"Antwort 3", "AnotherPage", Remove = true},</pre>
-- Eine Option kann auch bedingt ausgeblendet werden. Dazu wird eine Funktion
-- angegeben, die für alle Optionen aller MC-Seiten beim Start des Briefing
-- entscheidet, ob die Option sichtbar ist oder nicht.
-- <pre>{"Antwort 3", "AnotherPage", Disable = OptionIsDisabled},</pre>
--
-- Nachdem der Spieler eine Antwort gewählt hat, wird er auf die Seite mit
-- dem angegebenen Namen geleitet.
--
-- Um das Briefing zu beenden, nachdem ein Pfad beendet ist, wird eine leere
-- AP-Seite genutzt. Auf diese Weise weiß das Briefing, das es an dieser
-- Stelle zuende ist.
-- <pre>AP()</pre>
--
-- Soll stattdessen zu einer anderen Seite gesprungen werden, kann bei AP der
-- Name der Seite angeben werden, zu der gesprungen werden soll.
-- <pre>AP("SomePageName")</pre>
--
-- Um später zu einem beliebigen Zeitpunkt die gewählte Antwort einer Seite zu
-- erfahren, muss der Name der Seite genutzt werden.
-- <pre>Briefing.Finished(_Data)
--    local Choosen = _Data:GetPage("Choice"):GetSelectedAnswer();
--end</pre>
-- Die zurückgegebene Zahl ist der Index der Antwort, angefangen von oben.
-- Wird 0 zurückgegeben, wurde noch nicht geantwortet. Wenn Anworten nicht
-- aktiv sind, verändert sich der Index anderer Antworten nicht.
--
-- <br><h5>Zurückblättern</h5>
-- Wenn man zurückblättern erlaubt, aber nicht will, dass die Entscheidung
-- erneut getroffen werden kann, kann man dies mit NoRethink unterbinden.
-- <pre>AP {
--    ...
--    NoRethink = true,
--};</pre>
-- Auf diese Weise hat der Spieler die Möglichkeit die Texte nach der letzten
-- Entscheidung noch einmal zu lesen, ohne dass er seine Meinung ändern kann.
--
-- @param[type=table] _Page Spezifikation der Seite
-- @return[type=table] Refernez auf die angelegte Seite
-- @within Briefing
--
function AP(_Page)
    error("AP: Please use the function provides by AddPages!");
end

---
-- Erstellt eine Seite in vereinfachter Syntax. Es wird davon
-- Ausgegangen, dass das Entity ein Siedler ist. Die Kamera
-- schaut den Siedler an.
--
-- <b>Achtung</b>: Diese Funktion wird von
-- <a href="#API.AddPages">API.AddPages</a> erzeugt und an
-- das Briefing gebunden.
--
-- @param[type=string]   _pageName     (optional) Briefing-Seite Namen geben
-- @param[type=string]   _entity       Entity, das die Kamera zeigt
-- @param[type=string]   _title	       Titel der Seite
-- @param[type=string]   _text         Text der Seite
-- @param[type=boolean]  _dialogCamera Nahsicht an/aus
-- @param[type=function] _action       (Optional) Callback-Funktion
-- @return[type=table] Referenz auf die Seite
-- @within Briefing
-- 
-- @usage -- Beispiel ohne Page Name
-- ASP("hans", "Hänschen-Klein", "Ich gehe in die weitel Welt hinein.", true);
-- -- Beispiel mit Page Name
-- ASP("B1P1", "hans", "Hänschen-Klein", "Ich gehe in die weitel Welt hinein.", true);
--
function ASP(...)
    error("ASP: Please use the function provided by AddPages!");
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleBriefingSystem = {
    Global = {
        Data = {
            CAMERA_ANGLEDEFAULT = 43,
            CAMERA_ROTATIONDEFAULT = -45,
            CAMERA_ZOOMDEFAULT = 6500,
            CAMERA_FOVDEFAULT = 42,
            DLGCAMERA_ANGLEDEFAULT = 27,
            DLGCAMERA_ROTATIONDEFAULT = -45,
            DLGCAMERA_ZOOMDEFAULT = 1750,
            DLGCAMERA_FOVDEFAULT = 25,

            FinishedBriefings = {},
            CurrentBriefing = {},
            CurrentPage = {},
            BriefingQueue = {},
            BriefingID = 0,
            DisplayIngameCutscene = false,
            BriefingActive = false,
            PauseQuests = true,
            MissionStartBriefingID = 0,
        }
    },
    Local = {
        Data = {
            CurrentBriefing = {},
            CurrentPage = {},
            BriefingMessages = {},
            DisplayIngameCutscene = false,
            BriefingActive = false,
            ChatOptionsWasShown = false,
            MessageLogWasShown = false,
            LastSkipButtonPressed = 0,
        },
    },

    Text = {
        NextButton = {de = "Weiter",  en = "Forward"},
        PrevButton = {de = "Zurück",  en = "Previous"},
        EndButton  = {de = "Beenden", en = "Close"},
    },
}

-- Global Script ------------------------------------------------------------ --

---
-- Startet das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:Install()
    StartSimpleHiResJobEx(self.BriefingExecutionController);
    StartSimpleJobEx(self.BriefingQuestPausedController);
end

---
-- Konvertiert eine Briefing-Table des alten Formats in das neue.
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=number] ID des Briefing
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:ConvertBriefingTable(_Briefing)
    _Briefing.DisableGlobalInvulnerability = _Briefing.disableGlobalInvulnerability or _Briefing.DisableGlobalInvulnerability;
    _Briefing.HideBorderPins = _Briefing.hideBorderPins or _Briefing.HideBorderPins;
    _Briefing.ShowSky = _Briefing.showSky or _Briefing.ShowSky;
    _Briefing.RestoreGameSpeed = _Briefing.restoreGameSpeed or _Briefing.RestoreGameSpeed;
    _Briefing.RestoreCamera = _Briefing.restoreCamera or _Briefing.RestoreCamera;
    _Briefing.SkippingAllowed = (_Briefing.skipPerPage or _Briefing.skipAll) or _Briefing.SkippingAllowed;
    _Briefing.ReturnForbidden = _Briefing.returnForbidden or _Briefing.ReturnForbidden;
    _Briefing.Finished = _Briefing.finished or _Briefing.Finished;
    _Briefing.Starting = _Briefing.starting or _Briefing.Starting;
    
    for k, v in pairs(_Briefing) do
        if type(v) == "table" then
            -- Normale Optionen
            _Briefing[k].Title = v.title or _Briefing[k].Title;
            _Briefing[k].Text = v.text or _Briefing[k].Text;
            _Briefing[k].Position = (v.position and {v.position, 0}) or _Briefing[k].Position;
            _Briefing[k].Angle = v.angle or _Briefing[k].Angle;
            _Briefing[k].Rotation = v.rotation or _Briefing[k].Rotation;
            _Briefing[k].Zoom = v.zoom or _Briefing[k].Zoom;
            _Briefing[k].Action = v.action or _Briefing[k].Action;
            _Briefing[k].FadeIn = v.fadeIn or _Briefing[k].FadeIn;
            _Briefing[k].FadeOut = v.fadeOut or _Briefing[k].FadeOut;
            _Briefing[k].FaderAlpha = v.faderAlpha or _Briefing[k].FaderAlpha;
            _Briefing[k].DialogCamera = v.dialogCamera or _Briefing[k].DialogCamera;
            _Briefing[k].Portrait = v.portrait or _Briefing[k].Portrait;
            _Briefing[k].NoRethink = v.noRethink or _Briefing[k].NoRethink;
            _Briefing[k].NoHistory = v.noHistory or _Briefing[k].NoHistory;
            -- Splashscreen
            if v.splashscreen then
                v.Splashscreen = v.splashscreen;
                if type(v.Splashscreen) == "table" then
                    v.Splashscreen = v.Splashscreen.image;
                end
            end
            -- Multiple Choice
            if v.mc then
                _Briefing[k].Title = v.mc.title;
                _Briefing[k].Text = v.mc.title;
                _Briefing[k].MC = v.mc.answers;
            end
        end
    end
    return _Briefing;
end

---
-- Startet ein Briefing.
--
-- @param[type=table] _Briefing Briefing Definition
-- @param[type=number] _ID      ID aus Queue
-- @return[type=number] ID des Briefing
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:StartBriefing(_Briefing, _ID)
    _Briefing = self:ConvertBriefingTable(_Briefing);
    if _Briefing.ReturnForbidden == nil then
        _Briefing.ReturnForbidden = true;
    end

    if not _ID then
        self.Data.BriefingID = self.Data.BriefingID +1;
        _ID = self.Data.BriefingID;
    end

    if API.IsLoadscreenVisible() or self:IsBriefingActive() then
        table.insert(self.Data.BriefingQueue, {_Briefing, _ID});
        if not self.Data.BriefingQueueJobID then
            self.Data.BriefingQueueJobID = StartSimpleHiResJobEx(self.BriefingQueueController);
        end
        return _ID;
    end

    if not self:AreAllPagesLegit(_Briefing) then
        error("API.StartBriefing: Discovered illegaly added pages inside the briefing!");
        return _ID;
    end

    self.Data.CurrentBriefing = API.InstanceTable(_Briefing);
    self.Data.CurrentBriefing.Page = 1;
    self.Data.CurrentBriefing.PageHistory = {};
    self.Data.CurrentBriefing.ID = _ID;
    self.Data.CurrentBriefing.BarOpacity = self.Data.CurrentBriefing.BarOpacity or 1;

    -- Animationen übertragen
    self:TransformAnimations();
    
    -- Bars Default setzen
    if self.Data.CurrentBriefing.BigBars == nil then
        self.Data.CurrentBriefing.BigBars = true;
    end
    -- Multiple Choice vorbereiten
    self:DisableMCAnswers();
    -- Globale Unverwundbarkeit
    if self.Data.CurrentBriefing.DisableGlobalInvulnerability ~= false then
        Logic.SetGlobalInvulnerability(1);
    end
    -- Kopieren ins lokale Skript
    local Briefing = API.ConvertTableToString(self.Data.CurrentBriefing);
    Logic.ExecuteInLuaLocalState("BundleBriefingSystem.Local:StartBriefing(" ..Briefing.. ")");
    
    self.Data.BriefingActive = true;
    if self.Data.CurrentBriefing.Starting then
        self.Data.CurrentBriefing:Starting();
    end
    self.Data.CurrentPage = {};
    self:PageStarted();
    return _ID;
end

---
-- Beendet ein Briefing.
--
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:FinishBriefing()
    Logic.SetGlobalInvulnerability(0);
    Logic.ExecuteInLuaLocalState("BundleBriefingSystem.Local:FinishBriefing()");

    if self.Data.CurrentBriefing.Finished then
        self.Data.CurrentBriefing:Finished();
    end

    self.Data.FinishedBriefings[self.Data.CurrentBriefing.ID] = true;
    self.Data.CurrentBriefing = {};
    self.Data.CurrentPage = {};
    self.Data.BriefingActive = false;
end

---
-- Gibt die Page-ID zum angegebenen Page-Namen zurück.
--
-- Wenn keine Seite gefunden wird, die den angegebenen Namen hat, wird 0
-- zurückgegeben. Wenn eine Page-ID angegeben wird, wird diese zurückgegeben.
--
-- @param[type=string] _PageName Name der Seite
-- @return[type=number] ID der Seite
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:GetPageIDByName(_PageName)
    if self.Data.CurrentBriefing then
        if type(_PageName) == "number" then
            return _PageName;
        end
        for i= 1, self.Data.CurrentBriefing.Length, 1 do
            local Page = self.Data.CurrentBriefing[i];
            if Page and type(Page) == "table" and Page.Name == _PageName then
                return i;
            end
        end
    end
    return 0;
end

---
-- Startet die aktuelle Briefing-Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:PageStarted()
    local PageID = self.Data.CurrentBriefing.Page;
    if PageID then
        if type(self.Data.CurrentBriefing[PageID]) == "table" then
            if type(self.Data.CurrentBriefing[PageID]) == "table" then
                if self.Data.CurrentBriefing[PageID].Action then
                    self.Data.CurrentBriefing[PageID]:Action();
                end
                self.Data.CurrentPage = self.Data.CurrentBriefing[PageID];
                self.Data.CurrentPage.Started = Logic.GetTime();
                Logic.ExecuteInLuaLocalState("BundleBriefingSystem.Local:PageStarted()");
            end

        elseif type(self.Data.CurrentBriefing[PageID]) == "string" then
            PageID = self:GetPageIDByName(self.Data.CurrentBriefing[PageID]);
            if PageID > 0 then
                self.Data.CurrentBriefing.Page = PageID;
                Logic.ExecuteInLuaLocalState("BundleBriefingSystem.Local.Data.CurrentBriefing.Page = " ..PageID);
                self:PageStarted();
            else
                self:FinishBriefing();
            end

        elseif type(self.Data.CurrentBriefing[PageID]) == "number" and self.Data.CurrentBriefing[PageID] > 0 then
            self.Data.CurrentBriefing.Page = self.Data.CurrentBriefing[PageID];
            Logic.ExecuteInLuaLocalState("BundleBriefingSystem.Local.Data.CurrentBriefing.Page = " ..self.Data.CurrentBriefing.Page);
            self:PageStarted();

        else
            self:FinishBriefing();
        end
    end
end

---
-- Beendet die aktuelle Briefing-Seite
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:PageFinished()
    local PageID = self.Data.CurrentBriefing.Page;
    Logic.ExecuteInLuaLocalState("BundleBriefingSystem.Local:PageFinished()");
    self.Data.CurrentBriefing.Page = (self.Data.CurrentBriefing.Page or 0) +1;
    local PageID = self.Data.CurrentBriefing.Page;
    if not self.Data.CurrentBriefing[PageID] or PageID > #self.Data.CurrentBriefing then
        BundleBriefingSystem.Global:FinishBriefing();
    else
        BundleBriefingSystem.Global:PageStarted();
    end
end

---
-- Prüft, ob ein Briefing aktiv ist.
-- @return[type=boolean] Briefing ist aktiv
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:IsBriefingActive()
    return self.Data.BriefingActive == true;
end

function BundleBriefingSystem.Global:AreAllPagesLegit(_Briefing)
    for i= 1, #_Briefing, 1 do
        if type(_Briefing[i]) == "table" then
            if not _Briefing[i].__Legit then
                return false;
            end
        end
    end
    return true;
end

---
-- Bindet die angegebenen Animationen an die jeweiligen Pages.
--
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:TransformAnimations()
    if self.Data.CurrentBriefing.PageAnimations then
        for k, v in pairs(self.Data.CurrentBriefing.PageAnimations) do
            local PageID = self:GetPageIDByName(k);
            self.Data.CurrentBriefing[PageID].Animations = self.Data.CurrentBriefing[PageID].Animations or {};
            self.Data.CurrentBriefing[PageID].Animations.PurgeOld = v.PurgeOld == true;
            for i= 1, #v, 1 do               
                -- Relative Angabe
                if #v[i] == 9 then
                    table.insert(self.Data.CurrentBriefing[PageID].Animations, {
                        Duration = v[i][9] or 2 * 60,

                        Start = {
                            Position = (type(v[i][1]) ~= "table" and {v[i][1],0}) or v[i][1],
                            Rotation = v[i][2],
                            Zoom     = v[i][3],
                            Angle    = v[i][4],
                        },
                        End = {
                            Position = (type(v[i][5]) ~= "table" and {v[i][5],0}) or v[i][5],
                            Rotation = v[i][6],
                            Zoom     = v[i][7],
                            Angle    = v[i][8],
                        },
                    });
                -- Vektorisierte Angabe
                elseif #v[i] == 5 then
                    table.insert(self.Data.CurrentBriefing[PageID].Animations, {
                        Duration = v[i][5] or 2 * 60,

                        Start = {
                            Position = (type(v[i][1]) ~= "table" and {v[i][1],0}) or v[i][1],
                            LookAt   = (type(v[i][2]) ~= "table" and {v[i][1],0}) or v[i][2],
                        },
                        End = {
                            Position = (type(v[i][3]) ~= "table" and {v[i][5],0}) or v[i][3],
                            LookAt   = (type(v[i][4]) ~= "table" and {v[i][1],0}) or v[i][4],
                        },
                    });
                end
            end
        end
        self.Data.CurrentBriefing.PageAnimations = nil;
    end
end

---
-- Gibt für das Entity eine Tabelle mit Skriptnamen und Z-Offset zurück.
--
-- @param[type=string] _Entity Skriptname des Entity
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:NormalizeZPosForEntity(_Entity)
    local TargetID = GetID(_Entity);
    local TargetType = Logic.GetEntityType(TargetID);
    local Position = {_Entity, 0};
    if Logic.IsSettler(TargetID) == 1 then
        Position[2] = 120;
        if Logic.IsKnight(TargetID) then
            Position[2] = 160;
        end
    end
    if TargetType == Entities.XD_ScriptEntity then
        Position[2] = 160;
    end
    return Position;
end

---
-- Gibt die Rotation für das Entity zurück.
--
-- @param[type=string] _Entity Skriptname des Entity
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:NormalizeRotationForEntity(_Entity)
    local Rotation = 0;
    if IsExisting(_Entity) then
        Rotation = Logic.GetEntityOrientation(GetID(_Entity));
        if Logic.IsSettler(GetID(_Entity)) == 1 then
            Rotation = Rotation + 90;
        end
    end
    return Rotation;
end

---
-- Reagiert auf die Auswahl einer Option einer Multiple-Choice-Page.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:OnMCConfirmed(_Selected)
    if self.Data.CurrentPage.MC then
        local PageID = self.Data.CurrentBriefing.Page;
        self.Data.CurrentBriefing[PageID].MC.Selected = _Selected;
        local JumpData = self.Data.CurrentPage.MC[_Selected];
        if type(JumpData[2]) == "function" then
            self.Data.CurrentBriefing.Page = self:GetPageIDByName(JumpData[2](self.Data.CurrentPage, JumpData))-1;
        else
            self.Data.CurrentBriefing.Page = self:GetPageIDByName(JumpData[2])-1;
        end
        Logic.ExecuteInLuaLocalState("BundleBriefingSystem.Local.Data.CurrentBriefing.Page = " ..self.Data.CurrentBriefing.Page);
        self:PageFinished();
    end
end

---
-- Aktualisiert, ob eine Option sichtbar ist oder nicht. Eine Option
-- braucht eine Update-Funktion "Display". Die Update-Funktion
-- erhält Daten der Seite und Daten der Antwort.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:DisableMCAnswers()
    for i= 1, #self.Data.CurrentBriefing, 1 do
        if type(self.Data.CurrentBriefing[i]) == "table" and self.Data.CurrentBriefing[i].MC then
            for k, v in pairs(self.Data.CurrentBriefing[i].MC) do 
                if type(v) == "table" and type(v.Disable) == "function" then
                    local Invisible = v.Disable(self.Data.CurrentBriefing[i], v) == true;
                    self.Data.CurrentBriefing[i].MC[k].Invisible = Invisible;
                end
            end
        end
    end
end

---
-- Steuert das automatische weiter blättern und Sprünge zwischen Pages.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global.BriefingExecutionController()
    if not BundleBriefingSystem.Global.Data.DisplayIngameCutscene and BundleBriefingSystem.Global:IsBriefingActive() then
        if BundleBriefingSystem.Global.Data.CurrentPage == nil then
            BundleBriefingSystem.Global:FinishBriefing();

        elseif type(BundleBriefingSystem.Global.Data.CurrentPage) == "table" then
            local Duration = (BundleBriefingSystem.Global.Data.CurrentPage.Duration or 0);
            if Duration > -1 and BundleBriefingSystem.Global.Data.CurrentPage.Started then
                if Logic.GetTime() > BundleBriefingSystem.Global.Data.CurrentPage.Started + Duration then
                    local PageID = BundleBriefingSystem.Global.Data.CurrentBriefing.Page;
                    if not BundleBriefingSystem.Global.Data.CurrentPage.NoHistory then
                        Logic.ExecuteInLuaLocalState("table.insert(BundleBriefingSystem.Local.Data.CurrentBriefing.PageHistory, " ..PageID.. ")");
                    end
                    BundleBriefingSystem.Global:PageFinished();
                end
            end
        end
    end
end

---
-- Verhindert, dass während Briefings Quest-Timer weiter laufen.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global.BriefingQuestPausedController()
    if BundleBriefingSystem.Global.Data.BriefingActive and BundleBriefingSystem.Global.Data.PauseQuests then
        for i= 1, #Quests, 1 do
            if Quests[i].State == QuestState.Active then
                Quests[i].StartTime = Quests[i].StartTime +1;
            end
        end
    end
end

---
-- Steuert die Briefing-Warteschlange.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global.BriefingQueueController()
    if #BundleBriefingSystem.Global.Data.BriefingQueue == 0 then
        BundleBriefingSystem.Global.Data.BriefingQueueJobID = nil;
        return true;
    end
    
    if not API.IsLoadscreenVisible() and not BundleBriefingSystem.Global:IsBriefingActive() then
        local Next = table.remove(BundleBriefingSystem.Global.Data.BriefingQueue, 1);
        BundleBriefingSystem.Global:StartBriefing(Next[1], Next[2]);
    end
end

-- Local Script ------------------------------------------------------------- --

---
-- Startet das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:Install()
    if not InitializeFader then
        Script.Load("script/mainmenu/fader.lua");
    end
    self:OverrideThroneRoomFunctions();
end

---
-- Startet ein Briefing.
-- @param[type=table] _Briefing Briefing Definition
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:StartBriefing(_Briefing)
    self.Data.CurrentBriefing.Page = 1;
    self.Data.CurrentBriefing = _Briefing;
    self.Data.CurrentBriefing.CurrentAnimation = nil;
    self.Data.CurrentBriefing.AnimationQueue = {};
    if self.Data.CurrentBriefing.HideBorderPins then
        Display.SetRenderBorderPins(0);
    end
    if self.Data.CurrentBriefing.ShowSky then
        Display.SetRenderSky(1);
    end
    if Game.GameTimeGetFactor() ~= 0 then
        if self.Data.CurrentBriefing.RestoreGameSpeed and not self.Data.GameSpeedBackup then
            self.Data.GameSpeedBackup = Game.GameTimeGetFactor();
        end
        Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
    end
    if self.Data.CurrentBriefing.RestoreCamera and not self.Data.CameraBackup then
        self.Data.CameraBackup = {Camera.RTS_GetLookAtPosition()};
    end
    if not self.Data.CinematicActive then
        self:ActivateCinematicMode();
    end
    self.Data.BriefingActive = true;
end

---
-- Beendet ein Briefing.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:FinishBriefing()
    if self.Data.CurrentBriefing.CameraBackup then 
        Camera.RTS_SetLookAtPosition(unpack(self.Data.CurrentBriefing.CameraBackup));
        self.Data.CurrentBriefing.CameraBackup = nil;
    end
    Display.SetRenderBorderPins(1);
    Display.SetRenderSky(0);
    local GameSpeed = (self.Data.GameSpeedBackup or 1);
    Game.GameTimeSetFactor(GUI.GetPlayerID(), GameSpeed);
    self.Data.GameSpeedBackup = nil;
    self:DeactivateCinematicMode();
    self.Data.BriefingActive = false;
    self.Data.CurrentBriefing = {};
    self.Data.CurrentPage = {};
end

---
-- Zeigt die aktuele Seite an.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:PageStarted()
    local PageID = self.Data.CurrentBriefing.Page;
    self.Data.CurrentPage = self.Data.CurrentBriefing[PageID];
    if type(self.Data.CurrentPage) == "table" then
        self.Data.CurrentPage.Started = XGUIEng.GetSystemTime();

        -- Zurück und Weiter
        local BackFlag = 1;
        local SkipFlag = 1;
        if self.Data.CurrentBriefing.SkippingAllowed ~= true or self.Data.CurrentPage.NoSkipping == true then
            if self.Data.CurrentPage.MC and not self.Data.CurrentPage.NoHistory then
                table.insert(self.Data.CurrentBriefing.PageHistory, PageID);
            end
            SkipFlag = 0;
            BackFlag = 0;
        end
        local LastPageID = self.Data.CurrentBriefing.PageHistory[#self.Data.CurrentBriefing.PageHistory];
        local LastPage = self.Data.CurrentBriefing[LastPageID];
        local NoRethinkMC = (type(LastPage) == "table" and LastPage.NoRethink and 0) or 1;
        if PageID == 1 or NoRethinkMC == 0 or self.Data.CurrentBriefing.ReturnForbidden == true then
            BackFlag = 0;
        end
        if  (self.Data.CurrentPage.Duration == nil or self.Data.CurrentPage.Duration == -1)
        and not self.Data.CurrentPage.MC then
            SkipFlag = 1;
        end
        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", SkipFlag);
        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", BackFlag);

        -- Animationen
        if self.Data.CurrentPage.Animations then
            if self.Data.CurrentPage.Animations.PurgeOld then
                self.Data.CurrentBriefing.CurrentAnimation = nil;
                self.Data.CurrentBriefing.AnimationQueue = {};
            end
            for i= 1, #self.Data.CurrentPage.Animations, 1 do
                local Animation = API.InstanceTable(self.Data.CurrentPage.Animations[i]);
                table.insert(self.Data.CurrentBriefing.AnimationQueue, Animation);
            end
        end

        -- Titel setzen
        local TitleWidget = "/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight";
        XGUIEng.SetText(TitleWidget, "");
        if self.Data.CurrentPage.Title then
            local Title = self.Data.CurrentPage.Title;
            if Title:sub(1, 1) ~= "{" then
                Title = "{@color:255,250,0,255}{center}" ..Title;
            end
            XGUIEng.SetText(TitleWidget, Title);
        end

        -- Text setzen
        local TextWidget = "/InGame/ThroneRoom/Main/MissionBriefing/Text";
        XGUIEng.SetText(TextWidget, "");
        if self.Data.CurrentPage.Text then
            local Text = self.Data.CurrentPage.Text;
            if Text:sub(1, 1) ~= "{" then
                Text = "{center}" ..Text;
            end
            if not self.Data.CurrentBriefing.BigBars then
                Text = "{cr}{cr}{cr}" .. Text;
            end
            XGUIEng.SetText(TextWidget, Text);
        end

        -- Fader
        self:SetFader();
        -- Portrait
        self:SetPortrait();
        -- Splashscreen
        self:SetSplashscreen();
        -- Multiple Choice
        self:SetOptionsDialog();
    end
end

---
-- Beendet die aktuelle Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:PageFinished()
    -- TODO: Warum ist PageHistory hier u.U. nil?
    -- self.Data.CurrentBriefing.PageHistory = self.Data.CurrentBriefing.PageHistory or {};
    self.Data.CurrentBriefing.Page = (self.Data.CurrentBriefing.Page or 0) +1;
    EndJob(self.Data.CurrentBriefing.FaderJob);
end

---
-- Prüft, ob ein Briefing aktiv ist.
-- @param[type=boolean] Briefing ist aktiv
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:IsBriefingActive()
    return self.Data.BriefingActive == true;
end

---
-- Reagiert auf die Auswahl einer Option einer Multiple-Choice-Page.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:LocalOnMCConfirmed()
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Position = self.Data.OriginalBoxPosition;
    XGUIEng.SetWidgetScreenPosition(Widget, Position[1], Position[2]);
    XGUIEng.ShowWidget(Widget, 0);
    XGUIEng.PopPage();

    if self.Data.CurrentPage.MC then
        local Selected = XGUIEng.ListBoxGetSelectedIndex(Widget .. "/ListBox")+1;
        local AnswerID = self.Data.CurrentPage.MC.Map[Selected];
        for i= #self.Data.CurrentPage.MC, 1, -1 do
            if self.Data.CurrentPage.MC[i].ID == AnswerID and self.Data.CurrentPage.MC[i].Remove then
                self.Data.CurrentPage.MC[i].Invisible = true;
            end
        end
        GUI.SendScriptCommand("BundleBriefingSystem.Global:OnMCConfirmed(" ..AnswerID.. ")");
    end
end

---
-- Ändert die Sichtbarkeit einer Antwort im aktuellen Briefing.
-- @param[type=number] _Page ID der Page
-- @param[type=number] _Answer ID der Antwort
-- @param[type=boolean] _Visible Sichtbarkeit
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetMCAnswerState(_Page, _Answer, _Visible)
   assert(type(_Page) == "number");
   assert(type(_Answer) == "number");
   if self.Data.BriefingActive then
       if  self.Data.CurrentBriefing[_Page] and self.Data.CurrentBriefing[_Page].MC then
           for k, v in pairs(self.Data.CurrentBriefing[_Page].MC) do
               if v and v.ID == _Answer then
                   self.Data.CurrentBriefing[_Page].MC[k].Invisible = _Visible == true;
               end
           end
       end
   end
end

---
-- Steuert die Kamera während des Throneroom Mode.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ThroneRoomCameraControl()
    if self.Data.DisplayIngameCutscene then
        if AddOnCutsceneSystem then
            AddOnCutsceneSystem.Local:ThroneRoomCameraControl();
        end
    else
        if type(self.Data.CurrentPage) == "table" then
            -- Animation invalidieren
            if self.Data.CurrentBriefing.CurrentAnimation then
                local CurrentTime = XGUIEng.GetSystemTime();
                local Animation = self.Data.CurrentBriefing.CurrentAnimation;
                if CurrentTime > Animation.Started + Animation.Duration then
                    if #self.Data.CurrentBriefing.AnimationQueue > 0 then
                        self.Data.CurrentBriefing.CurrentAnimation = nil;
                    end
                end
            end
            -- Nächste Animation
            if self.Data.CurrentBriefing.CurrentAnimation == nil then
                if self.Data.CurrentBriefing.AnimationQueue and #self.Data.CurrentBriefing.AnimationQueue > 0 then
                    local Next = table.remove(self.Data.CurrentBriefing.AnimationQueue, 1);
                    Next.Started = XGUIEng.GetSystemTime();
                    self.Data.CurrentBriefing.CurrentAnimation = Next;
                end
            end

            -- Kamera
            local PX, PY, PZ = self:GetPagePosition();
            local LX, LY, LZ = self:GetPageLookAt();
            if PX and not LX then
                LX, LY, LZ, PX, PY, PZ = self:GetCameraProperties();
            end
            Camera.ThroneRoom_SetPosition(PX, PY, PZ);
            Camera.ThroneRoom_SetLookAt(LX, LY, LZ);
            Camera.ThroneRoom_SetFOV(42.0);

            -- Bar Style
            BundleBriefingSystem.Local:SetBarStyle(self.Data.CurrentBriefing.BarOpacity, self.Data.CurrentBriefing.BigBars);
            if self.Data.CurrentPage.BigBars ~= nil then
                BundleBriefingSystem.Local:SetBarStyle(self.Data.CurrentBriefing.BarOpacity, self.Data.CurrentPage.BigBars);
            end

            -- Splashscreen
            self:ScrollSplashscreen();

            -- Multiple Choice
            if self.Data.MCSelectionIsShown then
                local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
                if XGUIEng.IsWidgetShown(Widget) == 0 then
                    self.Data.MCSelectionIsShown = false;
                    self:LocalOnMCConfirmed();
                end
            end

            -- Button Texte
            XGUIEng.SetText("/InGame/ThroneRoom/Main/StartButton", "{center}" ..API.Localize(BundleBriefingSystem.Text.PrevButton));
            local SkipText = API.Localize(BundleBriefingSystem.Text.NextButton);
            local PageID = self.Data.CurrentBriefing.Page;
            if PageID == #self.Data.CurrentBriefing or self.Data.CurrentBriefing[PageID+1] == -1 then
                SkipText = API.Localize(BundleBriefingSystem.Text.EndButton);
            end
            XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..SkipText);
        end
    end
end

---
-- Gibt die Blickrichtung der Kamera und die Position der Kamera für den
-- Kompatibelitätsmodus zurück.
-- @return[type=number] LookAt X
-- @return[type=number] LookAt Y
-- @return[type=number] LookAt Z
-- @return[type=number] Position X
-- @return[type=number] Position Y
-- @return[type=number] Position Z
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:GetCameraProperties()
    local CurrPage, FlyTo;
    if self.Data.CurrentBriefing.CurrentAnimation then
        CurrPage = self.Data.CurrentBriefing.CurrentAnimation.Start;
        FlyTo = self.Data.CurrentBriefing.CurrentAnimation.End;
    else
        CurrPage = self.Data.CurrentPage;
        FlyTo = self.Data.CurrentPage.FlyTo;
    end

    local startPosition = CurrPage.Position;
    local endPosition = (FlyTo and FlyTo.Position) or CurrPage.Position;
    local startRotation = CurrPage.Rotation;
    local endRotation = (FlyTo and FlyTo.Rotation) or CurrPage.Rotation;
    local startZoomAngle = CurrPage.Angle;
    local endZoomAngle = (FlyTo and FlyTo.Angle) or CurrPage.Angle;
    local startZoomDistance = CurrPage.Zoom;
    local endZoomDistance = (FlyTo and FlyTo.Zoom) or CurrPage.Zoom;
    local startFOV = (CurrPage.FOV) or 42.0;
    local endFOV = ((FlyTo and FlyTo.FOV) or CurrPage.FOV) or 42.0;

    local factor = self:GetLERP();
    
    local lPLX, lPLY, lPLZ = BundleBriefingSystem.Local:ConvertPosition(startPosition);
    local cPLX, cPLY, cPLZ = BundleBriefingSystem.Local:ConvertPosition(endPosition);
    local lookAtX = lPLX + (cPLX - lPLX) * factor;
    local lookAtY = lPLY + (cPLY - lPLY) * factor;
    local lookAtZ = lPLZ + (cPLZ - lPLZ) * factor;

    local zoomDistance = startZoomDistance + (endZoomDistance - startZoomDistance) * factor;
    local zoomAngle = startZoomAngle + (endZoomAngle - startZoomAngle) * factor;
    local rotation = startRotation + (endRotation - startRotation) * factor;
    local line = zoomDistance * math.cos(math.rad(zoomAngle));
    local positionX = lookAtX + math.cos(math.rad(rotation - 90)) * line;
    local positionY = lookAtY + math.sin(math.rad(rotation - 90)) * line;
    local positionZ = lookAtZ + (zoomDistance) * math.sin(math.rad(zoomAngle));

    return lookAtX, lookAtY, lookAtZ, positionX, positionY, positionZ;
end

---
-- Gibt die interpolierte Kameraposition zurück.
-- @return[type=number] X
-- @return[type=number] Y
-- @return[type=number] Z
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:GetPagePosition()
    local Position, FlyTo;
    if self.Data.CurrentBriefing.CurrentAnimation then
        Position = self.Data.CurrentBriefing.CurrentAnimation.Start.Position;
        FlyTo = self.Data.CurrentBriefing.CurrentAnimation.End.Position;
    else
        Position = self.Data.CurrentPage.Position;
        FlyTo = self.Data.CurrentPage.FlyTo;
    end

    local x, y, z = self:ConvertPosition(Position);
    if FlyTo then
        local lX, lY, lZ = self:ConvertPosition(FlyTo.Position);
        if lX then
            x = x + (lX - x) * self:GetLERP();
            y = y + (lY - y) * self:GetLERP();
            z = z + (lZ - z) * self:GetLERP();
        end
    end
    return x, y, z;
end

---
-- Gibt die interpolierte Blickrichtung der Kamera zurück.
-- @return[type=number] X
-- @return[type=number] Y
-- @return[type=number] Z
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:GetPageLookAt()
    local LookAt, FlyTo;
    if self.Data.CurrentBriefing.CurrentAnimation then
        LookAt = self.Data.CurrentBriefing.CurrentAnimation.Start.LookAt;
        FlyTo = self.Data.CurrentBriefing.CurrentAnimation.End.LookAt;
    else
        LookAt = self.Data.CurrentPage.LookAt;
        FlyTo = self.Data.CurrentPage.FlyTo;
    end

    local x, y, z = self:ConvertPosition(LookAt);
    if FlyTo and x then
        local lX, lY, lZ = self:ConvertPosition(FlyTo.LookAt);
        if lX then
            x = x + (lX - x) * self:GetLERP();
            y = y + (lY - y) * self:GetLERP();
            z = z + (lZ - z) * self:GetLERP();
        end
    end
    return x, y, z;
end

---
-- Konvertiert die angegebenen Koordinaten zu XYZ.
-- @return[type=number] X
-- @return[type=number] Y
-- @return[type=number] Z
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ConvertPosition(_Table)
    local x, y, z;
    if _Table and _Table.X then
        x = _Table.X; y = _Table.Y; z = _Table.Z;
    elseif _Table and not _Table.X then
        x, y, z = Logic.EntityGetPos(GetID(_Table[1]));
        z = z + (_Table[2] or 0);
    end
    return x, y, z;
end

---
-- Gibt den linearen Interpolationsfaktor zurück.
-- @param[type=number] LERP
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:GetLERP()
    local Started, FlyTime;
    if self.Data.CurrentBriefing.CurrentAnimation then
        Started = self.Data.CurrentBriefing.CurrentAnimation.Started;
        FlyTime = self.Data.CurrentBriefing.CurrentAnimation.Duration;
    else
        Started = self.Data.CurrentPage.Started;
        FlyTime = self.Data.CurrentPage.Duration;
        if self.Data.CurrentPage.FlyTo then
            FlyTime = self.Data.CurrentPage.FlyTo.Duration;
        end
    end
	
	if not LERPFactor then
		LERPFactor = function(s, c, e)
		local f = (c - s) / e;
			return (f > 1 and 1) or f;
		end
	end
	
    local Factor = LERPFactor(
        Started,
        XGUIEng.GetSystemTime(),
        FlyTime
    );
    return math.min(Factor, 1);
end

---
-- Reagiert auf einen beliebigen Linksklick im Throneroom.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ThroneRoomLeftClick()
    if self.Data.DisplayIngameCutscene then
        if AddOnCutsceneSystem then
            AddOnCutsceneSystem.Local:ThroneRoomLeftClick();
        end
    else
        -- Klick auf Entity
        local EntityID = GUI.GetMouseOverEntity();
        GUI.SendScriptCommand([[
            local CurrentPage = BundleBriefingSystem.Global.CurrentPage;
            if CurrentPage and CurrentPage.LeftClickOnEntity then
                BundleBriefingSystem.Global.CurrentPage:LeftClickOnEntity(]] ..tostring(EntityID).. [[)
            end
        ]]);
        -- Klick in die Spielwelt
        local x,y = GUI.Debug_GetMapPositionUnderMouse();
        GUI.SendScriptCommand([[
            local CurrentPage = BundleBriefingSystem.Global.CurrentPage;
            if CurrentPage and CurrentPage.LeftClickOnPosition then
                BundleBriefingSystem.Global.CurrentPage:LeftClickOnPosition(]] ..tostring(x).. [[, ]] ..tostring(y).. [[)
            end
        ]]);
        -- Klick auf den Bildschirm
        local x,y = GUI.GetMousePosition();
        GUI.SendScriptCommand([[
            local CurrentPage = BundleBriefingSystem.Global.CurrentPage;
            if CurrentPage and CurrentPage.LeftClickOnScreen then
                BundleBriefingSystem.Global.CurrentPage:LeftClickOnScreen(]] ..tostring(x).. [[, ]] ..tostring(y).. [[)
            end
        ]]);
    end
end

---
-- Reagiert auf Klick auf den Skip-Button während des Throneroom Mode.
--
-- Wenn eine Cutscene aktiv ist, wird die überschriebene Methode aus dem
-- Addon benutzt.
--
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:NextButtonPressed()
    if self.Data.DisplayIngameCutscene then
        if AddOnCutsceneSystem then
            AddOnCutsceneSystem.Local:NextButtonPressed();
        end
    else
        if (self.Data.LastSkipButtonPressed + 500) < Logic.GetTimeMs() then
            self.Data.LastSkipButtonPressed = Logic.GetTimeMs();
            if not self.Data.CurrentPage.NoHistory then
                table.insert(self.Data.CurrentBriefing.PageHistory, self.Data.CurrentBriefing.Page);
            end
            if self.Data.CurrentPage.OnForward then
                GUI.SendScriptCommand("BundleBriefingSystem.Global.CurrentPage:OnForward()");
            end
            GUI.SendScriptCommand("BundleBriefingSystem.Global:PageFinished()");
        end
    end
end

---
-- Reagiert auch Klick auf den Back-Button während des Throneroom Mode.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:PrevButtonPressed()
    if not self.Data.DisplayIngameCutscene then
        if (self.Data.LastSkipButtonPressed + 500) < Logic.GetTimeMs() then
            self.Data.LastSkipButtonPressed = Logic.GetTimeMs();

            local LastPageID = table.remove(BundleBriefingSystem.Local.Data.CurrentBriefing.PageHistory);
            if not LastPageID then
                return;
            end
            local LastPage = BundleBriefingSystem.Local.Data.CurrentBriefing[LastPageID];
            if type(LastPage) == "number" then
                LastPageID = table.remove(BundleBriefingSystem.Local.Data.CurrentBriefing.PageHistory);
                LastPage = BundleBriefingSystem.Local.Data.CurrentBriefing[LastPageID];
            end
            if not LastPageID or LastPageID < 1 or not LastPage then
                return;
            end

            if self.Data.CurrentPage.OnReturn then
                GUI.SendScriptCommand("BundleBriefingSystem.Global.CurrentPage:OnReturn()");
            end
            BundleBriefingSystem.Local.Data.CurrentBriefing.Page = LastPageID -1;
            GUI.SendScriptCommand([[
                BundleBriefingSystem.Global.Data.CurrentBriefing.Page = ]] ..(LastPageID -1).. [[
                BundleBriefingSystem.Global:PageFinished()
            ]]);
        end
    end
end

---
-- Setzt den Stil der Briefing-Bars.
-- @param[type=number] _Opacity Opacity der Bars
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetBarStyle(_Opacity, _BigBars)
    local OpacityBig = (255 * _Opacity);
    local OpacitySmall = (255 * _Opacity);
    if _BigBars then
        OpacitySmall = 0;
    end
    
    local BigVisibility = (_BigBars and 1 or 0);
    local SmallVisibility = (_BigBars and 0 or 1);
    if _Opacity == 0 then
        BigVisibility = 0;
        SmallVisibility = 0;
    end

    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", SmallVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", SmallVisibility);

    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, OpacitySmall);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, OpacitySmall);
end

---
-- Setzt die Fader-Optionen der aktuellen Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetFader()
    -- Alpha der Fader-Maske
    g_Fade.To = self.Data.CurrentPage.FaderAlpha or 0;

    -- Fadein starten
    local PageFadeIn = self.Data.CurrentPage.FadeIn;
    if PageFadeIn then
        FadeIn(PageFadeIn);
    end

    -- Fadeout starten
    local PageFadeOut = self.Data.CurrentPage.FadeOut;
    if PageFadeOut then
        self.Data.CurrentBriefing.FaderJob = StartSimpleHiResJobEx(function(_Time, _FadeOut)
            if Logic.GetTimeMs() > _Time - (_FadeOut * 1000) then
                FadeOut(_FadeOut);
                return true;
            end
        end, Logic.GetTimeMs() + ((self.Data.CurrentPage.Duration or 0) * 1000), PageFadeOut);
    end
end

---
-- Aktiviert den Auswahldialog einer Multiple-Choice-Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetOptionsDialog()
    if self.Data.CurrentPage.MC then
        local Screen = {GUI.GetScreenSize()};
        local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";

        self.Data.OriginalBoxPosition = {
            XGUIEng.GetWidgetScreenPosition(Widget)
        };

        local Listbox = XGUIEng.GetWidgetID(Widget .. "/ListBox");
        XGUIEng.ListBoxPopAll(Listbox);
        self.Data.CurrentPage.MC.Map = {};
        for i=1, #self.Data.CurrentPage.MC, 1 do
            if self.Data.CurrentPage.MC[i].Invisible ~= true then
                XGUIEng.ListBoxPushItem(Listbox, self.Data.CurrentPage.MC[i][1]);
                table.insert(self.Data.CurrentPage.MC.Map, self.Data.CurrentPage.MC[i].ID);
            end
        end
        XGUIEng.ListBoxSetSelectedIndex(Listbox, 0);

        local wSize = {XGUIEng.GetWidgetScreenSize(Widget)};
        local xFactor = (Screen[1]/1920);
        local xFix = math.ceil((Screen[1] /2) - (wSize[1] /2));
        local yFix = math.ceil(Screen[2] - (wSize[2] -10));
        if self.Data.CurrentPage.Text and self.Data.CurrentPage.Text ~= "" then
            yFix = math.ceil((Screen[2] /2) - (wSize[2] /2));
        end
        XGUIEng.SetWidgetScreenPosition(Widget, xFix, yFix);
        XGUIEng.PushPage(Widget, false);
        XGUIEng.ShowWidget(Widget, 1);

        self.Data.MCSelectionIsShown = true;
    end
end

---
-- Setzt das Portrait der aktuellen Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetPortrait()
    if self.Data.CurrentPage.Portrait then
        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/LeftFrame/KnightBG", 1, 255);
        XGUIEng.SetMaterialTexture("/InGame/ThroneRoom/KnightInfo/LeftFrame/KnightBG", 1, self.Data.CurrentPage.Portrait);
        XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/LeftFrame/KnightBG", 0, 0, 400, 600);
        XGUIEng.SetMaterialUV("/InGame/ThroneRoom/KnightInfo/LeftFrame/KnightBG", 1, 0, 0, 1, 1);
    else
        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/LeftFrame/KnightBG", 1, 0);
    end
end

---
-- Setzt den Splashscreen der aktuellen Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetSplashscreen()
    local SSW = "/InGame/ThroneRoom/KnightInfo/BG";
    if self.Data.CurrentPage.Splashscreen then
        local size = {GUI.GetScreenSize()};
        local u0, v0, u1, v1 = 0, 0, 1, 1;
        -- Folgende Annahmen werden gemacht:
        -- * Alle Bildverhältnisse >= 1.6 sind 16:9
        -- * Alle Bildverhältnisse < 1.6 sind 4:3
        -- * 5:4 wird behandelt wie 4:3
        -- * 16:10 wird behandelt wie 4:3
        -- Spieler mit anderen Bildverhältnissen haben Pech!
        if size[1]/size[2] < 1.6 then
            u0 = 0.125;
            u1 = u1 - (u1 * 0.125);
        end
        local Image = self.Data.CurrentPage.Splashscreen;
        if type(Image) == "table" then
            Image = self.Data.CurrentPage.Splashscreen.Image;
        end
        XGUIEng.SetMaterialAlpha(SSW, 0, 255);
        XGUIEng.SetMaterialTexture(SSW, 0, Image);
        XGUIEng.SetMaterialUV(SSW, 0, u0, v0, u1, v1);
    else
        XGUIEng.SetMaterialAlpha(SSW, 0, 0);
    end
end

---
-- Wendet die Animation auf den Splashscreen der aktuellen Seite an.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ScrollSplashscreen()
    local SSW = "/InGame/ThroneRoom/KnightInfo/BG";
    if type(self.Data.CurrentPage.Splashscreen) == "table" then
        local SSData = self.Data.CurrentPage.Splashscreen;
        if (not SSData.Animation[1] or #SSData.Animation[1] ~= 4) or (not SSData.Animation[2] or #SSData.Animation[2] ~= 4) then
            return;
        end

        local size   = {GUI.GetScreenSize()};
        local factor = self:GetSplashscreenLERP();

        local u0 = SSData.Animation[1][1] + (SSData.Animation[2][1] - SSData.Animation[1][1]) * factor;
        local u1 = SSData.Animation[1][3] + (SSData.Animation[2][3] - SSData.Animation[1][3]) * factor;
        local v0 = SSData.Animation[1][2] + (SSData.Animation[2][2] - SSData.Animation[1][2]) * factor;
        local v1 = SSData.Animation[1][4] + (SSData.Animation[2][4] - SSData.Animation[1][4]) * factor;
        -- Folgende Annahmen werden gemacht:
        -- * Alle Bildverhältnisse >= 1.6 sind 16:9
        -- * Alle Bildverhältnisse < 1.6 sind 4:3
        -- * 5:4 wird behandelt wie 4:3
        -- * 16:10 wird behandelt wie 16:9
        -- Spieler mit anderen Bildverhältnissen haben Pech!
        if size[1]/size[2] < 1.6 then
            u0 = u0 + 0.125;
            u1 = u1 - (u1 * 0.125);
        end
        XGUIEng.SetMaterialUV(SSW, 0, u0, v0, u1, v1);
    end
end

---
-- Gibt die lineare Interpolation des Splashscreens zurück.
-- @param[type=number] LERP
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:GetSplashscreenLERP()
    local Factor = 1.0;
    if type(self.Data.CurrentPage.Splashscreen) == "table" then
        local Current = Logic.GetTime();
        local Started = self.Data.CurrentPage.Started;
        local FlyTime = self.Data.CurrentPage.Splashscreen.Animation[3];
        Factor = (Current - Started) / FlyTime;
        Factor = (Factor > 1 and 1) or Factor;
    end
    return Factor;
end

---
-- Aktiviert den Cinematic Mode.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ActivateCinematicMode()
    self.Data.CinematicActive = true;
    
    local LoadScreenVisible = API.IsLoadscreenVisible();
    if LoadScreenVisible then
        XGUIEng.PopPage();
    end
    local ScreenX, ScreenY = GUI.GetScreenSize();

    Core:InterfaceDeactivateNormalInterface();
    Core:InterfaceDeactivateBlackBackground();

    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo/LeftFrame", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);
	XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/updater", 1);

    -- Text
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    -- Title and back button
    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65 * (ScreenY/1080));
    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/Skip");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/StartButton", 20, y);
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Objectives", 2, 0, 2000, 20);

    -- Briefing messages
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/BG", 1);
    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", " ");
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Text", 200, 300, 1000, 10);

    -- Splashscreen
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/BG", 1);
    XGUIEng.SetMaterialColor("/InGame/ThroneRoom/KnightInfo/BG", 0, 255, 255, 255, 0);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/BG", 0, 0);
    
    -- Portrait
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame", 1);
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo/LeftFrame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame/KnightBG", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame/KnightBG", 1);
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/LeftFrame/KnightBG", 0, 0, 400, 600);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/LeftFrame/KnightBG", 0, 0);

    GUI.ClearSelection();
    GUI.ClearNotes();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    Display.SetRenderFogOfWar(0);
    Display.SetUserOptionOcclusionEffect(0);
    Camera.SwitchCameraBehaviour(5);

    InitializeFader();
    g_Fade.To = 0;
    SetFaderAlpha(0);

    if LoadScreenVisible then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
end

---
-- Deaktiviert den Cinematic Mode.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:DeactivateCinematicMode()
    self.Data.CinematicActive = false;

    g_Fade.To = 0;
    SetFaderAlpha(0);
    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    Display.SetRenderFogOfWar(1);
    if Options.GetIntValue("Display", "Occlusion", 0) > 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);

    Core:InterfaceActivateNormalInterface();
    Core:InterfaceDeactivateBlackBackground();
end

---
-- Überschreibt die Throneroom-Funktionen.
--
-- Überschriebene Funktionen:
-- <ul>
-- <li>ThroneRoomCameraControl - Steuerung der Throneroom-Kamera</li>
-- <li>ThroneRoomLeftClick - Es wird mit der Maus irgend wo hin geklickt</li>
-- <li>OnSkipButtonPressed - Überspringen wird geklickt</li>
-- </ul>
--
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:OverrideThroneRoomFunctions()
    ThroneRoomCameraControl = function()
        if BundleBriefingSystem then
            if BundleBriefingSystem.Local.Data.DisplayIngameCutscene then
                if AddOnCutsceneSystem then
                    AddOnCutsceneSystem.Local:ThroneRoomCameraControl();
                end
            else
                BundleBriefingSystem.Local:ThroneRoomCameraControl();
            end
        end
    end

    ThroneRoomLeftClick = function()
        if BundleBriefingSystem then
            if BundleBriefingSystem.Local.Data.DisplayIngameCutscene then
                if AddOnCutsceneSystem then
                    AddOnCutsceneSystem.Local:ThroneRoomLeftClick();
                end
            else
                BundleBriefingSystem.Local:ThroneRoomLeftClick();
            end
        end
    end

    OnSkipButtonPressed = function()
        if BundleBriefingSystem then
            if BundleBriefingSystem.Local.Data.DisplayIngameCutscene then
                if AddOnCutsceneSystem then
                    AddOnCutsceneSystem.Local:NextButtonPressed();
                end
            else
                BundleBriefingSystem.Local:NextButtonPressed();
            end
        end
    end

    OnStartButtonPressed = function()
        if BundleBriefingSystem then
            BundleBriefingSystem.Local:PrevButtonPressed();
        end
    end

    OnBackButtonPressed = function()
        if BundleBriefingSystem then
            BundleBriefingSystem.Local:PrevButtonPressed();
        end
    end

    BundleBriefingSystem.Local.GameCallback_Escape = GameCallback_Escape;
    GameCallback_Escape = function()
        if not BundleBriefingSystem.Local:IsBriefingActive() then
            BundleBriefingSystem.Local.GameCallback_Escape();
        end
    end
end

-- Shared ------------------------------------------------------------------- --

---
-- Errechnet eine Position relativ im angegebenen Winkel und Position zur
-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.
--
-- @param               _target          Basisposition (Skriptname, ID oder Position)
-- @param[type=number]  _distance        Entfernung
-- @param[type=number]  _angle           Winkel
-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang
-- @return[type=table] Position
-- @within Internal
-- @local
--
function BundleBriefingSystem:GetRelativePos(_target,_distance,_angle,_buildingRealPos)
    if not type(_target) == "table" and not IsExisting(_target)then
        return
    end
    if _angle == nil then
        _angle = 0;
    end

    local pos1;
    if type(_target) == "table" then
        local pos = _target;
        local ori = 0+_angle;
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};
    else
        local eID = GetID(_target);
        local pos = GetPosition(eID);
        local ori = Logic.GetEntityOrientation(eID)+_angle;
        if Logic.IsBuilding(eID) == 1 and not _buildingRealPos then
            x, y = Logic.GetBuildingApproachPosition(eID);
            pos = {X= x, Y= y};
            ori = ori -90;
        end
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};
    end
    return pos1;
end

-- Behavior ----------------------------------------------------------------- --

---
-- Ruft die Lua-Funktion mit dem angegebenen Namen auf und spielt das Briefing
-- in ihr ab. Die Funktion muss eine Briefing-ID zurückgeben.
--
-- Das Brieifng wird an den Quest gebunden und kann mit Trigger_Briefing
-- überwacht werden. Es kann pro Quest nur ein Niederlage-Briefing 
-- gebunden werden!
--
-- @param[type=string] _Briefing Funktionsname als String
-- @within Reprisal
--
function Reprisal_Briefing(...)
    return b_Reprisal_Briefing:new(...);
end

b_Reprisal_Briefing = {
    Name = "Reprisal_Briefing",
    Description = {
        en = "Reward: Calls a function that creates a briefing and saves the returned briefing ID into the quest.",
        de = "Lohn: Ruft eine Funktion auf, die ein Briefing erzeugt und die zurueckgegebene ID in der Quest speichert.",
    },
    Parameter = {
        { ParameterType.Default, en = "Briefing function", de = "Funktion mit Briefing" },
    },
}

function b_Reprisal_Briefing:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Function = _Parameter;
    end
end

function b_Reprisal_Briefing:CustomFunction(_Quest)
    info(_Quest.Identifier..": "..self.Name..": Try starting briefing '" ..self.Function.. "'");
    local BriefingID = _G[self.Function](self, _Quest);
    if BriefingID < 1 then
        error(_Quest.Identifier..": "..self.Name..": Briefing '" ..self.Function.. "' was not started!");
        return;
    end
    local QuestID = GetQuestID(_Quest.Identifier);
    if QuestID == nil then
        warn("Briefing '" ..self.Function.. "' wasn't attached to a quest!");
    end
    Quests[QuestID].zl97d_ukfs5_0dpm0 = BriefingID;
    info(_Quest.Identifier..": "..self.Name..": Briefing '" ..self.Function.. "' started");
end

function b_Reprisal_Briefing:Debug(_Quest)
    if not type(_G[self.Function]) == "function" then
        error(_Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!", LEVEL_ERROR);
        return true;
    end
    return false;
end

function b_Reprisal_Briefing:Reset(_Quest)
    local QuestID = GetQuestID(_Quest.Identifier);
    Quests[QuestID].zl97d_ukfs5_0dpm0 = nil;
end

Core:RegisterBehavior(b_Reprisal_Briefing);

-- -------------------------------------------------------------------------- --

---
-- Ruft die Lua-Funktion mit dem angegebenen Namen auf und spielt das Briefing
-- in ihr ab. Die Funktion muss eine Briefing-ID zurückgeben.
--
-- Das Brieifng wird an den Quest gebunden und kann mit Trigger_Briefing
-- überwacht werden. Es kann pro Quest nur ein Erfolgs-Briefing gebunden werden!
--
-- @param[type=string] _Briefing Funktionsname als String
-- @within Reward
--
function Reward_Briefing(...)
    return b_Reward_Briefing:new(...);
end

b_Reward_Briefing = API.InstanceTable(b_Reprisal_Briefing);
b_Reward_Briefing.Name = "Reward_Briefing";
b_Reward_Briefing.Description.en = "Reward: Calls a function that creates a briefing and saves the returned briefing ID into the quest.";
b_Reward_Briefing.Description.de = "Lohn: Ruft eine Funktion auf, die ein Briefing erzeugt und die zurueckgegebene ID in der Quest speichert.";
b_Reward_Briefing.GetReprisalTable = nil;

b_Reward_Briefing.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

b_Reward_Briefing.CustomFunction = function(self, _Quest)
    local BriefingID = _G[self.Function](self, _Quest);
    local QuestID = GetQuestID(_Quest.Identifier);
    Quests[QuestID].w5kur_xig0q_d9k7e = BriefingID;
end

b_Reward_Briefing.Reset = function(self, _Quest)
    local QuestID = GetQuestID(_Quest.Identifier);
    Quests[QuestID].w5kur_xig0q_d9k7e = nil;
end

Core:RegisterBehavior(b_Reward_Briefing);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest, nachdem das Briefing eines Quests gestartet und
-- durchlaufen wurde.
--
-- Der Trigger wird sowohl Erfolgs- als auch Niederlage-Briefings prüfen.
-- Über den Typ-Parameter kann auf eine spezielle Art eingeschränt werden.
-- Mit diesem Trigger ist es u.a. möglich zu verzweigen, wenn man z.B. nach
-- einem Misserfolg eine Niederlage im nächsten Quest auslösen will und bei
-- Erfolg stattdessen die Mission gewonnen werden soll.
--
-- Mögliche Angaben für Briefing-Typen:
-- <ul>
-- <li><b>"All"</b>: Erfolg und Niederlage</li>
-- <li><b>"Failure"</b>: Nur Niederlage</li>
-- <li><b>"Success"</b>: Nur Erfolg</li>
-- </ul>
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string] _Type     (Optional) Briefing-Typ
-- @param[type=number] _Waittime (optional) Wartezeit in Sekunden
-- @within Trigger
--
function Trigger_Briefing(...)
    return b_Trigger_Briefing:new(...);
end

b_Trigger_Briefing = {
    Name = "Trigger_Briefing",
    Description = {
        en = "Trigger: After a briefing of the given quest has finished, this quest will be started. Additionally you can choose the type of briefing this trigger shall react to.",
        de = "Ausloeser: Wenn ein Briefing des angegebenen Quest beendet ist, wird dieser Quest gestartet. Optional kann gewählt werden, auf welchen Typ von Briefing reagiert werden soll.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name",    de = "Questname" },
        { ParameterType.Custom,    en = "Briefing type", de = "Briefing-Typ" },
        { ParameterType.Number,    en = "Wait time",     de = "Wartezeit" },
    },
}

function b_Trigger_Briefing:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Quest = _Parameter;
    elseif (_Index == 1) then
        _Paramater = _Parameter or "All";
        self.BriefingType = _Parameter;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function b_Trigger_Briefing:GetCustomData( _Index )
    if _Index == 1 then
        return {"All", "Success", "Failure"};
    end
end

function b_Trigger_Briefing:IsConditionFulfilled(_QuestID)
    if self.BriefingType == nil or self.BriefingType == "All" then
        return IsBriefingFinished(Quests[_QuestID].zl97d_ukfs5_0dpm0) or IsBriefingFinished(Quests[_QuestID].w5kur_xig0q_d9k7e);
    elseif self.BriefingType == "Failure" then
        return IsBriefingFinished(Quests[_QuestID].zl97d_ukfs5_0dpm0);
    elseif self.BriefingType == "Success" then
        return IsBriefingFinished(Quests[_QuestID].w5kur_xig0q_d9k7e);
    end
    return false;
end

function b_Trigger_Briefing:CustomFunction(_Quest)
    local QuestID = GetQuestID(self.Quest);
    if self:IsConditionFulfilled(QuestID) then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function b_Trigger_Briefing:Interrupt(_Quest)
    local QuestID = GetQuestID(self.Quest);
    Quests[QuestID].w5kur_xig0q_d9k7e = nil;
    Quests[QuestID].zl97d_ukfs5_0dpm0 = nil;
    self.WaitTimeTimer = nil
end

function b_Trigger_Briefing:Reset(_Quest)
    self:Interrupt(_Quest);
end

function b_Trigger_Briefing:Debug(_Quest)
    if self.WaitTime and self.WaitTime < 0 then
        error(_Quest.Identifier.." "..self.Name..": waittime is below 0!", LEVEL_ERROR);
        return true;
    elseif not IsValidQuest(self.Quest) then
        error(_Quest.Identifier.." "..self.Name..": '"..self.Quest.."' is not a valid quest!", LEVEL_ERROR);
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_Briefing);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest, nachdem das Mission Briefing beendet ist
--
-- @within Trigger
-- @see StartMissionBriefing
--
function Trigger_MissionBriefing(...)
    return b_Trigger_MissionBriefing:new(...);
end

b_Trigger_MissionBriefing = {
    Name = "Trigger_MissionBriefing",
    Description = {
        en = "Trigger: After the briefing started with StartMissionBriefing finishes, this trigger will start the quest.",
        de = "Ausloeser: Wenn das Briefing, gestartet mit StartMissionBriefing, beendet ist, wird der Quest gestartet.",
    },
}

function b_Trigger_MissionBriefing:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_MissionBriefing:CustomFunction(_Quest)
    if BundleBriefingSystem.Global.Data.MissionStartBriefingID > 0 then
        if IsBriefingFinished(BundleBriefingSystem.Global.Data.MissionStartBriefingID) then
            return true;
        end
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_MissionBriefing);

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleBriefingSystem");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleClassicBehaviors                                       # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle enthält alle Behavior, die aus der QSB 3.9 PlusB bekannt sind.
--
-- Die Behavior sind weitesgehend unverändert und es dürfte keine Probleme mit
-- Inkompatibelität geben, wenn die QSB ausgetauscht wird.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleClassicBehaviors = {};

API = API or {};
QSB = QSB or {};

QSB.EffectNameToID    = QSB.EffectNameToID or {};
QSB.InitalizedObjekts = QSB.InitalizedObjekts or {};
QSB.DestroyedSoldiers = QSB.DestroyedSoldiers or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog als Text zurück.
--
-- <b>Hinweis</b>: Es wird nur die letzte Eingabe zurückgegeben.
--
-- @param[type=string] _QuestName Name des Quest
-- @return[type=string] Eingabe des Spielers
-- @within Anwenderfunktionen
--
function API.GetInputStringFromQuest(_QuestName)
    if GUI then
        return;
    end
    local Quest = Quests[GetQuestID(_QuestName)];
    if not Quest then
        error("API.GetInputStringFromQuest: Quest '" ..tostring(_QuestName).. "' not found!");
        return;
    end
    return BundleClassicBehaviors.Global:GetInputFromQuest(_QuestName);
end

---
-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog Als Zahl zurück.
--
-- <b>Hinweis</b>: Es wird nur die letzte Eingabe zurückgegeben.
--
-- @param[type=string] _QuestName Name des Quest
-- @return[type=number] Eingabe des Spielers
-- @within Anwenderfunktionen
--
function API.GetInputNumberFromQuest(_QuestName)
    if GUI then
        return 0;
    end
    local Quest = Quests[GetQuestID(_QuestName)];
    if not Quest then
        error("API.GetInputNumberFromQuest: Quest '" ..tostring(_QuestName).. "' not found!");
        return 0;
    end
    return tonumber(API.GetInputStringFromQuest(_QuestName));
end

-- -------------------------------------------------------------------------- --
-- Goals                                                                      --
-- -------------------------------------------------------------------------- --

---
-- Ein Interaktives Objekt muss benutzt werden.
--
-- @param _ScriptName Skriptname des interaktiven Objektes
--
-- @within Goal
--
function Goal_ActivateObject(...)
    return b_Goal_ActivateObject:new(...);
end

b_Goal_ActivateObject = {
    Name = "Goal_ActivateObject",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Object name", de = "Skriptname" },
    },
}

function b_Goal_ActivateObject:GetGoalTable()
    return {Objective.Object, { self.ScriptName } }
end

function b_Goal_ActivateObject:AddParameter(_Index, _Parameter)
   if _Index == 0 then
        self.ScriptName = _Parameter
   end
end

function b_Goal_ActivateObject:GetMsgKey()
    return "Quest_Object_Activate"
end

Core:RegisterBehavior(b_Goal_ActivateObject);

-- -------------------------------------------------------------------------- --

---
-- Einem Spieler müssen Rohstoffe oder Waren gesendet werden.
--
-- In der Regel wird zum Auftraggeber gesendet. Es ist aber möglich auch zu
-- einem anderen Zielspieler schicken zu lassen. Wird ein Wagen gefangen
-- genommen, dann muss erneut geschickt werden. Optional kann dem Spieler
-- auch erlaubt werden, den Karren zurückzuerobern.
--
-- @param _GoodType      Typ der Ware
-- @param _GoodAmount    Menga der Ware
-- @param _OtherTarget   Anderes Ziel als Auftraggeber
-- @param _IgnoreCapture Wagen kann zurückerobert werden
--
-- @within Goal
--
function Goal_Deliver(...)
    return b_Goal_Deliver:new(...);
end

b_Goal_Deliver = {
    Name = "Goal_Deliver",
    Description = {
        en = "Goal: Deliver goods to quest giver or to another player.",
        de = "Ziel: Liefere Waren zum Auftraggeber oder zu einem anderen Spieler.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Ressourcentyp" },
        { ParameterType.Number, en = "Amount of good", de = "Ressourcenmenge" },
        { ParameterType.Custom, en = "To different player", de = "Anderer Empfänger" },
        { ParameterType.Custom, en = "Ignore capture", de = "Abfangen ignorieren" },
    },
};

function b_Goal_Deliver:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName);
    local Category = Logic.GetGoodCategoryForGoodType(GoodType);
    if Category == GoodCategories.GC_Resource then
        for i = 1, 8 do
            local SHID = Logic.GetStoreHouse(i);
            if SHID ~= 0 and Logic.GetIndexOnInStockByGoodType(SHID, GoodType) == -1 then
                Logic.AddGoodToStock(SHID, GoodType, 0, true, true);
            end
        end
    end    
    return {Objective.Deliver, GoodType, self.GoodAmount, self.OverrideTarget, self.IgnoreCapture};
end

function b_Goal_Deliver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter;
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1;
    elseif (_Index == 2) then
        self.OverrideTarget = tonumber(_Parameter);
    elseif (_Index == 3) then
        self.IgnoreCapture = AcceptAlternativeBoolean(_Parameter);
    end
end

function b_Goal_Deliver:GetCustomData(_Index)
    local Data = {};
    if _Index == 0 then
        for k, v in pairs(Goods) do
            if string.find(k, "^G_") then
                table.insert(Data, k);
            end
        end
        table.sort(Data);
    elseif _Index == 2 then
        table.insert(Data, "-");
        for i = 1, 8 do
            table.insert( Data, i );
        end
    elseif _Index == 3 then
        table.insert(Data, "true");
        table.insert(Data, "false");
    else
        assert(false);
    end
    return Data;
end

function b_Goal_Deliver:GetMsgKey()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName);
    local GC = Logic.GetGoodCategoryForGoodType(GoodType);

    local tMapping = {
        [GoodCategories.GC_Clothes] = "Quest_Deliver_GC_Clothes",
        [GoodCategories.GC_Entertainment] = "Quest_Deliver_GC_Entertainment",
        [GoodCategories.GC_Food] = "Quest_Deliver_GC_Food",
        [GoodCategories.GC_Gold] = "Quest_Deliver_GC_Gold",
        [GoodCategories.GC_Hygiene] = "Quest_Deliver_GC_Hygiene",
        [GoodCategories.GC_Medicine] = "Quest_Deliver_GC_Medicine",
        [GoodCategories.GC_Water] = "Quest_Deliver_GC_Water",
        [GoodCategories.GC_Weapon] = "Quest_Deliver_GC_Weapon",
        [GoodCategories.GC_Resource] = "Quest_Deliver_Resources",
    };

    if GC then
        local Key = tMapping[GC];
        if Key then
            return Key;
        end
    end
    return "Quest_Deliver_Goods";
end

Core:RegisterBehavior(b_Goal_Deliver);

-- -------------------------------------------------------------------------- --

---
-- Es muss ein bestimmter Diplomatiestatus zu einer anderen Patei erreicht
-- werden. Der Status kann eine Verbesserung oder eine Verschlechterung zum
-- aktuellen Status sein.
--
-- Die Relation kann entweder auf kleiner (<), kleiner oder gleich (<=), genau
-- gleich (==), größer oder gleich (>=), größer (>) oder ungleich (~=) 
-- eingestellt werden. Bei Prüfung auf genaue Gleicheit musst du darauf achten,
-- das dieser Zustand erreicht werden kann bzw. nicht schon überschritten oder
-- unterboten wurde.
--
-- @param _PlayerID Partei, die Entdeckt werden muss
-- @param _Relation Größer-Kleiner-Relation
-- @param _State    Diplomatiestatus
--
-- @within Goal
--
function Goal_Diplomacy(...)
    return b_Goal_Diplomacy:new(...);
end

b_Goal_Diplomacy = {
    Name = "Goal_Diplomacy",
    Description = {
        en = "Goal: A diplomatic state must b reached. Can be lower than current state or higher.",
        de = "Ziel: Die Beziehungen zu einem Spieler müssen entweder verbessert oder verschlechtert werden.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Party", de = "Partei" },
        { ParameterType.Custom,   en = "Relation", de = "Relation" },
        { ParameterType.Custom,   en = "Diplomacy state", de = "Diplomatische Beziehung" },
    },
}

function b_Goal_Diplomacy:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_Diplomacy:CustomFunction(_Quest)
    if self.Relation == "<" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) < self.DiplState then
            return true;
        end
    elseif self.Relation == "<=" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) <= self.DiplState then
            return true;
        end
    elseif self.Relation == "==" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) == self.DiplState then
            return true;
        end
    elseif self.Relation == ">=" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) >= self.DiplState then
            return true;
        end
    elseif self.Relation == ">" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) > self.DiplState then
            return true;
        end
    else
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) ~= self.DiplState then
            return true;
        end
    end
end

function b_Goal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Relation = _Parameter;
    elseif (_Index == 2) then
        self.DiplState = DiplomacyStates[_Parameter];
    end
end

function b_Goal_Diplomacy:GetIcon()
    return {6, 3};
end

function b_Goal_Diplomacy:GetCustomData(_Index)
    if _Index == 1 then
        return {">", ">=", "==", "<=", "<", "~="};
    elseif _Index == 2 then
        return {"Allied", "TradeContact", "EstablishedContact", "Undecided", "Enemy"};
    end
end

Core:RegisterBehavior(b_Goal_Diplomacy);

-- -------------------------------------------------------------------------- --

---
-- Das Heimatterritorium des Spielers muss entdeckt werden.
--
-- Das Heimatterritorium ist immer das, wo sich Burg oder Lagerhaus der
-- zu entdeckenden Partei befinden.
--
-- @param _PlayerID ID der zu entdeckenden Partei
--
-- @within Goal
--
function Goal_DiscoverPlayer(...)
    return b_Goal_DiscoverPlayer:new(...);
end

b_Goal_DiscoverPlayer = {
    Name = "Goal_DiscoverPlayer",
    Description = {
        en = "Goal: Discover the home territory of another player.",
        de = "Ziel: Entdecke das Heimatterritorium eines Spielers.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_DiscoverPlayer:GetGoalTable()
    return {Objective.Discover, 2, { self.PlayerID } }
end

function b_Goal_DiscoverPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_DiscoverPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_Discover",
        [PlayerCategories.City] = "Quest_Discover_City",
        [PlayerCategories.Cloister] = "Quest_Discover_Cloister",
        [PlayerCategories.Harbour] = "Quest_Discover",
        [PlayerCategories.Village] = "Quest_Discover_Village",
    }
    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_Discover"
end

Core:RegisterBehavior(b_Goal_DiscoverPlayer);

-- -------------------------------------------------------------------------- --

---
-- Ein Territorium muss erstmalig vom Auftragnehmer betreten werden.
--
-- Wenn ein Spieler zuvor mit seinen Einheiten auf dem Territorium war, ist
-- es bereits entdeckt und das Ziel sofort erfüllt.
--
-- @param _Territory Name oder ID des Territorium
--
-- @within Goal
--
function Goal_DiscoverTerritory(...)
    return b_Goal_DiscoverTerritory:new(...);
end

b_Goal_DiscoverTerritory = {
    Name = "Goal_DiscoverTerritory",
    Description = {
        en = "Goal: Discover a territory",
        de = "Ziel: Entdecke ein Territorium",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },
    },
}

function b_Goal_DiscoverTerritory:GetGoalTable()
    return { Objective.Discover, 1, { self.TerritoryID  } }
end

function b_Goal_DiscoverTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
        assert( self.TerritoryID > 0 )
    end
end

function b_Goal_DiscoverTerritory:GetMsgKey()
    return "Quest_Discover_Territory"
end

Core:RegisterBehavior(b_Goal_DiscoverTerritory);

-- -------------------------------------------------------------------------- --

---
-- Eine andere Partei muss besiegt werden.
--
-- Die Partei gilt als besiegt, wenn ein Hauptgebäude (Burg, Kirche, Lager)
-- zerstört wurde.
-- 
-- <b>Achtung:</b> Bei Banditen ist dieses Behavior wenig sinnvoll, da sie
-- nicht durch zerstörung ihres Hauptzeltes vernichtet werden. Hier bietet
-- sich Goal_DestroyAllPlayerUnits an.
--
-- @param _PlayerID ID des Spielers
--
-- @within Goal
--
function Goal_DestroyPlayer(...)
    return b_Goal_DestroyPlayer:new(...);
end

b_Goal_DestroyPlayer = {
    Name = "Goal_DestroyPlayer",
    Description = {
        en = "Goal: Destroy a player (destroy a main building)",
        de = "Ziel: Zerstöre einen Spieler (ein Hauptgebäude muss zerstört werden).",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_DestroyPlayer:GetGoalTable()
    assert( self.PlayerID <= 8 and self.PlayerID >= 1, "Error in " .. self.Name .. ": GetGoalTable: PlayerID is invalid")
    return { Objective.DestroyPlayers, self.PlayerID }
end

function b_Goal_DestroyPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_DestroyPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities_Building"
end

Core:RegisterBehavior(b_Goal_DestroyPlayer)

-- -------------------------------------------------------------------------- --

---
-- Es sollen Informationen aus der Burg gestohlen werden.
--
-- Der Spieler muss einen Dieb entsenden um Informationen aus der Burg zu
-- stehlen. 
--
-- <b>Achtung:</b> Das ist nur bei Feinden möglich!
--
-- @param _PlayerID ID der Partei
--
-- @within Goal
--
function Goal_StealInformation(...)
    return b_Goal_StealInformation:new(...);
end

b_Goal_StealInformation = {
    Name = "Goal_StealInformation",
    Description = {
        en = "Goal: Steal information from another players castle",
        de = "Ziel: Stehle Informationen aus der Burg eines Spielers",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_StealInformation:GetGoalTable()

    local Target = Logic.GetHeadquarters(self.PlayerID)
    if not Target or Target == 0 then
        Target = Logic.GetStoreHouse(self.PlayerID)
    end
    assert( Target and Target ~= 0 )
    return {Objective.Steal, 1, { Target } }

end

function b_Goal_StealInformation:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end

end

function b_Goal_StealInformation:GetMsgKey()
    return "Quest_Steal_Info"

end

Core:RegisterBehavior(b_Goal_StealInformation);

-- -------------------------------------------------------------------------- --

---
-- Alle Einheiten des Spielers müssen zerstört werden.
--
-- <b>Achtung</b>: Bei normalen Parteien, welche ein Dorf oder eine Stadt
-- besitzen, ist Goal_DestroyPlayer besser geeignet!
--
-- @param _PlayerID ID des Spielers
--
-- @within Goal
--
function Goal_DestroyAllPlayerUnits(...)
    return b_Goal_DestroyAllPlayerUnits:new(...);
end

b_Goal_DestroyAllPlayerUnits = {
    Name = "Goal_DestroyAllPlayerUnits",
    Description = {
        en = "Goal: Destroy all units owned by player (be careful with script entities)",
        de = "Ziel: Zerstöre alle Einheiten eines Spielers (vorsicht mit Script-Entities)",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_DestroyAllPlayerUnits:GetGoalTable()
    return { Objective.DestroyAllPlayerUnits, self.PlayerID }
end

function b_Goal_DestroyAllPlayerUnits:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_DestroyAllPlayerUnits:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities"
end

Core:RegisterBehavior(b_Goal_DestroyAllPlayerUnits);

-- -------------------------------------------------------------------------- --

---
-- Ein benanntes Entity muss zerstört werden.
--
-- Ein Entity gilt als zerstört, wenn es nicht mehr existiert oder während
-- der Laufzeit des Quests seine Entity-ID oder den Besitzer verändert.
--
-- <b>Achtung</b>: Helden können nicht direkt zerstört werden. Bei ihnen
-- genügt es, wenn sie sich "in die Burg zurückziehen".
--
-- @param _ScriptName Skriptname des Ziels
--
-- @within Goal
--
function Goal_DestroyScriptEntity(...)
    return b_Goal_DestroyScriptEntity:new(...);
end

b_Goal_DestroyScriptEntity = {
    Name = "Goal_DestroyScriptEntity",
    Description = {
        en = "Goal: Destroy an entity",
        de = "Ziel: Zerstöre eine Entität",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Goal_DestroyScriptEntity:GetGoalTable()
    return {Objective.DestroyEntities, 1, { self.ScriptName } }
end

function b_Goal_DestroyScriptEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Goal_DestroyScriptEntity:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_DestroyEntities_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
                    return "Quest_DestroyEntities_Predators"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Destroy_Leader"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

                    return "Quest_DestroyEntities_Unit"
                end
            end
        end
    end
    return "Quest_DestroyEntities"
end

Core:RegisterBehavior(b_Goal_DestroyScriptEntity);

-- -------------------------------------------------------------------------- --

---
-- Eine Menge an Entities eines Typs müssen zerstört werden.
--
-- <b>Achtung</b>: Wenn Raubtiere zerstört werden sollen, muss Spieler 0
-- als Besitzer angegeben werden.
--
-- @param _EntityType Typ des Entity
-- @param _Amount     Menge an Entities des Typs
-- @param _PlayerID   Besitzer des Entity
--
-- @within Goal
--
function Goal_DestroyType(...)
    return b_Goal_DestroyType:new(...);
end

b_Goal_DestroyType = {
    Name = "Goal_DestroyType",
    Description = {
        en = "Goal: Destroy entity types",
        de = "Ziel: Zerstöre Entitätstypen",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.Custom, en = "Player", de = "Spieler" },
    },
}

function b_Goal_DestroyType:GetGoalTable()
    return {Objective.DestroyEntities, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function b_Goal_DestroyType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
        self.DestroyTypeAmount = self.Amount
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_DestroyType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^[ABU]_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function b_Goal_DestroyType:GetMsgKey()
    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
        return "Quest_DestroyEntities_Building"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
        return "Quest_DestroyEntities_Predators"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
        return "Quest_Destroy_Leader"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

        return "Quest_DestroyEntities_Unit"
    end
    return "Quest_DestroyEntities"
end

Core:RegisterBehavior(b_Goal_DestroyType);

-- -------------------------------------------------------------------------- --

do
    GameCallback_EntityKilled_Orig_QSB_Goal_DestroySoldiers = GameCallback_EntityKilled;
    GameCallback_EntityKilled = function(_AttackedEntityID, _AttackedPlayerID, _AttackingEntityID, _AttackingPlayerID, _AttackedEntityType, _AttackingEntityType)
        if _AttackedPlayerID ~= 0 and _AttackingPlayerID ~= 0 then
            QSB.DestroyedSoldiers[_AttackingPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID] or {}
            QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] or 0
            if Logic.IsEntityTypeInCategory( _AttackedEntityType, EntityCategories.Military ) == 1
            and Logic.IsEntityInCategory( _AttackedEntityID, EntityCategories.HeavyWeapon) == 0 then
                QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] +1
            end
        end
        GameCallback_EntityKilled_Orig_QSB_Goal_DestroySoldiers(_AttackedEntityID, _AttackedPlayerID, _AttackingEntityID, _AttackingPlayerID, _AttackedEntityType, _AttackingEntityType)
    end
end

---
-- Ein beliebiger Spieler muss Soldaten eines anderen Spielers zerstören.
--
-- Dieses Behavior kann auch in versteckten Quests bentutzt werden, wenn die
-- Menge an zerstörten Soldaten durch einen Feind des Spielers gefragt ist.
--
-- @param _PlayerA Angreifende Partei
-- @param _PlayerB Zielpartei
-- @param _Amount Menga an Soldaten
--
-- @within Goal
--
function Goal_DestroySoldiers(...)
    return b_Goal_DestroySoldiers:new(...);
end

b_Goal_DestroySoldiers = {
    Name = "Goal_DestroySoldiers",
    Description = {
        en = "Goal: Destroy a given amount of enemy soldiers",
        de = "Ziel: Zerstöre eine Anzahl gegnerischer Soldaten",
                },
    Parameter = {
        {ParameterType.PlayerID, en = "Attacking Player", de = "Angreifer", },
        {ParameterType.PlayerID, en = "Defending Player", de = "Verteidiger", },
        {ParameterType.Number, en = "Amount", de = "Anzahl", },
    },
}

function b_Goal_DestroySoldiers:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_DestroySoldiers:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AttackingPlayer = _Parameter * 1
    elseif (_Index == 1) then
        self.AttackedPlayer = _Parameter * 1
    elseif (_Index == 2) then
        self.KillsNeeded = _Parameter * 1
    end
end

function b_Goal_DestroySoldiers:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local PlayerName = GetPlayerName(self.AttackedPlayer) or "";
        Core:ChangeCustomQuestCaptionText(
            string.format(
                API.Localize(BundleClassicBehaviors.Text.DestroySoldiers),
                PlayerName, self.KillsNeeded
            ),
            _Quest
        );
    end

    local currentKills = 0;
    if QSB.DestroyedSoldiers[self.AttackingPlayer] and QSB.DestroyedSoldiers[self.AttackingPlayer][self.AttackedPlayer] then
        currentKills = QSB.DestroyedSoldiers[self.AttackingPlayer][self.AttackedPlayer]
    end
    self.SaveAmount = self.SaveAmount or currentKills
    return self.KillsNeeded <= currentKills - self.SaveAmount or nil
end

function b_Goal_DestroySoldiers:Debug(_Quest)
    if Logic.GetStoreHouse(self.AttackingPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AttackinPlayer .. " is dead :-(")
        return true
    elseif Logic.GetStoreHouse(self.AttackedPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AttackedPlayer .. " is dead :-(")
        return true
    elseif self.KillsNeeded < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount negative")
        return true
    end
end

function b_Goal_DestroySoldiers:GetIcon()
    return {7,12}
end

function b_Goal_DestroySoldiers:Reset()
    self.SaveAmount = nil
end

Core:RegisterBehavior(b_Goal_DestroySoldiers)

---
-- Eine Entfernung zwischen zwei Entities muss erreicht werden.
--
-- Je nach angegebener Relation muss die Entfernung unter- oder überschritten
-- werden, um den Quest zu gewinnen.
--
-- @param _ScriptName1  Erstes Entity
-- @param _ScriptName2  Zweites Entity
-- @param _Relation     Relation
-- @param _Distance     Entfernung
--
-- @within Goal
--
function Goal_EntityDistance(...)
    return b_Goal_EntityDistance:new(...);
end

b_Goal_EntityDistance = {
    Name = "Goal_EntityDistance",
    Description = {
        en = "Goal: Distance between two entities",
        de = "Ziel: Zwei Entities sollen zueinander eine Entfernung über- oder unterschreiten.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
        { ParameterType.Number, en = "Distance", de = "Entfernung" },
    },
}

function b_Goal_EntityDistance:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_EntityDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "<"
    elseif (_Index == 3) then
        self.Distance = _Parameter * 1
    end
end

function b_Goal_EntityDistance:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.Entity1 ) or Logic.IsEntityDestroyed( self.Entity2 ) then
        return false
    end
    local ID1 = GetID( self.Entity1 )
    local ID2 = GetID( self.Entity2 )
    local InRange = Logic.CheckEntitiesDistance( ID1, ID2, math.abs(self.Distance) )
    if ( self.bRelSmallerThan and InRange ) or ( not self.bRelSmallerThan and not InRange ) then
        return true
    end
end

function b_Goal_EntityDistance:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        table.insert( Data, ">" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function b_Goal_EntityDistance:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        error(_Quest.Identifier.. ": " ..self.Name..": At least 1 of the entities for distance check don't exist!");
        return true;
    end
    if not self.Distance or self.Distance == 0 then
        error(_Quest.Identifier.. ": " ..self.Name..": Distance must be above 0!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_EntityDistance);

-- -------------------------------------------------------------------------- --

---
-- Der Primary Knight des angegebenen Spielers muss sich dem Ziel nähern.
--
-- Die Distanz, die unterschritten werden muss, kann frei bestimmt werden.
-- Wird die Distanz 0 belassen, wird sie automatisch 2500.
--
-- @param _ScriptName Skriptname des Ziels
-- @param _Disctande  (optional) Entfernung zum Ziel
--
-- @within Goal
--
function Goal_KnightDistance(...)
    return b_Goal_KnightDistance:new(...);
end

b_Goal_KnightDistance = {
    Name = "Goal_KnightDistance",
    Description = {
        en = "Goal: Bring the knight close to a given entity. If the distance is left at 0 it will automatically set to 2500.",
        de = "Ziel: Bringe den Ritter nah an eine bestimmte Entität. Wird die Entfernung 0 gelassen, ist sie automatisch 2500.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target", de = "Ziel" },
        { ParameterType.Number, en = "Distance", de = "Entfernung" },
    },
}

function b_Goal_KnightDistance:GetGoalTable()
    return {Objective.Distance, -65566, self.Target, self.Distance, true}
end

function b_Goal_KnightDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Target = _Parameter;
    elseif (_Index == 1) then
        if _Parameter == nil or _Parameter == "" then
            _Parameter = 0;
        end
        self.Distance = _Parameter * 1;
        if self.Distance == 0 then
            self.Distance = 2500;
        end
    end
end

Core:RegisterBehavior(b_Goal_KnightDistance);

---
-- Eine bestimmte Anzahl an Einheiten einer Kategorie muss sich auf dem
-- Territorium befinden.
--
-- Es kann entweder gefordert werden, weniger als die angegebene Menge auf
-- dem Territorium zu haben (z.B. "<"" 1 für 0) oder mindestens so
-- viele Entities (z.B. ">=" 5 für mindestens 5).
--
-- @param _Territory  TerritoryID oder TerritoryName
-- @param _PlayerID   PlayerID der Einheiten
-- @param _Category   Kategorie der Einheiten
-- @param _Relation   Mengenrelation (< oder >=)
-- @param _Amount     Menge an Einheiten
--
-- @within Goal
--
function Goal_UnitsOnTerritory(...)
    return b_Goal_UnitsOnTerritory:new(...);
end

b_Goal_UnitsOnTerritory = {
    Name = "Goal_UnitsOnTerritory",
    Description = {
        en = "Goal: Place a certain amount of units on a territory",
        de = "Ziel: Platziere eine bestimmte Anzahl Einheiten auf einem Gebiet",
    },
    Parameter = {
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium" },
        { ParameterType.Custom,  en = "Player", de = "Spieler" },
        { ParameterType.Custom,  en = "Category", de = "Kategorie" },
        { ParameterType.Custom,  en = "Relation", de = "Relation" },
        { ParameterType.Number,  en = "Number of units", de = "Anzahl Einheiten" },
    },
}

function b_Goal_UnitsOnTerritory:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_UnitsOnTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if self.TerritoryID == nil then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 1) then
        self.PlayerID = tonumber(_Parameter) * 1
    elseif (_Index == 2) then
        self.Category = _Parameter
    elseif (_Index == 3) then
        self.bRelSmallerThan = (tostring(_Parameter) == "true" or tostring(_Parameter) == "<")
    elseif (_Index == 4) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function b_Goal_UnitsOnTerritory:CustomFunction(_Quest)
    local Units = GetEntitiesOfCategoryInTerritory(self.PlayerID, EntityCategories[self.Category], self.TerritoryID);
    if self.bRelSmallerThan == false and #Units >= self.NumberOfUnits then
        return true;
    elseif self.bRelSmallerThan == true and #Units < self.NumberOfUnits then
        return true;
    end
end

function b_Goal_UnitsOnTerritory:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, -1 )
        for i = 1, 8 do
            table.insert( Data, i )
        end
    elseif _Index == 2 then
        for k, v in pairs( EntityCategories ) do
            if not string.find( k, "^G_" ) and k ~= "SheepPasture" then
                table.insert( Data, k )
            end
        end
        table.sort( Data );
    elseif _Index == 3 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function b_Goal_UnitsOnTerritory:Debug(_Quest)
    local territories = {Logic.GetTerritories()}
    if tonumber(self.TerritoryID) == nil or self.TerritoryID < 0 or not Inside(self.TerritoryID,territories) then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid territoryID!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    elseif not EntityCategories[self.Category] then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid entity category!");
        return true;
    elseif tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then
        error(_Quest.Identifier.. ": " ..self.Name..": amount is negative or nil!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_UnitsOnTerritory);

-- -------------------------------------------------------------------------- --

---
-- Der angegebene Spieler muss einen Buff aktivieren.
--
-- <u>Buffs "Aufstieg eines Königreich"</u>
-- <li>Buff_Spice: Salz</li>
-- <li>Buff_Colour: Farben</li>
-- <li>Buff_Entertainers: Entertainer anheuern</li>
-- <li>Buff_FoodDiversity: Vielfältige Nahrung</li>
-- <li>Buff_ClothesDiversity: Vielfältige Kleidung</li>
-- <li>Buff_HygieneDiversity: Vielfältige Hygiene</li>
-- <li>Buff_EntertainmentDiversity: Vielfältige Unterhaltung</li>
-- <li>Buff_Sermon: Predigt halten</li>
-- <li>Buff_Festival: Fest veranstalten</li>
-- <li>Buff_ExtraPayment: Bonussold auszahlen</li>
-- <li>Buff_HighTaxes: Hohe Steuern verlangen</li>
-- <li>Buff_NoPayment: Sold streichen</li>
-- <li>Buff_NoTaxes: Keine Steuern verlangen</li>
-- <br/>
-- <u>Buffs "Reich des Ostens"</u>
-- <li>Buff_Gems: Edelsteine</li>
-- <li>Buff_MusicalInstrument: Musikinstrumente</li>
-- <li>Buff_Olibanum: Weihrauch</li>
--
-- @param _PlayerID Spieler, der den Buff aktivieren muss
-- @param _Buff     Buff, der aktiviert werden soll
--
-- @within Goal
--
function Goal_ActivateBuff(...)
    return b_Goal_ActivateBuff:new(...);
end

b_Goal_ActivateBuff = {
    Name = "Goal_ActivateBuff",
    Description = {
        en = "Goal: Activate a buff",
        de = "Ziel: Aktiviere einen Buff",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Buff", de = "Buff" },
    },
}

function b_Goal_ActivateBuff:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_ActivateBuff:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.BuffName = _Parameter
        self.Buff = Buffs[_Parameter]
    end
end

function b_Goal_ActivateBuff:CustomFunction(_Quest)
   if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local tMapping = API.InstanceTable(BundleClassicBehaviors.Text.ActivateBuff.BuffsVanilla);
        if g_GameExtraNo >= 1 then
            tMapping = API.InstanceTable(BundleClassicBehaviors.Text.ActivateBuff.BuffsEx1, tMapping);
        end
        Core:ChangeCustomQuestCaptionText(
            string.format(
                API.Localize(BundleClassicBehaviors.Text.ActivateBuff.Pattern),
                API.Localize(tMapping[self.BuffName])
            ),
            _Quest
        );
    end

    local Buff = Logic.GetBuff( self.PlayerID, self.Buff )
    if Buff and Buff ~= 0 then
        return true
    end
end

function b_Goal_ActivateBuff:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        Data = {
            "Buff_Spice",
            "Buff_Colour",
            "Buff_Entertainers",
            "Buff_FoodDiversity",
            "Buff_ClothesDiversity",
            "Buff_HygieneDiversity",
            "Buff_EntertainmentDiversity",
            "Buff_Sermon",
            "Buff_Festival",
            "Buff_ExtraPayment",
            "Buff_HighTaxes",
            "Buff_NoPayment",
            "Buff_NoTaxes"
        }

        if g_GameExtraNo >= 1 then
            table.insert(Data, "Buff_Gems")
            table.insert(Data, "Buff_MusicalInstrument")
            table.insert(Data, "Buff_Olibanum")
        end

        table.sort( Data )
    else
        assert( false )
    end
    return Data
end

function b_Goal_ActivateBuff:GetIcon()
    local tMapping = {
        [Buffs.Buff_Spice]                  = "Goods.G_Salt",
        [Buffs.Buff_Colour]                 = "Goods.G_Dye",
        [Buffs.Buff_Entertainers]           = "Entities.U_Entertainer_NA_FireEater", --{5, 12},
        [Buffs.Buff_FoodDiversity]          = "Needs.Nutrition", --{1, 1},
        [Buffs.Buff_ClothesDiversity]       = "Needs.Clothes", --{1, 2},
        [Buffs.Buff_HygieneDiversity]       = "Needs.Hygiene", --{16, 1},
        [Buffs.Buff_EntertainmentDiversity] = "Needs.Entertainment", --{1, 4},
        [Buffs.Buff_Sermon]                 = "Technologies.R_Sermon", --{4, 14},
        [Buffs.Buff_Festival]               = "Technologies.R_Festival", --{4, 15},
        [Buffs.Buff_ExtraPayment]           = {1,8},
        [Buffs.Buff_HighTaxes]              = {1,6},
        [Buffs.Buff_NoPayment]              = {1,8},
        [Buffs.Buff_NoTaxes]                = {1,6},
    }
    if g_GameExtraNo and g_GameExtraNo >= 1 then
        tMapping[Buffs.Buff_Gems] = "Goods.G_Gems"
        tMapping[Buffs.Buff_MusicalInstrument] = "Goods.G_MusicalInstrument"
        tMapping[Buffs.Buff_Olibanum] = "Goods.G_Olibanum"
    end
    return tMapping[self.Buff]
end

function b_Goal_ActivateBuff:Debug(_Quest)
    if not self.Buff then
        error(_Quest.Identifier.. ": " ..self.Name..": buff '" ..self.BuffName.. "' does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_ActivateBuff);

-- -------------------------------------------------------------------------- --

---
-- Zwei Punkte auf der Spielwelt müssen mit einer Straße verbunden werden.
--
-- @param _Position1 Erster Endpunkt der Straße
-- @param _Position2 Zweiter Endpunkt der Straße
-- @param _OnlyRoads Keine Wege akzeptieren
--
-- @within Goal
--
function Goal_BuildRoad(...)
    return b_Goal_BuildRoad:new(...)
end

b_Goal_BuildRoad = {
    Name = "Goal_BuildRoad",
    Description = {
        en = "Goal: Connect two points with a street or a road",
        de = "Ziel: Verbinde zwei Punkte mit einer Strasse oder einem Weg.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1",     de = "Entity 1" },
        { ParameterType.ScriptName, en = "Entity 2",     de = "Entity 2" },
        { ParameterType.Custom,     en = "Only roads",     de = "Nur Strassen" },
    },
}

function b_Goal_BuildRoad:GetGoalTable()
    -- {BehaviorType, {EntityID1, EntityID2, BeSmalerThan, Length, RoadsOnly}}
    -- -> Length wird nicht mehr benutzt. Sorgte für Promleme im Spiel
    return { Objective.BuildRoad, { GetID( self.Entity1 ), GetID( self.Entity2 ), false, 0, self.bRoadsOnly } }
end

function b_Goal_BuildRoad:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRoadsOnly = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Goal_BuildRoad:GetCustomData( _Index )
    local Data
    if _Index == 2 then
        Data = {"true","false"}
    end
    return Data
end

function b_Goal_BuildRoad:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        error(_Quest.Identifier.. ": " ..self.Name..": first or second entity does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_BuildRoad);

-- -------------------------------------------------------------------------- --


---
-- Eine Mauer muss gebaut werden um die Bewegung eines Spielers einzuschränken.
-- 
-- Einschränken bedeutet, dass sich der angegebene Spieler nicht von Punkt A
-- nach Punkt B bewegen kann, weil eine Mauer im Weg ist. Die Punkte sind
-- frei wählbar. In den meisten Fällen reicht es, Marktplätze anzugeben.
--
-- Beispiel: Spieler 3 ist der Feind von Spieler 1, aber Bekannt mit Spieler 2.
-- Wenn er sich nicht mehr zwischen den Marktplätzen von Spieler 1 und 2
-- bewegen kann, weil eine Mauer dazwischen ist, ist das Ziel erreicht.
--
-- <b>Achtung:</b> Bei Monsun kann dieses Ziel fälschlicher Weise als erfüllt
-- gewertet werden, wenn der Weg durch Wasser blockiert wird!
--
-- @param _PlayerID  PlayerID, die blockiert wird
-- @param _Position1 Erste Position
-- @param _Position2 Zweite Position
--
-- @within Goal
--
function Goal_BuildWall(...)
    return b_Goal_BuildWall:new(...)
end

b_Goal_BuildWall = {
    Name = "Goal_BuildWall",
    Description = {
        en = "Goal: Build a wall between 2 positions bo stop the movement of an (hostile) player.",
        de = "Ziel: Baue eine Mauer zwischen 2 Punkten, die die Bewegung eines (feindlichen) Spielers zwischen den Punkten verhindert.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Enemy", de = "Feind" },
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2" },
    },
}

function b_Goal_BuildWall:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_BuildWall:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.EntityName1 = _Parameter
    elseif (_Index == 2) then
        self.EntityName2 = _Parameter
    end
end

function b_Goal_BuildWall:CustomFunction(_Quest)
    local eID1 = GetID(self.EntityName1)
    local eID2 = GetID(self.EntityName2)

    if not IsExisting(eID1) then
        return false
    end
    if not IsExisting(eID2) then
        return false
    end
    local x,y,z = Logic.EntityGetPos(eID1)
    if Logic.IsBuilding(eID1) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID1)
    end
    local Sector1 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    local x,y,z = Logic.EntityGetPos(eID2)
    if Logic.IsBuilding(eID2) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID2)
    end
    local Sector2 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    if Sector1 ~= Sector2 then
        return true
    end
    return nil
end

function b_Goal_BuildWall:GetMsgKey()
    return "Quest_Create_Wall"
end

function b_Goal_BuildWall:GetIcon()
    return {3,9}
end

function b_Goal_BuildWall:Debug(_Quest)
    if not IsExisting(self.EntityName1) or not IsExisting(self.EntityName2) then
        error(_Quest.Identifier.. ": " ..self.Name..": first or second entity does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end

    if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) > -1 and not self.WarningPrinted then
        warn(_Quest.Identifier.. ": " ..self.Name..": player %d is neighter enemy or unknown to quest receiver!");
        self.WarningPrinted = true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_BuildWall);

-- -------------------------------------------------------------------------- --

---
-- Ein bestimmtes Territorium muss vom Auftragnehmer eingenommen werden.
--
-- @param _Territory Territorium-ID oder Territoriumname
--
-- @within Goal
--
function Goal_Claim(...)
    return b_Goal_Claim:new(...)
end

b_Goal_Claim = {
    Name = "Goal_Claim",
    Description = {
        en = "Goal: Claim a territory",
        de = "Ziel: Erobere ein Territorium",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },
    },
}

function b_Goal_Claim:GetGoalTable()
    return { Objective.Claim, 1, self.TerritoryID }
end

function b_Goal_Claim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function b_Goal_Claim:GetMsgKey()
    return "Quest_Claim_Territory"
end

Core:RegisterBehavior(b_Goal_Claim);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge an Territorien besitzen.
-- Das Heimatterritorium des Spielers wird mitgezählt!
--
-- @param _Amount Anzahl Territorien
--
-- @within Goal
--
function Goal_ClaimXTerritories(...)
    return b_Goal_ClaimXTerritories:new(...)
end

b_Goal_ClaimXTerritories = {
    Name = "Goal_ClaimXTerritories",
    Description = {
        en = "Goal: Claim the given number of territories, all player territories are counted",
        de = "Ziel: Erobere die angegebene Anzahl Territorien, alle spielereigenen Territorien werden gezählt",
    },
    Parameter = {
        { ParameterType.Number, en = "Territories" , de = "Territorien" }
    },
}

function b_Goal_ClaimXTerritories:GetGoalTable()
    return { Objective.Claim, 2, self.TerritoriesToClaim }
end

function b_Goal_ClaimXTerritories:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoriesToClaim = _Parameter * 1
    end
end

function b_Goal_ClaimXTerritories:GetMsgKey()
    return "Quest_Claim_Territory"
end

Core:RegisterBehavior(b_Goal_ClaimXTerritories);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss auf dem Territorium einen Entitytyp erstellen.
--
-- Dieses Behavior eignet sich für Aufgaben vom Schlag "Baue X Getreidefarmen
-- Auf Territorium >".
--
-- @param _Type      Typ des Entity
-- @param _Amount    Menge an Entities
-- @param _Territory Territorium
--
-- @within Goal
--
function Goal_Create(...)
    return b_Goal_Create:new(...);
end

b_Goal_Create = {
    Name = "Goal_Create",
    Description = {
        en = "Goal: Create Buildings/Units on a specified territory",
        de = "Ziel: Erstelle Einheiten/Gebäude auf einem bestimmten Territorium.",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium" },
    },
}

function b_Goal_Create:GetGoalTable()
    return { Objective.Create, assert( Entities[self.EntityName] ), self.Amount, self.TerritoryID }
end

function b_Goal_Create:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function b_Goal_Create:GetMsgKey()
    return Logic.IsEntityTypeInCategory( Entities[self.EntityName], EntityCategories.AttackableBuilding ) == 1 and "Quest_Create_Building" or "Quest_Create_Unit"
end

Core:RegisterBehavior(b_Goal_Create);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge von Rohstoffen produzieren.
--
-- @param _Type   Typ des Rohstoffs
-- @param _Amount Menge an Rohstoffen
--
-- @within Goal
--
function Goal_Produce(...)
    return b_Goal_Produce:new(...);
end

b_Goal_Produce = {
    Name = "Goal_Produce",
    Description = {
        en = "Goal: Produce an amount of goods",
        de = "Ziel: Produziere eine Anzahl einer bestimmten Ware.",
    },
    Parameter = {
        { ParameterType.RawGoods, en = "Type of good", de = "Ressourcentyp" },
        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Ressource" },
    },
}

function b_Goal_Produce:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount }
end

function b_Goal_Produce:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function b_Goal_Produce:GetMsgKey()
    return "Quest_Produce"
end

Core:RegisterBehavior(b_Goal_Produce);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss eine bestimmte Menge einer Ware erreichen.
--
-- @param _Type     Typ der Ware
-- @param _Amount   Menge an Waren
-- @param _Relation Mengenrelation
--
-- @within Goal
--
function Goal_GoodAmount(...)
    return b_Goal_GoodAmount:new(...);
end

b_Goal_GoodAmount = {
    Name = "Goal_GoodAmount",
    Description = {
        en = "Goal: Obtain an amount of goods - either by trading or producing them",
        de = "Ziel: Beschaffe eine Anzahl Waren - entweder durch Handel oder durch eigene Produktion.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Warentyp" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
    },
}

function b_Goal_GoodAmount:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount, self.bRelSmallerThan }
end

function b_Goal_GoodAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    elseif  (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "<" or tostring(_Parameter) == "true"
    end
end

function b_Goal_GoodAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

Core:RegisterBehavior(b_Goal_GoodAmount);

-- -------------------------------------------------------------------------- --

---
-- Die Siedler des Spielers dürfen nicht aufgrund des Bedürfnisses streiken.
--
-- <u>Bedürfnisse</u>
-- <ul>
-- <li>Clothes: Kleidung</li>
-- <li>Entertainment: Unterhaltung</li>
-- <li>Nutrition: Nahrung</li>
-- <li>Hygiene: Hygiene</li>
-- <li>Medicine: Medizin</li>
-- </ul>
--
-- @param _PlayerID ID des Spielers
-- @param _Need     Bedürfnis
--
-- @within Goal
--
function Goal_SatisfyNeed(...)
    return b_Goal_SatisfyNeed:new(...);
end

b_Goal_SatisfyNeed = {
    Name = "Goal_SatisfyNeed",
    Description = {
        en = "Goal: Satisfy a need",
        de = "Ziel: Erfuelle ein Bedürfnis",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Need, en = "Need", de = "Bedürfnis" },
    },
}

function b_Goal_SatisfyNeed:GetGoalTable()
    return { Objective.SatisfyNeed, Needs[self.Need], self.PlayerID }

end

function b_Goal_SatisfyNeed:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    end

end

function b_Goal_SatisfyNeed:GetMsgKey()
    local tMapping = {
        [Needs.Clothes] = "Quest_SatisfyNeed_Clothes",
        [Needs.Entertainment] = "Quest_SatisfyNeed_Entertainment",
        [Needs.Nutrition] = "Quest_SatisfyNeed_Food",
        [Needs.Hygiene] = "Quest_SatisfyNeed_Hygiene",
        [Needs.Medicine] = "Quest_SatisfyNeed_Medicine",
    }

    local Key = tMapping[Needs[self.Need]]
    if Key then
        return Key
    end

    -- No default message
end

Core:RegisterBehavior(b_Goal_SatisfyNeed);

-- -------------------------------------------------------------------------- --

---
-- Der angegebene Spieler muss eine Menge an Siedlern in der Stadt haben.
--
-- @param _Amount   Menge an Siedlern
-- @param _PlayerID ID des Spielers (Default: 1)
--
-- @within Goal
--
function Goal_SettlersNumber(...)
    return b_Goal_SettlersNumber:new(...);
end

b_Goal_SettlersNumber = {
    Name = "Goal_SettlersNumber",
    Description = {
        en = "Goal: Get a given amount of settlers",
        de = "Ziel: Erreiche eine bestimmte Anzahl Siedler.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount", de = "Anzahl" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_SettlersNumber:GetGoalTable()
    return {Objective.SettlersNumber, self.PlayerID or 1, self.SettlersAmount };
end

function b_Goal_SettlersNumber:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SettlersAmount = _Parameter * 1;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    end
end

function b_Goal_SettlersNumber:GetMsgKey()
    return "Quest_NumberSettlers";
end

Core:RegisterBehavior(b_Goal_SettlersNumber);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge von Ehefrauen in der Stadt haben.
--
-- @param _Amount Menge an Ehefrauen
--
-- @within Goal
--
function Goal_Spouses(...)
    return b_Goal_Spouses:new(...);
end

b_Goal_Spouses = {
    Name = "Goal_Spouses",
    Description = {
        en = "Goal: Get a given amount of spouses",
        de = "Ziel: Erreiche eine bestimmte Ehefrauenanzahl",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
    },
}

function b_Goal_Spouses:GetGoalTable()
    return {Objective.Spouses, self.SpousesAmount }
end

function b_Goal_Spouses:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SpousesAmount = _Parameter * 1
    end
end

function b_Goal_Spouses:GetMsgKey()
    return "Quest_NumberSpouses"
end

Core:RegisterBehavior(b_Goal_Spouses);

-- -------------------------------------------------------------------------- --

---
-- Ein Spieler muss eine Menge an Soldaten haben.
--
-- <u>Relationen</u>
-- <ul>
-- <li>>= - Anzahl als Mindestmenge</li>
-- <li>< - Weniger als Anzahl</li>
-- </ul>
--
-- Dieses Behavior kann verwendet werden um die Menge an feindlichen
-- Soldaten zu zählen oder die Menge an Soldaten des Spielers.
--
-- @param _PlayerID ID des Spielers
-- @param _Relation Mengenrelation
-- @param _Amount   Menge an Soldaten
--
-- @within Goal
--
function Goal_SoldierCount(...)
    return b_Goal_SoldierCount:new(...);
end

b_Goal_SoldierCount = {
    Name = "Goal_SoldierCount",
    Description = {
        en = "Goal: Create a specified number of soldiers",
        de = "Ziel: Erreiche eine Anzahl grösser oder kleiner der angegebenen Menge Soldaten.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },
    },
}

function b_Goal_SoldierCount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_SoldierCount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or tostring(_Parameter) == "<"
    elseif (_Index == 2) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function b_Goal_SoldierCount:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local Relation = tostring(self.bRelSmallerThan);
        local PlayerName = GetPlayerName(self.PlayerID) or "";
        Core:ChangeCustomQuestCaptionText(
            string.format(
                API.Localize(BundleClassicBehaviors.Text.SoldierCount.Pattern),
                PlayerName,
                API.Localize(BundleClassicBehaviors.Text.SoldierCount.Relation[Relation]),
                self.NumberOfUnits
            ),
            _Quest
        );
    end

    local NumSoldiers = Logic.GetCurrentSoldierCount( self.PlayerID )
    if ( self.bRelSmallerThan and NumSoldiers < self.NumberOfUnits ) then
        return true
    elseif ( not self.bRelSmallerThan and NumSoldiers >= self.NumberOfUnits ) then
        return true
    end
    return nil
end

function b_Goal_SoldierCount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then

        table.insert( Data, ">=" )
        table.insert( Data, "<" )

    else
        assert( false )
    end
    return Data
end

function b_Goal_SoldierCount:GetIcon()
    return {7,11}
end

function b_Goal_SoldierCount:GetMsgKey()
    return "Quest_Create_Unit"
end

function b_Goal_SoldierCount:Debug(_Quest)
    if tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then
        error(_Quest.Identifier.. ": " ..self.Name..": amount can not be below 0!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_SoldierCount);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss wenigstens einen bestimmten Titel erreichen.
--
-- Folgende Titel können verwendet werden:
-- <table border="1">
-- <tr>
-- <td><b>Titel</b></td>
-- <td><b>Übersetzung</b></td>
-- </tr>
-- <tr>
-- <td>Knight</td>
-- <td>Ritter</td>
-- </tr>
-- <tr>
-- <td>Mayor</td>
-- <td>Landvogt</td>
-- </tr>
-- <tr>
-- <td>Baron</td>
-- <td>Baron</td>
-- </tr>
-- <tr>
-- <td>Earl</td>
-- <td>Graf</td>
-- </tr>
-- <tr>
-- <td>Marquees</td>
-- <td>Marktgraf</td>
-- </tr>
-- <tr>
-- <td>Duke</td>
-- <td>Herzog</td>
-- </tr>
-- </tr>
-- <tr>
-- <td>Archduke</td>
-- <td>Erzherzog</td>
-- </tr>
-- <table>
--
-- @param _Title Titel, der erreicht werden muss
--
-- @within Goal
--
function Goal_KnightTitle(...)
    return b_Goal_KnightTitle:new(...);
end

b_Goal_KnightTitle = {
    Name = "Goal_KnightTitle",
    Description = {
        en = "Goal: Reach a specified knight title",
        de = "Ziel: Erreiche einen vorgegebenen Titel",
    },
    Parameter = {
        { ParameterType.Custom, en = "Knight title", de = "Titel" },
    },
}

function b_Goal_KnightTitle:GetGoalTable()
    return {Objective.KnightTitle, assert( KnightTitles[self.KnightTitle] ) }
end

function b_Goal_KnightTitle:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.KnightTitle = _Parameter
    end
end

function b_Goal_KnightTitle:GetMsgKey()
    return "Quest_KnightTitle"
end

function b_Goal_KnightTitle:GetCustomData( _Index )
    return {"Knight", "Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"}
end

Core:RegisterBehavior(b_Goal_KnightTitle);

-- -------------------------------------------------------------------------- --

---
-- Der angegebene Spieler muss mindestens die Menge an Festen feiern.
--
-- Ein Fest wird gewertet, sobald die Metfässer auf dem Markt erscheinen. Diese
-- Metfässer erscheinen im normalen Spielverlauf nur durch ein Fest!
--
-- <b>Achtung</b>: Wenn ein Spieler aus einem anderen Grund Metfässer besitzt,
-- wird dieses Behavior nicht mehr richtig funktionieren!
--
-- @param _PlayerID ID des Spielers
-- @param _Amount   Menge an Festen
--
-- @within Goal
--
function Goal_Festivals(...)
    return b_Goal_Festivals:new(...);
end

b_Goal_Festivals = {
    Name = "Goal_Festivals",
    Description = {
        en = "Goal: The player has to start the given number of festivals.",
        de = "Ziel: Der Spieler muss eine gewisse Anzahl Feste gestartet haben.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Number, en = "Number of festivals", de = "Anzahl Feste" }
    }
};

function b_Goal_Festivals:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function b_Goal_Festivals:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.PlayerID = tonumber(_Parameter);
    else
        assert(_Index == 1, "Error in " .. self.Name .. ": AddParameter: Index is invalid.");
        self.NeededFestivals = tonumber(_Parameter);
    end
end

function b_Goal_Festivals:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local PlayerName = GetPlayerName(self.PlayerID) or "";
        Core:ChangeCustomQuestCaptionText(
            string.format(
                API.Localize(BundleClassicBehaviors.Text.Festivals.Pattern),
                PlayerName, self.NeededFestivals
            ), 
            _Quest
        );
    end

    if Logic.GetStoreHouse( self.PlayerID ) == 0  then
        return false
    end
    local tablesOnFestival = {Logic.GetPlayerEntities(self.PlayerID, Entities.B_TableBeer, 5,0)}
    local amount = 0
    for k=2, #tablesOnFestival do
        local tableID = tablesOnFestival[k]
        if Logic.GetIndexOnOutStockByGoodType(tableID, Goods.G_Beer) ~= -1 then
            local goodAmountOnMarketplace = Logic.GetAmountOnOutStockByGoodType(tableID, Goods.G_Beer)
            amount = amount + goodAmountOnMarketplace
        end
    end
    if not self.FestivalStarted and amount > 0 then
        self.FestivalStarted = true
        self.FestivalCounter = (self.FestivalCounter and self.FestivalCounter + 1) or 1
        if self.FestivalCounter >= self.NeededFestivals then
            self.FestivalCounter = nil
            return true
        end
    elseif amount == 0 then
        self.FestivalStarted = false
    end
end

function b_Goal_Festivals:Debug(_Quest)
    if Logic.GetStoreHouse( self.PlayerID ) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead :-(")
        return true
    elseif GetPlayerCategoryType(self.PlayerID) ~= PlayerCategories.City then
        error(_Quest.Identifier.. ": " ..self.Name .. ":  Player "..  self.PlayerID .. " is no city")
        return true
    elseif self.NeededFestivals < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Festivals is negative")
        return true
    end
    return false
end

function b_Goal_Festivals:Reset()
    self.FestivalCounter = nil
    self.FestivalStarted = nil
end

function b_Goal_Festivals:GetIcon()
    return {4,15}
end

Core:RegisterBehavior(b_Goal_Festivals)

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Einheit gefangen nehmen.
--
-- @param _ScriptName Ziel
--
-- @within Goal
--
function Goal_Capture(...)
    return b_Goal_Capture:new(...)
end

b_Goal_Capture = {
    Name = "Goal_Capture",
    Description = {
        en = "Goal: Capture a cart.",
        de = "Ziel: Ein Karren muss erobert werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Goal_Capture:GetGoalTable()
    return { Objective.Capture, 1, { self.ScriptName } }
end

function b_Goal_Capture:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Goal_Capture:GetMsgKey()
   local ID = GetID(self.ScriptName)
   if Logic.IsEntityAlive(ID) then
        ID = Logic.GetEntityType( ID )
        if ID and ID ~= 0 then
            if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                return "Quest_Capture_Cart"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
                return "Quest_Capture_SiegeEngine"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

                return "Quest_Capture_VIPOfPlayer"

            end
        end
    end
end

Core:RegisterBehavior(b_Goal_Capture);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge von Einheiten eines Typs von einem
-- Spieler gefangen nehmen.
--
-- @param _Typ      Typ, der gefangen werden soll
-- @param _Amount   Menge an Einheiten
-- @param _PlayerID Besitzer der Einheiten
--
-- @within Goal
--
function Goal_CaptureType(...)
    return b_Goal_CaptureType:new(...)
end

b_Goal_CaptureType = {
    Name = "Goal_CaptureType",
    Description = {
        en = "Goal: Capture specified entity types",
        de = "Ziel: Nimm bestimmte Entitätstypen gefangen",
    },
    Parameter = {
        { ParameterType.Custom,     en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number,     en = "Amount", de = "Anzahl" },
        { ParameterType.PlayerID,     en = "Player", de = "Spieler" },
    },
}

function b_Goal_CaptureType:GetGoalTable()
    return { Objective.Capture, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function b_Goal_CaptureType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_CaptureType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^U_.+Cart" ) or Logic.IsEntityTypeInCategory( v, EntityCategories.AttackableMerchant ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function b_Goal_CaptureType:GetMsgKey()

    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
        return "Quest_Capture_Cart"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
        return "Quest_Capture_SiegeEngine"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

        return "Quest_Capture_VIPOfPlayer"
    end
end

Core:RegisterBehavior(b_Goal_CaptureType);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss das angegebene Entity beschützen.
--
-- Wird ein Wagen zerstört oder in das Lagerhaus / die Burg eines Feindes
-- gebracht, schlägt das Ziel fehl.
--
-- @param _ScriptName Zu beschützendes Entity
--
-- @within Goal
--
function Goal_Protect(...)
    return b_Goal_Protect:new(...)
end

b_Goal_Protect = {
    Name = "Goal_Protect",
    Description = {
        en = "Goal: Protect an entity (entity needs a script name",
        de = "Ziel: Beschütze eine Entität (Entität benötigt einen Skriptnamen)",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Goal_Protect:GetGoalTable()
    return {Objective.Protect, { self.ScriptName }}
end

function b_Goal_Protect:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Goal_Protect:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SpecialBuilding ) == 1 then
                    local tMapping = {
                        [PlayerCategories.City]        = "Quest_Protect_City",
                        [PlayerCategories.Cloister]    = "Quest_Protect_Cloister",
                        [PlayerCategories.Village]    = "Quest_Protect_Village",
                    }
                    local PlayerCategory = GetPlayerCategoryType( Logic.EntityGetPlayer(GetID(self.ScriptName)) )
                    if PlayerCategory then
                        local Key = tMapping[PlayerCategory]
                        if Key then
                            return Key
                        end
                    end
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Protect_Knight"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                    return "Quest_Protect_Cart"
                end
            end
        end
    end
    return "Quest_Protect"
end

Core:RegisterBehavior(b_Goal_Protect);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Mine mit einem Geologen wieder auffüllen.
--
-- <b>Achtung</b>: Dieses Behavior ist nur in "Reich des Ostens" verfügbar.
--
-- @param _ScriptName Skriptname der Mine
--
-- @within Goal
--
function Goal_Refill(...)
    return b_Goal_Refill:new(...)
end

b_Goal_Refill = {
    Name = "Goal_Refill",
    Description = {
        en = "Goal: Refill an object using a geologist",
        de = "Ziel: Eine Mine soll durch einen Geologen wieder aufgefuellt werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
   RequiresExtraNo = 1,
}

function b_Goal_Refill:GetGoalTable()
    return { Objective.Refill, { GetID(self.ScriptName) } }
end

function b_Goal_Refill:GetIcon()
    return {8,1,1}
end

function b_Goal_Refill:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

if g_GameExtraNo > 0 then
    Core:RegisterBehavior(b_Goal_Refill);
end

-- -------------------------------------------------------------------------- --

---
-- Eine bestimmte Menge an Rohstoffen in einer Mine muss erreicht werden.
--
-- Dieses Behavior eignet sich besonders für den Einsatz als versteckter
-- Quest um eine Reaktion auszulösen, wenn z.B. eine Mine leer ist.
--
-- <u>Relationen</u>
-- <ul>
-- <li>> - Mehr als Anzahl</li>
-- <li>< - Weniger als Anzahl</li>
-- </ul>
--
-- @param _ScriptName Skriptname der Mine
-- @param _Relation   Mengenrelation
-- @param _Amount     Menge an Rohstoffen
--
-- @within Goal
--
function Goal_ResourceAmount(...)
    return b_Goal_ResourceAmount:new(...)
end

b_Goal_ResourceAmount = {
    Name = "Goal_ResourceAmount",
    Description = {
        en = "Goal: Reach a specified amount of resources in a doodad",
        de = "Ziel: In einer Mine soll weniger oder mehr als eine angegebene Anzahl an Rohstoffen sein.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
        { ParameterType.Number, en = "Amount", de = "Menge" },
    },
}

function b_Goal_ResourceAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_ResourceAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = _Parameter == "<"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function b_Goal_ResourceAmount:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    if ID and ID ~= 0 and Logic.GetResourceDoodadGoodType(ID) ~= 0 then
        local HaveAmount = Logic.GetResourceDoodadGoodAmount(ID)
        if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then
            return true
        end
    end
    return nil
end

function b_Goal_ResourceAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function b_Goal_ResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        error(_Quest.Identifier.. ": " ..self.Name..": entity '" ..self.ScriptName.. "' does not exist!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name..": error at amount! (nil or below 0)");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_ResourceAmount);

-- -------------------------------------------------------------------------- --

---
-- Der Quest schlägt sofort fehl.
--
-- @within Goal
--
function Goal_InstantFailure()
    return b_Goal_InstantFailure:new()
end

b_Goal_InstantFailure = {
    Name = "Goal_InstantFailure",
    Description = {
        en = "Instant failure, the goal returns false.",
        de = "Direkter Misserfolg, das Goal sendet false.",
    },
}

function b_Goal_InstantFailure:GetGoalTable()
    return {Objective.DummyFail};
end

Core:RegisterBehavior(b_Goal_InstantFailure);

-- -------------------------------------------------------------------------- --

---
-- Der Quest wird sofort erfüllt.
--
-- @within Goal
--
function Goal_InstantSuccess()
    return b_Goal_InstantSuccess:new()
end

b_Goal_InstantSuccess = {
    Name = "Goal_InstantSuccess",
    Description = {
        en = "Instant success, the goal returns true.",
        de = "Direkter Erfolg, das Goal sendet true.",
    },
}

function b_Goal_InstantSuccess:GetGoalTable()
    return {Objective.Dummy};
end

Core:RegisterBehavior(b_Goal_InstantSuccess);

-- -------------------------------------------------------------------------- --

---
-- Der Zustand des Quests ändert sich niemals
--
-- Wenn ein Zeitlimit auf dem Quest liegt, wird dieses Behavior nicht
-- fehlschlagen sondern automatisch erfüllt.
--
-- @within Goal
--
function Goal_NoChange()
    return b_Goal_NoChange:new()
end

b_Goal_NoChange = {
    Name = "Goal_NoChange",
    Description = {
        en = "The quest state doesn't change. Use reward functions of other quests to change the state of this quest.",
        de = "Der Questzustand wird nicht verändert. Ein Reward einer anderen Quest sollte den Zustand dieser Quest verändern.",
    },
}

function b_Goal_NoChange:GetGoalTable()
    return { Objective.NoChange }
end

Core:RegisterBehavior(b_Goal_NoChange);

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Goal aus.
--
-- Die Funktion muss entweder true, false oder nichts zurückgeben.
-- <ul>
-- <li>true: Erfolgreich abgeschlossen</li>
-- <li>false: Fehlschlag</li>
-- <li>nichts: Zustand unbestimmt</li>
-- </ul>
--
-- Anstelle eines Strings kann beim Einsatz im Skript eine Funktionsreferenz
-- übergeben werden. In diesem Fall werden alle weiteren Parameter direkt an
-- die Funktion weitergereicht.
--
-- @param _FunctionName Name der Funktion
--
-- @within Goal
--
function Goal_MapScriptFunction(...)
    return b_Goal_MapScriptFunction:new(...);
end

b_Goal_MapScriptFunction = {
    Name = "Goal_MapScriptFunction",
    Description = {
        en = "Goal: Calls a function within the global map script. Return 'true' means success, 'false' means failure and 'nil' doesn't change anything.",
        de = "Ziel: Ruft eine Funktion im globalen Skript auf, die einen Wahrheitswert zurueckgibt. Rueckgabe 'true' gilt als erfuellt, 'false' als gescheitert und 'nil' ändert nichts.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname" },
    },
}

function b_Goal_MapScriptFunction:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function b_Goal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.FuncName(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function b_Goal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        error(_Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        error(_Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

---
-- Eine benutzerdefinierte Variable muss einen bestimmten Wert haben.
--
-- Custom Variables können ausschließlich Zahlen enthalten. Bevor eine
-- Variable in einem Goal abgefragt werden kann, muss sie zuvor mit
-- Reprisal_CustomVariables oder Reward_CutsomVariables initialisiert
-- worden sein.
--
-- <p>Vergleichsoperatoren</p>
-- <ul>
-- <li>== - Werte müssen gleich sein</li>
-- <li>~= - Werte müssen ungleich sein</li>
-- <li>> - Variablenwert größer Vergleichswert</li>
-- <li>>= - Variablenwert größer oder gleich Vergleichswert</li>
-- <li>< - Variablenwert kleiner Vergleichswert</li>
-- <li><= - Variablenwert kleiner oder gleich Vergleichswert</li>
-- </ul>
--
-- @param _Name     Name der Variable
-- @param _Relation Vergleichsoperator
-- @param _Value    Wert oder andere Custom Variable mit wert.
--
-- @within Goal
--
function Goal_CustomVariables(...)
    return b_Goal_CustomVariables:new(...);
end

b_Goal_CustomVariables = {
    Name = "Goal_CustomVariables",
    Description = {
        en = "Goal: A customised variable has to assume a certain value.",
        de = "Ziel: Eine benutzerdefinierte Variable muss einen bestimmten Wert annehmen.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable", de = "Variablenname" },
        { ParameterType.Custom,  en = "Relation", de = "Relation" },
        { ParameterType.Default, en = "Value or variable", de = "Wert oder Variable" }
    }
};

function b_Goal_CustomVariables:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function b_Goal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        value = (value ~= nil and value) or tostring(_Parameter);
        self.Value = value
    end
end

function b_Goal_CustomVariables:CustomFunction()
    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;

    local Value = (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    if self.Relation == "==" then
        if _G["QSB_CustomVariables_"..self.VariableName] == Value then
            return true;
        end
    elseif self.Relation == "~=" then
        if _G["QSB_CustomVariables_"..self.VariableName] == Value then
            return true;
        end
    elseif self.Relation == "<" then
        if _G["QSB_CustomVariables_"..self.VariableName] < Value then
            return true;
        end
    elseif self.Relation == "<=" then
        if _G["QSB_CustomVariables_"..self.VariableName] <= Value then
            return true;
        end
    elseif self.Relation == ">=" then
        if _G["QSB_CustomVariables_"..self.VariableName] >= Value then
            return true;
        end
    else
        if _G["QSB_CustomVariables_"..self.VariableName] > Value then
            return true;
        end
    end
    return nil;
end

function b_Goal_CustomVariables:GetCustomData( _Index )
    return {"==", "~=", "<=", "<", ">", ">="};
end

function b_Goal_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "<=", "<", ">", ">="}
    local results    = {true, false, nil}

    if not _G["QSB_CustomVariables_"..self.VariableName] then
        warn(_Quest.Identifier.. ": " ..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not Inside(self.Relation, relations) then
        error(_Quest.Identifier.. ": " ..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Lässt den Spieler zwischen zwei Antworten wählen.
--
-- Dabei kann zwischen den Labels Ja/Nein und Ok/Abbrechen gewählt werden.
--
-- <b>Hinweis:</b> Es können nur geschlossene Fragen gestellt werden. Dialoge
-- müssen also immer mit Ja oder Nein beantwortbar sein oder auf Okay und
-- Abbrechen passen.
--
-- @param _Text   Fenstertext
-- @param _Title  Fenstertitel
-- @param _Labels Label der Buttons
--
-- @within Goal
--
function Goal_Decide(...)
    return b_Goal_Decide:new(...);
end

b_Goal_Decide = {
    Name = "Goal_Decide",
    Description = {
        en = "Opens a Yes/No Dialog. Decision = Quest Result",
        de = "Oeffnet einen Ja/Nein-Dialog. Die Entscheidung bestimmt das Quest-Ergebnis (ja=true, nein=false).",
    },
    Parameter = {
        { ParameterType.Default, en = "Text", de = "Text", },
        { ParameterType.Default, en = "Title", de = "Titel", },
        { ParameterType.Custom, en = "Button labels", de = "Button Beschriftung", },
    },
}

function b_Goal_Decide:GetGoalTable()
    return { Objective.Custom2, { self, self.CustomFunction } }
end

function b_Goal_Decide:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Text = _Parameter
    elseif (_Index == 1) then
        self.Title = _Parameter
    elseif (_Index == 2) then
        self.Buttons = (_Parameter == "Ok/Cancel")
    end
end

function b_Goal_Decide:CustomFunction(_Quest)
    if not IsBriefingActive or (IsBriefingActive and IsBriefingActive() == false) then
        if not self.LocalExecuted then
            if QSB.DialogActive then
                return;
            end
            QSB.DialogActive = true
            local buttons = (self.Buttons and "true") or "nil"
            self.LocalExecuted = true

            local commandString = [[
                Game.GameTimeSetFactor( GUI.GetPlayerID(), 0 )
                OpenRequesterDialog(%q,
                                    %q,
                                    "Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 ); GUI.SendScriptCommand( 'QSB.DecisionWindowResult = true ')",
                                    %s ,
                                    "Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 ); GUI.SendScriptCommand( 'QSB.DecisionWindowResult = false ')")
            ]];
            local commandString = string.format(commandString, self.Text, "{center} " .. self.Title, buttons)
            Logic.ExecuteInLuaLocalState(commandString);

        end
        local result = QSB.DecisionWindowResult
        if result ~= nil then
            QSB.DecisionWindowResult = nil
            QSB.DialogActive = false;
            return result
        end
    end
end

function b_Goal_Decide:GetIcon()
    return {4,12}
end

function b_Goal_Decide:GetCustomData(_Index)
    if _Index == 2 then
        return { "Yes/No", "Ok/Cancel" }
    end
end

function b_Goal_Decide:Reset()
    self.LocalExecuted = nil;
end

Core:RegisterBehavior(b_Goal_Decide);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler kann durch regelmäßiges Begleichen eines Tributes bessere
-- Diplomatie zu einem Spieler erreichen.
--
-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die
-- Wiederholungsperiode.
--
-- <b>Hinweis</b>: Je mehr Zeit sich der Spieler lässt um den Tribut zu
-- begleichen, desto mehr wird sich der Start der nächsten Periode verzögern.
--
-- @param _Good       Warentyp
-- @param _Amount     Menge an Waren
-- @param _Periode    Zahlungsperiode in Sekunden
-- @param _Time       Zeitbegrenzung in Sekunden
-- @param _StartMsg   Vorschlagnachricht
-- @param _SuccessMsg Erfolgsnachricht
-- @param _FailureMsg Fehlschlagnachricht
-- @param _Restart    Nach nichtbezahlen neu starten
--
-- @within Goal
--
function Goal_GoodTributeDiplomacy(...)
    return b_Goal_GoodTributeDiplomacy:new(...);
end

b_Goal_GoodTributeDiplomacy = {
    Name = "Goal_GoodTributeDiplomacy",
    Description = {
        en = "Goal: AI requests periodical a tribute of the selected good type for better Diplomacy.",
        de = "Ziel: Die KI fordert einen regelmässigen Warentribut für bessere Diplomatie. Der Questgeber ist der fordernde Spieler.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Good Type", de = "Warentyp", },
        { ParameterType.Number, en = "Amount", de = "Menge", },
        { ParameterType.Number, en = "Time till next peyment in seconds", de = "Zeit bis zur Forderung in Sekunden", },
        { ParameterType.Number, en = "Time to pay tribute in seconds", de = "Zeit bis zur Zahlung in Sekunden", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },
        { ParameterType.Custom, en = "Restart if failed to pay", de = "Nicht-bezahlen beendet die Quest", },
        { ParameterType.Custom, en = "Increase/Decrease gradually ", de = "Stufenweise senken/verbessern", },
    },
}

function b_Goal_GoodTributeDiplomacy:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function b_Goal_GoodTributeDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodType = Goods[_Parameter];
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 2) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 3) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 4) then
        self.StartMsg = _Parameter;
    elseif (_Index == 5) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 6) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 7) then
        self.RestartAtFailure = AcceptAlternativeBoolean(_Parameter);
    elseif (_Index == 8) then
        self.GraduallyDiplomacy = AcceptAlternativeBoolean(_Parameter);
    end
end

function b_Goal_GoodTributeDiplomacy:GetTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = QSB.Language;
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        BundleClassicBehaviors.Global.Data.BehaviorQuestCounter = BundleClassicBehaviors.Global.Data.BehaviorQuestCounter+1;

        local QuestID, Quest = QuestTemplate:New (
            _Quest.Identifier.."_TributeDiplomacyQuest_" ..BundleClassicBehaviors.Global.Data.BehaviorQuestCounter,
            _Quest.SendingPlayer,
            _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {self.GoodType, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, nil, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function b_Goal_GoodTributeDiplomacy:CheckTributeQuest(_Quest)
    if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Over and not self.RestartQuest then
        if self.InternTributeQuest.Result ~= QuestResult.Success then
            local OldState = GetDiplomacyState(_Quest.ReceivingPlayer, _Quest.SendingPlayer);
            local NewState = (self.GraduallyDiplomacy and OldState > -2 and (OldState -1)) or -2;
            SetDiplomacyState(_Quest.ReceivingPlayer, _Quest.SendingPlayer, NewState);
            if not self.RestartAtFailure then
                return false;
            end
        else
            local OldState = GetDiplomacyState(_Quest.ReceivingPlayer, _Quest.SendingPlayer);
            local NewState = (self.GraduallyDiplomacy and OldState < 2 and (OldState +1)) or 2;
            SetDiplomacyState(_Quest.ReceivingPlayer, _Quest.SendingPlayer, NewState);
        end
        self.RestartQuest = true;
        self.Time = Logic.GetTime();
    end
end

function b_Goal_GoodTributeDiplomacy:CheckTributePlayer(_Quest)
    local storeHouse = Logic.GetStoreHouse(_Quest.SendingPlayer);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function b_Goal_GoodTributeDiplomacy:TributQuestRestarter(_Quest)
    if self.InternTributeQuest and self.Time and self.RestartQuest and ((Logic.GetTime() - self.Time) >= self.PeriodLength) then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        StartSimpleJobEx(_G[QuestTemplate.Loop], self.InternTributeQuest.QueueID);
        self.RestartQuest = nil;
    end
end

function b_Goal_GoodTributeDiplomacy:CustomFunction(_Quest)
    -- Tribut Quest erzeugen
    self:GetTributeQuest(_Quest);
    -- Status des Tributes prüfen.
    if self:CheckTributeQuest(_Quest) == false then
        return false;
    end
    -- Status des fordernden Spielers prüfen.
    if self:CheckTributePlayer(_Quest) == true then
        return true;
    end
    -- Quest neu starten, falls nötig.
    self:TributQuestRestarter(_Quest);
end

function b_Goal_GoodTributeDiplomacy:Debug(_Quest)
    if self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount is negative!");
        return true;
    end
    if not self.GoodType or self.GoodType == nil or self.GoodType == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Good type is invalid!");
        return true;
    end
    if self.PeriodLength < self.TributTime then
        error(_Quest.Identifier.. ": " ..self.Name .. ": TributTime too long!");
        return true;
    end
end

function b_Goal_GoodTributeDiplomacy:Reset(_Quest)
    self.Time = nil;
    self.InternTributeQuest = nil;
    self.RestartQuest = nil;
end

function b_Goal_GoodTributeDiplomacy:Interrupt(_Quest)
    if self.InternTributeQuest ~= nil then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt()
        end
    end
end

function b_Goal_GoodTributeDiplomacy:GetCustomData(_Index)
    if (_Index == 0) then
        return {
            "G_Beer",
            "G_Bread",
            "G_Broom",
            "G_Carcass",
            "G_Cheese",
            "G_Clothes",
            "G_Gold",
            "G_Grain",
            "G_Herb",
            "G_Honeycomb",
            "G_Iron",
            "G_Leather",
            "G_Medicine",
            "G_Milk",
            "G_RawFish",
            "G_Sausage",
            "G_SmokedFish",
            "G_Soap",
            "G_Stone",
            "G_Water",
            "G_Wood",
            "G_Wool",
        };
    end
    if (_Index == 7) or (_Index == 8) then
        return {"true", "false"};
    end
end

Core:RegisterBehavior(b_Goal_GoodTributeDiplomacy);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
b_Goal_TributeDiplomacy = API.InstanceTable(b_Goal_GoodTributeDiplomacy);
b_Goal_TributeDiplomacy.Name             = "Goal_TributeDiplomacy";
b_Goal_TributeDiplomacy.Description.de   = "Ziel: Die KI fordert einen regelmässigen Tribut für bessere Diplomatie. Der Questgeber ist der fordernde Spieler.";
b_Goal_TributeDiplomacy.Description.en   = "Goal: AI requests periodical tribute for better diplomacy.";
b_Goal_TributeDiplomacy.Parameter        = {
    { ParameterType.Number, en = "Gold Amount", de = "Goldmenge", },
    { ParameterType.Number, en = "Time till next peyment in seconds", de = "Zeit bis zur Forderung in Sekunden", },
    { ParameterType.Number, en = "Time to pay tribute in seconds", de = "Zeit bis zur Zahlung in Sekunden", },
    { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },
    { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },
    { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },
    { ParameterType.Custom, en = "Restart if failed to pay", de = "Nicht-bezahlen beendet die Quest", },
};

function b_Goal_TributeDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodType = Goods.G_Gold;
        self.Amount = _Parameter * 1;
        self.GraduallyDiplomacy = false;
    elseif (_Index == 1) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 2) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 3) then
        self.StartMsg = _Parameter;
    elseif (_Index == 4) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 5) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 6) then
        self.RestartAtFailure = AcceptAlternativeBoolean(_Parameter);
    end
end

function b_Goal_TributeDiplomacy:GetCustomData(_Index)
    if (_Index == 6) then
        return {"true", "false"};
    end
end

Core:RegisterBehavior(b_Goal_TributeDiplomacy);

-- -------------------------------------------------------------------------- --

---
-- Erlaubt es dem Spieler ein Territorium zu "mieten".
--
-- Zerstört der Spieler den Außenposten, schlägt der Quest fehl und das
-- Territorium wird an den Vermieter übergeben. Wenn der Spieler die Pacht
-- nicht bezahlt, geht der Besitz an den Vermieter über.
--
-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die
-- Wiederholungsperiode.
--
-- <b>Hinweis</b>: Je mehr Zeit sich der Spieler lässt um den Tribut zu
-- begleichen, desto mehr wird sich der Start der nächsten Periode verzögern.
--
-- @param _Territory  Name des Territorium
-- @param _PlayerID   PlayerID des Zahlungsanforderer
-- @param _Cost       Menge an Gold
-- @param _Periode    Zahlungsperiode in Sekunden
-- @param _Time       Zeitbegrenzung in Sekunden
-- @param _StartMsg   Vorschlagnachricht
-- @param _SuccessMsg Erfolgsnachricht
-- @param _FailMsg    Fehlschlagnachricht
-- @param _HowOften   Anzahl an Zahlungen (0 = endlos)
-- @param _OtherOwner Eroberung durch Dritte beendet Quest
-- @param _Abort      Nach nichtbezahlen abbrechen
--
-- @within Goal
--
function Goal_GoodTributeClaim(...)
    return b_Goal_GoodTributeClaim:new(...);
end

b_Goal_GoodTributeClaim = {
    Name = "Goal_GoodTributeClaim",
    Description = {
        en = "Goal: AI requests periodical good tribute for a specified territory. The quest sender is the demanding player.",
        de = "Ziel: Die KI fordert einen regelmässigen Warentribut für ein Territorium. Der Questgeber ist der fordernde Spieler.",
                },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", },
        { ParameterType.PlayerID, en = "PlayerID", de = "PlayerID", },
        { ParameterType.Custom, en = "Good Type", de = "Warentyp", },
        { ParameterType.Number, en = "Amount", de = "Menge", },
        { ParameterType.Number, en = "Length of Period in seconds", de = "Sekunden bis zur nächsten Forderung", },
        { ParameterType.Number, en = "Time to pay Tribut in seconds", de = "Zeit bis zur Zahlung in Sekunden", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },
        { ParameterType.Number, en = "How often to pay (0 = forerver)", de = "Anzahl der Tributquests (0 = unendlich)", },
        { ParameterType.Custom, en = "Other Owner cancels the Quest", de = "Anderer Spieler kann Quest beenden", },
        { ParameterType.Custom, en = "About if a rate is not payed", de = "Nicht-bezahlen beendet die Quest", },
    },
}

function b_Goal_GoodTributeClaim:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function b_Goal_GoodTributeClaim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        if type(_Parameter) == "string" then
            _Parameter = GetTerritoryIDByName(_Parameter);
        end
        self.TerritoryID = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        self.GoodType = Goods[_Parameter];
    elseif (_Index == 3) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 4) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 5) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 6) then
        self.StartMsg = _Parameter;
    elseif (_Index == 7) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 8) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 9) then
        self.HowOften = _Parameter * 1;
    elseif (_Index == 10) then
        self.OtherOwnerCancels = AcceptAlternativeBoolean(_Parameter);
    elseif (_Index == 11) then
        self.DontPayCancels = AcceptAlternativeBoolean(_Parameter);
    end
end

function b_Goal_GoodTributeClaim:CureOutpost(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) and GetHealth(Outpost) < 25 and Logic.IsBuildingBeingKnockedDown(Outpost) == false then
        while (Logic.GetEntityHealth(Outpost) < Logic.GetEntityMaxHealth(Outpost) * 0.6) do
            Logic.HealEntity(Outpost, 1);
        end
    end
end

function b_Goal_GoodTributeClaim:RestartTributeQuest(_Quest)
    if self.InternTributeQuest then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        self.InternTributeQuest.NotPayed = nil;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        StartSimpleJobEx(_G[QuestTemplate.Loop], self.InternTributeQuest.QueueID);
    end
end

function b_Goal_GoodTributeClaim:CreateTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = QSB.Language;
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        BundleClassicBehaviors.Global.Data.BehaviorQuestCounter = BundleClassicBehaviors.Global.Data.BehaviorQuestCounter+1;

        local OnFinished = function()
            self.Time = Logic.GetTime();
        end
        local QuestID, Quest = QuestTemplate:New(
            _Quest.Identifier.."_TributeClaimQuest" ..BundleClassicBehaviors.Global.Data.BehaviorQuestCounter,
            self.PlayerID,
            _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {self.GoodType, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, OnFinished, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function b_Goal_GoodTributeClaim:OnTributeFailed(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) then
        Logic.ChangeEntityPlayerID(Outpost, self.PlayerID);
    end
    Logic.SetTerritoryPlayerID(self.TerritoryID, self.PlayerID);
    self.InternTributeQuest.NotPayed = false;
    self.Time = nil;

    if self.DontPayCancels then
        _Quest:Interrupt();
    end
end

function b_Goal_GoodTributeClaim:OnTributePaid(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if self.InternTributeQuest.Result == QuestResult.Success then
        if Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
            if IsExisting(Outpost) then
                Logic.ChangeEntityPlayerID(Outpost, _Quest.ReceivingPlayer);
            end
            Logic.SetTerritoryPlayerID(self.TerritoryID, _Quest.ReceivingPlayer);
        end
    end
    if self.Time and Logic.GetTime() >= self.Time + self.PeriodLength then
        if self.HowOften and self.HowOften ~= 0 then
            self.TributeCounter = (self.TributeCounter or 0) +1;
            if self.TributeCounter >= self.HowOften then
                return false;
            end
        end
        self:RestartTributeQuest();
        self.Time = nil;
    end
end

function b_Goal_GoodTributeClaim:CustomFunction(_Quest)
    self:CreateTributeQuest(_Quest);
    self:CureOutpost(_Quest);

    if Logic.GetTerritoryPlayerID(self.TerritoryID) == _Quest.ReceivingPlayer
    or Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
        if self.OtherOwner then
            self:RestartTributeQuest();
            self.OtherOwner = nil;
        end

        -- Quest abgeschlossen
        if self.InternTributeQuest.State == QuestState.Over then
            if self.InternTributeQuest.Result == QuestResult.Failure then
                self:OnTributeFailed(_Quest);
            else
                self:OnTributePaid(_Quest);
            end

        elseif self.InternTributeQuest.NotPayed == false then
            if self.Time and Logic.GetTime() >= self.Time + self.PeriodLength then
                self:RestartTributeQuest(_Quest);
            end
        end

    -- Keiner besitzt das Territorium -> Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) == 0 and self.InternTributeQuest then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end

    -- Anderer Besitzer -> Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) ~= self.PlayerID then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        if self.OtherOwnerCancels then
            _Quest:Interrupt();
        end
        self.OtherOwner = true;
    end

    --Fordernder Spieler existiert nicht -> Abbruch
    local storeHouse = Logic.GetStoreHouse(self.PlayerID);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function b_Goal_GoodTributeClaim:Debug(_Quest)
    if self.TerritoryID == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Unknown Territory");
        return true;
    end
    if not self.GoodType or self.GoodType == nil or self.GoodType == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Good type is invalid!");
        return true;
    end
    if not self.Quest and Logic.GetStoreHouse(self.PlayerID) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(");
        return true;
    end
    if self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount is negative");
        return true;
    end
    if self.PeriodLength < self.TributTime or self.PeriodLength < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Period Length is wrong");
        return true;
    end
    if self.HowOften < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": HowOften is negative");
        return true;
    end
end

function b_Goal_GoodTributeClaim:Reset(_Quest)
    self.InternTributeQuest = nil;
    self.Time = nil;
    self.OtherOwner = nil;
end

function b_Goal_GoodTributeClaim:Interrupt(_Quest)
    if type(self.InternTributeQuest) == "table" then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
    end
end

function b_Goal_GoodTributeClaim:GetCustomData(_Index)
    if (_Index == 2) then
        return {
            "G_Beer",
            "G_Bread",
            "G_Broom",
            "G_Carcass",
            "G_Cheese",
            "G_Clothes",
            "G_Gold",
            "G_Grain",
            "G_Herb",
            "G_Honeycomb",
            "G_Iron",
            "G_Leather",
            "G_Medicine",
            "G_Milk",
            "G_RawFish",
            "G_Sausage",
            "G_SmokedFish",
            "G_Soap",
            "G_Stone",
            "G_Water",
            "G_Wood",
            "G_Wool",
        };
    end
    if (_Index == 10) or (_Index == 11) then
        return {"false", "true"};
    end
end

Core:RegisterBehavior(b_Goal_GoodTributeClaim);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
b_Goal_TributeClaim = API.InstanceTable(b_Goal_GoodTributeClaim);
b_Goal_TributeClaim.Name             = "Goal_TributeClaim";
b_Goal_TributeClaim.Description.de   = "Ziel: Die KI fordert einen regelmässigen Tribut für bessere Diplomatie. Der Questgeber ist der fordernde Spieler.";
b_Goal_TributeClaim.Description.en   = "Goal: AI requests periodical tribute for better diplomacy.";
b_Goal_TributeClaim.Parameter        = {
    { ParameterType.TerritoryName, en = "Territory", de = "Territorium", },
    { ParameterType.PlayerID, en = "PlayerID", de = "PlayerID", },
    { ParameterType.Number, en = "Amount", de = "Menge", },
    { ParameterType.Number, en = "Length of Period in seconds", de = "Sekunden bis zur nächsten Forderung", },
    { ParameterType.Number, en = "Time to pay Tribut in seconds", de = "Zeit bis zur Zahlung in Sekunden", },
    { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },
    { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },
    { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },
    { ParameterType.Number, en = "How often to pay (0 = forerver)", de = "Anzahl der Tributquests (0 = unendlich)", },
    { ParameterType.Custom, en = "Other Owner cancels the Quest", de = "Anderer Spieler kann Quest beenden", },
    { ParameterType.Custom, en = "About if a rate is not payed", de = "Nicht-bezahlen beendet die Quest", },
};

function b_Goal_TributeClaim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        if type(_Parameter) == "string" then
            _Parameter = GetTerritoryIDByName(_Parameter);
        end
        self.TerritoryID = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        self.GoodType = Goods.G_Gold;
        self.Amount = _Parameter * 1;
    elseif (_Index == 3) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 4) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 5) then
        self.StartMsg = _Parameter;
    elseif (_Index == 6) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 7) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 8) then
        self.HowOften = _Parameter * 1;
    elseif (_Index == 9) then
        self.OtherOwnerCancels = AcceptAlternativeBoolean(_Parameter);
    elseif (_Index == 10) then
        self.DontPayCancels = AcceptAlternativeBoolean(_Parameter);
    end
end

function b_Goal_TributeClaim:GetCustomData(_Index)
    if (_Index == 9) or (_Index == 10) then
        return {"false", "true"};
    end
end

Core:RegisterBehavior(b_Goal_TributeClaim);

-- -------------------------------------------------------------------------- --
-- Reprisal                                                                   --
-- -------------------------------------------------------------------------- --

---
-- Deaktiviert ein interaktives Objekt.
--
-- @param _ScriptName Skriptname des interaktiven Objektes
--
-- @within Reprisal
--
function Reprisal_ObjectDeactivate(...)
    return b_Reprisal_InteractiveObjectDeactivate:new(...);
end

b_Reprisal_InteractiveObjectDeactivate = {
    Name = "Reprisal_InteractiveObjectDeactivate",
    Description = {
        en = "Reprisal: Deactivates an interactive object",
        de = "Vergeltung: Deaktiviert ein interaktives Objekt",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt" },
    },
}

function b_Reprisal_InteractiveObjectDeactivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_InteractiveObjectDeactivate:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    end

end

function b_Reprisal_InteractiveObjectDeactivate:CustomFunction(_Quest)
    InteractiveObjectDeactivate(self.ScriptName);
end

function b_Reprisal_InteractiveObjectDeactivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn(_Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then
        error(_Quest.Identifier.. ": " ..self.Name..": you can not deactivate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_InteractiveObjectDeactivate);

-- -------------------------------------------------------------------------- --

---
-- Aktiviert ein interaktives Objekt.
--
-- Der Status bestimmt, wie das Objekt aktiviert wird.
-- <ul>
-- <li>0: Kann nur mit Helden aktiviert werden</li>
-- <li>1: Kann immer aktiviert werden</li>
-- <li>2: Kann niemals aktiviert werden</li>
-- </ul>
--
-- @param _ScriptName Skriptname des interaktiven Objektes
-- @param _State      Status des Objektes
--
-- @within Reprisal
--
function Reprisal_ObjectActivate(...)
    return b_Reprisal_InteractiveObjectActivate:new(...);
end

b_Reprisal_InteractiveObjectActivate = {
    Name = "Reprisal_InteractiveObjectActivate",
    Description = {
        en = "Reprisal: Activates an interactive object",
        de = "Vergeltung: Aktiviert ein interaktives Objekt",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object",  de = "Interaktives Objekt" },
        { ParameterType.Custom,     en = "Availability",         de = "Nutzbarkeit" },
    },
}

function b_Reprisal_InteractiveObjectActivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_InteractiveObjectActivate:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        local parameter = 0
        if _Parameter == "Always" or 1 then
            parameter = 1
        end
        self.UsingState = parameter * 1
    end
end

function b_Reprisal_InteractiveObjectActivate:CustomFunction(_Quest)
    InteractiveObjectActivate(self.ScriptName, self.UsingState);
end

function b_Reprisal_InteractiveObjectActivate:GetCustomData( _Index )
    if _Index == 1 then
        return {"Knight only", "Always"}
    end
end

function b_Reprisal_InteractiveObjectActivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn(_Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then
        error(_Quest.Identifier.. ": " ..self.Name..": you can not activate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_InteractiveObjectActivate);

-- -------------------------------------------------------------------------- --

---
-- Der diplomatische Status zwischen Sender und Empfänger verschlechtert sich
-- um eine Stufe.
--
-- @within Reprisal
--
function Reprisal_DiplomacyDecrease()
    return b_Reprisal_SlightlyDiplomacyDecrease:new();
end

b_Reprisal_SlightlyDiplomacyDecrease = {
    Name = "Reprisal_SlightlyDiplomacyDecrease",
    Description = {
        en = "Reprisal: Diplomacy decreases slightly to another player.",
        de = "Vergeltung: Der Diplomatiestatus zum Auftraggeber wird um eine Stufe verringert.",
    },
}

function b_Reprisal_SlightlyDiplomacyDecrease:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_SlightlyDiplomacyDecrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State > -2 then
        SetDiplomacyState(Receiver, Sender, State-1);
    end
end

function b_Reprisal_SlightlyDiplomacyDecrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

Core:RegisterBehavior(b_Reprisal_SlightlyDiplomacyDecrease);

-- -------------------------------------------------------------------------- --

---
-- Änder den Diplomatiestatus zwischen zwei Spielern.
--
-- @param _Party1   ID der ersten Partei
-- @param _Party2   ID der zweiten Partei
-- @param _State    Neuer Diplomatiestatus
--
-- @within Reprisal
--
function Reprisal_Diplomacy(...)
    return b_Reprisal_Diplomacy:new(...);
end

b_Reprisal_Diplomacy = {
    Name = "Reprisal_Diplomacy",
    Description = {
        en = "Reprisal: Sets Diplomacy state of two Players to a stated value.",
        de = "Vergeltung: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.",
    },
    Parameter = {
        { ParameterType.PlayerID,         en = "PlayerID 1", de = "Spieler 1" },
        { ParameterType.PlayerID,         en = "PlayerID 2", de = "Spieler 2" },
        { ParameterType.DiplomacyState,   en = "Relation",   de = "Beziehung" },
    },
}

function b_Reprisal_Diplomacy:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID1 = _Parameter * 1
    elseif (_Index == 1) then
        self.PlayerID2 = _Parameter * 1
    elseif (_Index == 2) then
        self.Relation = DiplomacyStates[_Parameter]
    end
end

function b_Reprisal_Diplomacy:CustomFunction(_Quest)
    SetDiplomacyState(self.PlayerID1, self.PlayerID2, self.Relation);
end

function b_Reprisal_Diplomacy:Debug(_Quest)
    if not tonumber(self.PlayerID1) or self.PlayerID1 < 1 or self.PlayerID1 > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": PlayerID 1 is invalid!");
        return true;
    elseif not tonumber(self.PlayerID2) or self.PlayerID2 < 1 or self.PlayerID2 > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": PlayerID 2 is invalid!");
        return true;
    elseif not tonumber(self.Relation) or self.Relation < -2 or self.Relation > 2 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": '"..self.Relation.."' is a invalid diplomacy state!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_Diplomacy);

-- -------------------------------------------------------------------------- --

---
-- Ein benanntes Entity wird entfernt.
--
-- <b>Hinweis</b>: Das Entity wird durch ein XD_ScriptEntity ersetzt. Es
-- behält Name, Besitzer und Ausrichtung.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Reprisal
--
function Reprisal_DestroyEntity(...)
    return b_Reprisal_DestroyEntity:new(...);
end

b_Reprisal_DestroyEntity = {
    Name = "Reprisal_DestroyEntity",
    Description = {
        en = "Reprisal: Replaces an entity with an invisible script entity, which retains the entities name.",
        de = "Vergeltung: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity", de = "Entity" },
    },
}

function b_Reprisal_DestroyEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_DestroyEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Reprisal_DestroyEntity:CustomFunction(_Quest)
    ReplaceEntity(self.ScriptName, Entities.XD_ScriptEntity);
end

function b_Reprisal_DestroyEntity:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        warn(_Quest.Identifier .. ": " ..self.Name..": '" ..self.ScriptName.. "' is already destroyed!");
        self.WarningPrinted = true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_DestroyEntity);

-- -------------------------------------------------------------------------- --

---
-- Zerstört einen über ein Behavior erzeugten Effekt.
--
-- @param _EffectName Name des Effekts
--
-- @within Reprisal
--
function Reprisal_DestroyEffect(...)
    return b_Reprisal_DestroyEffect:new(...);
end

b_Reprisal_DestroyEffect = {
    Name = "Reprisal_DestroyEffect",
    Description = {
        en = "Reprisal: Destroys an effect",
        de = "Vergeltung: Zerstört einen Effekt",
    },
    Parameter = {
        { ParameterType.Default, en = "Effect name", de = "Effektname" },
    }
}

function b_Reprisal_DestroyEffect:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.EffectName = _Parameter;
    end
end

function b_Reprisal_DestroyEffect:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } };
end

function b_Reprisal_DestroyEffect:CustomFunction(_Quest)
    if not QSB.EffectNameToID[self.EffectName] or not Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then
        return;
    end
    Logic.DestroyEffect(QSB.EffectNameToID[self.EffectName]);
end

function b_Reprisal_DestroyEffect:Debug(_Quest)
    if not QSB.EffectNameToID[self.EffectName] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Effect " .. self.EffectName .. " never created")
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_DestroyEffect);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler verliert das Spiel.
--
-- @within Reprisal
--
function Reprisal_Defeat()
    return b_Reprisal_Defeat:new()
end

b_Reprisal_Defeat = {
    Name = "Reprisal_Defeat",
    Description = {
        en = "Reprisal: The player loses the game.",
        de = "Vergeltung: Der Spieler verliert das Spiel.",
    },
}

function b_Reprisal_Defeat:GetReprisalTable()
    return {Reprisal.Defeat};
end

Core:RegisterBehavior(b_Reprisal_Defeat);

-- -------------------------------------------------------------------------- --

---
-- Zeigt die Niederlagedekoration am Quest an.
--
-- Es handelt sich dabei um reine Optik! Der Spieler wird nicht verlieren.
--
-- @within Reprisal
--
function Reprisal_FakeDefeat()
    return b_Reprisal_FakeDefeat:new();
end

b_Reprisal_FakeDefeat = {
    Name = "Reprisal_FakeDefeat",
    Description = {
        en = "Reprisal: Displays a defeat icon for a quest",
        de = "Vergeltung: Zeigt ein Niederlage Icon für eine Quest an",
    },
}

function b_Reprisal_FakeDefeat:GetReprisalTable()
    return { Reprisal.FakeDefeat }
end

Core:RegisterBehavior(b_Reprisal_FakeDefeat);

-- -------------------------------------------------------------------------- --

---
-- Ein Entity wird durch ein neues anderen Typs ersetzt.
--
-- Das neue Entity übernimmt Skriptname, Besitzer  und Ausrichtung des 
-- alten Entity.
--
-- @param _Entity Skriptname oder ID des Entity
-- @param _Type   Neuer Typ des Entity
-- @param _Owner  Besitzer des Entity
--
-- @within Reprisal
--
function Reprisal_ReplaceEntity(...)
    return b_Reprisal_ReplaceEntity:new(...);
end

b_Reprisal_ReplaceEntity = {
    Name = "Reprisal_ReplaceEntity",
    Description = {
        en = "Reprisal: Replaces an entity with a new one of a different type. The playerID can be changed too.",
        de = "Vergeltung: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target", de = "Ziel" },
        { ParameterType.Custom, en = "New Type", de = "Neuer Typ" },
        { ParameterType.Custom, en = "New playerID", de = "Neue Spieler ID" },
    },
}

function b_Reprisal_ReplaceEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_ReplaceEntity:AddParameter(_Index, _Parameter)
   if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.NewType = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = tonumber(_Parameter);
    end
end

function b_Reprisal_ReplaceEntity:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    local pID = self.PlayerID;
    if pID == Logic.EntityGetPlayer(eID) then
        pID = nil;
    end
    ReplaceEntity(self.ScriptName, Entities[self.NewType], pID);
end

function b_Reprisal_ReplaceEntity:GetCustomData(_Index)
    local Data = {}
    if _Index == 1 then
        for k, v in pairs( Entities ) do
            local name = {"^M_","^XS_","^X_","^XT_","^Z_", "^XB_"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        Data = {"-","0","1","2","3","4","5","6","7","8",}
    end
    return Data
end

function b_Reprisal_ReplaceEntity:Debug(_Quest)
    if not Entities[self.NewType] then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid entity type!");
        return true;
    elseif self.PlayerID ~= nil and (self.PlayerID < 1 or self.PlayerID > 8) then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end

    if not IsExisting(self.ScriptName) then
        self.WarningPrinted = true;
        warn(_Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' does not exist!");
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_ReplaceEntity);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest neu.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestRestart(...)
    return b_Reprisal_QuestRestart:new(...)
end

b_Reprisal_QuestRestart = {
    Name = "Reprisal_QuestRestart",
    Description = {
        en = "Reprisal: Restarts a (completed) quest so it can be triggered and completed again",
        de = "Vergeltung: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reprisal_QuestRestart:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_QuestRestart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Reprisal_QuestRestart:CustomFunction(_Quest)
    RestartQuestByName(self.QuestName, true);
end

function b_Reprisal_QuestRestart:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestRestart);

-- -------------------------------------------------------------------------- --

---
-- Lässt einen Quest fehlschlagen.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestFailure(...)
    return b_Reprisal_QuestFailure:new(...)
end

b_Reprisal_QuestFailure = {
    Name = "Reprisal_QuestFailure",
    Description = {
        en = "Reprisal: Lets another active quest fail",
        de = "Vergeltung: Lässt eine andere aktive Quest fehlschlagen",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reprisal_QuestFailure:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_QuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Reprisal_QuestFailure:CustomFunction(_Quest)
    FailQuestByName(self.QuestName, true);
end

function b_Reprisal_QuestFailure:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid quest!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Wertet einen Quest als erfolgreich.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestSuccess(...)
    return b_Reprisal_QuestSuccess:new(...)
end

b_Reprisal_QuestSuccess = {
    Name = "Reprisal_QuestSuccess",
    Description = {
        en = "Reprisal: Completes another active quest successfully",
        de = "Vergeltung: Beendet eine andere aktive Quest erfolgreich",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reprisal_QuestSuccess:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_QuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Reprisal_QuestSuccess:CustomFunction(_Quest)
    WinQuestByName(self.QuestName, true);
end

function b_Reprisal_QuestSuccess:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Triggert einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestActivate(...)
    return b_Reprisal_QuestActivate:new(...)
end

b_Reprisal_QuestActivate = {
    Name = "Reprisal_QuestActivate",
    Description = {
        en = "Reprisal: Activates another quest that is not triggered yet.",
        de = "Vergeltung: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.",
                },
    Parameter = {
        {ParameterType.QuestName, en = "Quest name", de = "Questname", },
    },
}

function b_Reprisal_QuestActivate:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction} }
end

function b_Reprisal_QuestActivate:AddParameter(_Index, _Parameter)
    if (_Index==0) then
        self.QuestName = _Parameter
    else
        assert(false, "Error in " .. self.Name .. ": AddParameter: Index is invalid")
    end
end

function b_Reprisal_QuestActivate:CustomFunction(_Quest)
    StartQuestByName(self.QuestName, true);
end

function b_Reprisal_QuestActivate:Debug(_Quest)
    if not IsValidQuest(self.QuestName) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestActivate)

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestInterrupt(...)
    return b_Reprisal_QuestInterrupt:new(...)
end

b_Reprisal_QuestInterrupt = {
    Name = "Reprisal_QuestInterrupt",
    Description = {
        en = "Reprisal: Interrupts another active quest without success or failure",
        de = "Vergeltung: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reprisal_QuestInterrupt:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_QuestInterrupt:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Reprisal_QuestInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if Quest.State == QuestState.Active then
            StopQuestByName(self.QuestName, true);
        end
    end
end

function b_Reprisal_QuestInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.
--
-- @param _QuestName   Name des Quest
-- @param _EndetQuests Bereits beendete unterbrechen
--
-- @within Reprisal
--
function Reprisal_QuestForceInterrupt(...)
    return b_Reprisal_QuestForceInterrupt:new(...)
end

b_Reprisal_QuestForceInterrupt = {
    Name = "Reprisal_QuestForceInterrupt",
    Description = {
        en = "Reprisal: Interrupts another quest (even when it isn't active yet) without success or failure",
        de = "Vergeltung: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
        { ParameterType.Custom, en = "Ended quests", de = "Beendete Quests" },
    },
}

function b_Reprisal_QuestForceInterrupt:GetReprisalTable()

    return { Reprisal.Custom,{self, self.CustomFunction} }

end

function b_Reprisal_QuestForceInterrupt:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.InterruptEnded = AcceptAlternativeBoolean(_Parameter)
    end

end

function b_Reprisal_QuestForceInterrupt:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end
function b_Reprisal_QuestForceInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if self.InterruptEnded or Quest.State ~= QuestState.Over then
            Quest:Interrupt()
        end
    end
end

function b_Reprisal_QuestForceInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Wert einer benutzerdefinierten Variable.
--
-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein. Nutze
-- dieses Behavior bevor die Variable in einem Goal oder Trigger abgefragt
-- wird, um sie zu initialisieren!
--
-- <p>Operatoren</p>
-- <ul>
-- <li>= - Variablenwert wird auf den Wert gesetzt</li>
-- <li>- - Variablenwert mit Wert Subtrahieren</li>
-- <li>+ - Variablenwert mit Wert addieren</li>
-- <li>* - Variablenwert mit Wert multiplizieren</li>
-- <li>/ - Variablenwert mit Wert dividieren</li>
-- <li>^ - Variablenwert mit Wert potenzieren</li>
-- </ul>
--
-- @param _Name     Name der Variable
-- @param _Operator Rechen- oder Zuweisungsoperator
-- @param _Value    Wert oder andere Custom Variable
--
-- @within Reprisal
--
function Reprisal_CustomVariables(...)
    return b_Reprisal_CustomVariables:new(...);
end

b_Reprisal_CustomVariables = {
    Name = "Reprisal_CustomVariables",
    Description = {
        en = "Reprisal: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.",
        de = "Vergeltung: Fuehrt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of variable", de = "Variablenname" },
        { ParameterType.Custom,  en = "Operator", de = "Operator" },
        { ParameterType.Default,  en = "Value or variable", de = "Wert oder Variable" }
    }
};

function b_Reprisal_CustomVariables:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} };
end

function b_Reprisal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Operator = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        value = (value ~= nil and value) or tostring(_Parameter);
        self.Value = value
    end
end

function b_Reprisal_CustomVariables:CustomFunction()
    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;
    local oldValue = _G["QSB_CustomVariables_"..self.VariableName];

    if self.Operator == "=" then
        _G["QSB_CustomVariables_"..self.VariableName] = (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "+" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue + (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "-" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue - (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "*" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue * (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "/" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue / (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "^" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue ^ (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];

    end
end

function b_Reprisal_CustomVariables:GetCustomData( _Index )
    return {"=", "+", "-", "*", "/", "^"};
end

function b_Reprisal_CustomVariables:Debug(_Quest)
    local operators = {"=", "+", "-", "*", "/", "^"};
    if not Inside(self.Operator,operators) then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid operator!");
        return true;
    elseif self.VariableName == "" then
        error(_Quest.Identifier.. ": " ..self.Name..": missing name for variable!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Reprisal aus.
--
-- Wird ein Funktionsname als String übergeben, wird die Funktion mit den
-- Daten des Behavors und des zugehörigen Quest aufgerufen (Standard).
--
-- Wird eine Funktionsreferenz angegeben, wird die Funktion zusammen mit allen
-- optionalen Parametern aufgerufen, als sei es ein gewöhnlicher Aufruf im
-- Skript.
-- <pre> Reprisal_MapScriptFunction(ReplaceEntity, "block", Entities.XD_ScriptEntity);
-- -- entspricht: ReplaceEntity("block", Entities.XD_ScriptEntity);</pre>
-- <b>Achtung:</b> Nicht über den Assistenten verfügbar!
--
-- @param _Function Name der Funktion oder Funktionsreferenz
--
-- @within Reprisal
--
function Reprisal_MapScriptFunction(...)
    return b_Reprisal_MapScriptFunction:new(...);
end

b_Reprisal_MapScriptFunction = {
    Name = "Reprisal_MapScriptFunction",
    Description = {
        en = "Reprisal: Calls a function within the global map script if the quest has failed.",
        de = "Vergeltung: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname" },
    },
}

function b_Reprisal_MapScriptFunction:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction}};
end

function b_Reprisal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.FuncName = _Parameter;
    end
end

function b_Reprisal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        self.FuncName(unpack(self.i47ya_6aghw_frxil));
        return;
    end
    _G[self.FuncName](self, _Quest);
end

function b_Reprisal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        error(_Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        error(_Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

---
-- Erlaubt oder verbietet einem Spieler ein Recht.
--
-- @param _PlayerID   ID des Spielers
-- @param _Lock       Sperren/Entsperren
-- @param _Technology Name des Rechts
--
-- @within Reprisal
--
function Reprisal_Technology(...)
    return b_Reprisal_Technology:new(...);
end

b_Reprisal_Technology = {
    Name = "Reprisal_Technology",
    Description = {
        en = "Reprisal: Locks or unlocks a technology for the given player",
        de = "Vergeltung: Sperrt oder erlaubt eine Technolgie für den angegebenen Player",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "PlayerID", de = "SpielerID" },
        { ParameterType.Custom,   en = "Un / Lock", de = "Sperren/Erlauben" },
        { ParameterType.Custom,   en = "Technology", de = "Technologie" },
    },
}

function b_Reprisal_Technology:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} }
end

function b_Reprisal_Technology:AddParameter(_Index, _Parameter)
    if (_Index ==0) then
        self.PlayerID = _Parameter*1
    elseif (_Index == 1) then
        self.LockType = _Parameter == "Lock"
    elseif (_Index == 2) then
        self.Technology = _Parameter
    end
end

function b_Reprisal_Technology:CustomFunction(_Quest)
    if self.PlayerID
    and Logic.GetStoreHouse(self.PlayerID) ~= 0
    and Technologies[self.Technology]
    then
        if self.LockType  then
            LockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        else
            UnLockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        end
    else
        return false
    end
end

function b_Reprisal_Technology:GetCustomData(_Index)
    local Data = {}
    if (_Index == 1) then
        Data[1] = "Lock"
        Data[2] = "UnLock"
    elseif (_Index == 2) then
        for k, v in pairs( Technologies ) do
            table.insert( Data, k )
        end
    end
    return Data
end

function b_Reprisal_Technology:Debug(_Quest)
    if not Technologies[self.Technology] then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid technology type!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_Technology);

-- -------------------------------------------------------------------------- --
-- Rewards                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Deaktiviert ein interaktives Objekt
--
-- @param _ScriptName Skriptname des interaktiven Objektes
--
-- @within Reward
--
function Reward_ObjectDeactivate(...)
    return b_Reward_InteractiveObjectDeactivate:new(...);
end

b_Reward_InteractiveObjectDeactivate = API.InstanceTable(b_Reprisal_InteractiveObjectDeactivate);
b_Reward_InteractiveObjectDeactivate.Name             = "Reward_InteractiveObjectDeactivate";
b_Reward_InteractiveObjectDeactivate.Description.de   = "Reward: Deactivates an interactive object";
b_Reward_InteractiveObjectDeactivate.Description.en   = "Lohn: Deaktiviert ein interaktives Objekt";
b_Reward_InteractiveObjectDeactivate.GetReprisalTable = nil;

b_Reward_InteractiveObjectDeactivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_InteractiveObjectDeactivate);

-- -------------------------------------------------------------------------- --

---
-- Aktiviert ein interaktives Objekt.
--
-- Der Status bestimmt, wie das objekt aktiviert wird.
-- <ul>
-- <li>0: Kann nur mit Helden aktiviert werden</li>
-- <li>1: Kann immer aktiviert werden</li>
-- <li>2: Kann niemals aktiviert werden</li>
-- </ul>
--
-- @param _ScriptName Skriptname des interaktiven Objektes
-- @param _State Status des Objektes
--
-- @within Reward
--
function Reward_ObjectActivate(...)
    return b_Reward_InteractiveObjectActivate:new(...);
end

b_Reward_InteractiveObjectActivate = API.InstanceTable(b_Reprisal_InteractiveObjectActivate);
b_Reward_InteractiveObjectActivate.Name             = "Reward_InteractiveObjectActivate";
b_Reward_InteractiveObjectActivate.Description.de   = "Reward: Activates an interactive object";
b_Reward_InteractiveObjectActivate.Description.en   = "Lohn: Aktiviert ein interaktives Objekt";
b_Reward_InteractiveObjectActivate.GetReprisalTable = nil;

b_Reward_InteractiveObjectActivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} };
end

Core:RegisterBehavior(b_Reward_InteractiveObjectActivate);

-- -------------------------------------------------------------------------- --

---
-- Initialisiert ein interaktives Objekt.
--
-- Interaktive Objekte können Kosten und Belohnungen enthalten, müssen sie
-- jedoch nicht. Ist eine Wartezeit angegeben, kann das Objekt erst nach
-- Ablauf eines Cooldowns benutzt werden.
--
-- @param _ScriptName Skriptname des interaktiven Objektes
-- @param _Distance   Entfernung zur Aktivierung
-- @param _Time       Wartezeit bis zur Aktivierung
-- @param _RType1     Warentyp der Belohnung
-- @param _RAmount    Menge der Belohnung
-- @param _CType1     Typ der 1. Ware
-- @param _CAmount1   Menge der 1. Ware
-- @param _CType2     Typ der 2. Ware
-- @param _CAmount2   Menge der 2. Ware
-- @param _Status     Aktivierung (0: Held, 1: immer, 2: niemals)
--
-- @within Reward
--
function Reward_ObjectInit(...)
    return b_Reward_ObjectInit:new(...);
end

b_Reward_ObjectInit = {
    Name = "Reward_ObjectInit",
    Description = {
        en = "Reward: Setup an interactive object with costs and rewards.",
        de = "Lohn: Initialisiert ein interaktives Objekt mit seinen Kosten und Schätzen.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object",     de = "Interaktives Objekt" },
        { ParameterType.Number,     en = "Distance to use",     de = "Nutzungsentfernung" },
        { ParameterType.Number,     en = "Waittime",             de = "Wartezeit" },
        { ParameterType.Custom,     en = "Reward good",         de = "Belohnungsware" },
        { ParameterType.Number,     en = "Reward amount",         de = "Anzahl" },
        { ParameterType.Custom,     en = "Cost good 1",         de = "Kostenware 1" },
        { ParameterType.Number,     en = "Cost amount 1",         de = "Anzahl 1" },
        { ParameterType.Custom,     en = "Cost good 2",         de = "Kostenware 2" },
        { ParameterType.Number,     en = "Cost amount 2",         de = "Anzahl 2" },
        { ParameterType.Custom,     en = "Availability",         de = "Verfügbarkeit" },
    },
}

function b_Reward_ObjectInit:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_ObjectInit:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Distance = _Parameter * 1
    elseif (_Index == 2) then
        self.Waittime = _Parameter * 1
    elseif (_Index == 3) then
        self.RewardType = _Parameter
    elseif (_Index == 4) then
        self.RewardAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.FirstCostType = _Parameter
    elseif (_Index == 6) then
        self.FirstCostAmount = _Parameter * 1
    elseif (_Index == 7) then
        self.SecondCostType = _Parameter
    elseif (_Index == 8) then
        self.SecondCostAmount = _Parameter * 1
    elseif (_Index == 9) then
        local parameter = nil
        if _Parameter == "Always" or _Parameter == 1 then
            parameter = 1
        elseif _Parameter == "Never" or _Parameter == 2 then
            parameter = 2
        elseif _Parameter == "Knight only" or _Parameter == 0 then
            parameter = 0
        end
        self.UsingState = parameter
    end
end

function b_Reward_ObjectInit:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    if eID == 0 then
        return;
    end
    QSB.InitalizedObjekts[eID] = _Quest.Identifier;

    Logic.InteractiveObjectClearCosts(eID);
    Logic.InteractiveObjectClearRewards(eID);

    Logic.InteractiveObjectSetInteractionDistance(eID, self.Distance);
    Logic.InteractiveObjectSetTimeToOpen(eID, self.Waittime);

    if self.RewardType and self.RewardType ~= "-" then
        Logic.InteractiveObjectAddRewards(eID, Goods[self.RewardType], self.RewardAmount);
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.FirstCostType], self.FirstCostAmount);
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.SecondCostType], self.SecondCostAmount);
    end

    Logic.InteractiveObjectSetAvailability(eID,true);
    if self.UsingState then
        for i=1, 8 do
            Logic.InteractiveObjectSetPlayerState(eID,i, self.UsingState);
        end
    end

    Logic.InteractiveObjectSetRewardResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetRewardGoldCartType(eID,Entities.U_GoldCart);
    Logic.InteractiveObjectSetCostResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetCostGoldCartType(eID, Entities.U_GoldCart);
    RemoveInteractiveObjectFromOpenedList(eID);
    table.insert(HiddenTreasures,eID);
end

function b_Reward_ObjectInit:GetCustomData( _Index )
    if _Index == 3 or _Index == 5 or _Index == 7 then
        local Data = {
            "-",
            "G_Beer",
            "G_Bread",
            "G_Broom",
            "G_Carcass",
            "G_Cheese",
            "G_Clothes",
            "G_Dye",
            "G_Gold",
            "G_Grain",
            "G_Herb",
            "G_Honeycomb",
            "G_Iron",
            "G_Leather",
            "G_Medicine",
            "G_Milk",
            "G_RawFish",
            "G_Salt",
            "G_Sausage",
            "G_SmokedFish",
            "G_Soap",
            "G_Stone",
            "G_Water",
            "G_Wood",
            "G_Wool",
        }

        if g_GameExtraNo >= 1 then
            Data[#Data+1] = "G_Gems"
            Data[#Data+1] = "G_MusicalInstrument"
            Data[#Data+1] = "G_Olibanum"
        end
        return Data
    elseif _Index == 9 then
        return {"-", "Knight only", "Always", "Never",}
    end
end

function b_Reward_ObjectInit:Debug(_Quest)
    if Logic.IsInteractiveObject(GetID(self.ScriptName)) == false then
        error(_Quest.Identifier.. ": " ..self.Name..": '"..self.ScriptName.."' is not a interactive object!");
        return true;
    end
    if self.UsingState ~= 1 and self.Distance < 50 then
        warn(_Quest.Identifier.. ": " ..self.Name..": distance is maybe too short!");
    end
    if self.Waittime < 0 then
        error(_Quest.Identifier.. ": " ..self.Name..": waittime must be equal or greater than 0!");
        return true;
    end
    if self.RewardType and self.RewardType ~= "-" then
        if not Goods[self.RewardType] then
            error(_Quest.Identifier.. ": " ..self.Name..": '"..self.RewardType.."' is invalid good type!");
            return true;
        elseif self.RewardAmount < 1 then
            error(_Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        if not Goods[self.FirstCostType] then
            error(_Quest.Identifier.. ": " ..self.Name..": '"..self.FirstCostType.."' is invalid good type!");
            return true;
        elseif self.FirstCostAmount < 1 then
            error(_Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        if not Goods[self.SecondCostType] then
            error(_Quest.Identifier.. ": " ..self.Name..": '"..self.SecondCostType.."' is invalid good type!");
            return true;
        elseif self.SecondCostAmount < 1 then
            error(_Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    return false;
end

Core:RegisterBehavior(b_Reward_ObjectInit);

-- -------------------------------------------------------------------------- --

---
-- Änder den Diplomatiestatus zwischen zwei Spielern.
--
-- @param _Party1   ID der ersten Partei
-- @param _Party2   ID der zweiten Partei
-- @param _State    Neuer Diplomatiestatus
--
-- @within Reward
--
function Reward_Diplomacy(...)
    return b_Reward_Diplomacy:new(...);
end

b_Reward_Diplomacy = API.InstanceTable(b_Reprisal_Diplomacy);
b_Reward_Diplomacy.Name             = "Reward_Diplomacy";
b_Reward_Diplomacy.Description.de   = "Reward: Sets Diplomacy state of two Players to a stated value.";
b_Reward_Diplomacy.Description.en   = "Lohn: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.";
b_Reward_Diplomacy.GetReprisalTable = nil;

b_Reward_Diplomacy.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_Diplomacy);

-- -------------------------------------------------------------------------- --

---
-- Verbessert die diplomatischen Beziehungen zwischen Sender und Empfänger
-- um einen Grad.
--
-- @within Reward
--
function Reward_DiplomacyIncrease()
    return b_Reward_SlightlyDiplomacyIncrease:new();
end

b_Reward_SlightlyDiplomacyIncrease = {
    Name = "Reward_SlightlyDiplomacyIncrease",
    Description = {
        en = "Reward: Diplomacy increases slightly to another player",
        de = "Lohn: Verbesserug des Diplomatiestatus zu einem anderen Spieler",
    },
}

function b_Reward_SlightlyDiplomacyIncrease:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_SlightlyDiplomacyIncrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State < 2 then
        SetDiplomacyState(Receiver, Sender, State+1);
    end
end

function b_Reward_SlightlyDiplomacyIncrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

Core:RegisterBehavior(b_Reward_SlightlyDiplomacyIncrease);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt Handelsangebote im Lagerhaus des angegebenen Spielers.
--
-- Sollen Angebote gelöscht werden, muss "-" als Ware ausgewählt werden.
--
-- <b>Achtung:</b> Stadtlagerhäuser können keine Söldner anbieten!
--
-- @param _PlayerID Partei, die Anbietet
-- @param _Amount1  Menge des 1. Angebot
-- @param _Type1    Ware oder Typ des 1. Angebot
-- @param _Amount2  Menge des 2. Angebot
-- @param _Type2    Ware oder Typ des 2. Angebot
-- @param _Amount3  Menge des 3. Angebot
-- @param _Type3    Ware oder Typ des 3. Angebot
-- @param _Amount4  Menge des 4. Angebot
-- @param _Type4    Ware oder Typ des 4. Angebot
--
-- @within Reward
--
function Reward_TradeOffers(...)
    return b_Reward_Merchant:new(...);
end

b_Reward_Merchant = {
    Name = "Reward_Merchant",
    Description = {
        en = "Reward: Deletes all existing offers for a merchant and sets new offers, if given",
        de = "Lohn: Löscht alle Angebote eines Händlers und setzt neue, wenn angegeben",
    },
    Parameter = {
        { ParameterType.Custom, en = "PlayerID", de = "PlayerID" },
        { ParameterType.Custom, en = "Amount 1", de = "Menge 1" },
        { ParameterType.Custom, en = "Offer 1", de = "Angebot 1" },
        { ParameterType.Custom, en = "Amount 2", de = "Menge 2" },
        { ParameterType.Custom, en = "Offer 2", de = "Angebot 2" },
        { ParameterType.Custom, en = "Amount 3", de = "Menge 3" },
        { ParameterType.Custom, en = "Offer 3", de = "Angebot 3" },
        { ParameterType.Custom, en = "Amount 4", de = "Menge 4" },
        { ParameterType.Custom, en = "Offer 4", de = "Angebot 4" },
    },
}

function b_Reward_Merchant:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_Merchant:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 1) then
        _Parameter = _Parameter or 0;
        self.AmountOffer1 = _Parameter * 1;
    elseif (_Index == 2) then
        self.Offer1 = _Parameter
    elseif (_Index == 3) then
        _Parameter = _Parameter or 0;
        self.AmountOffer2 = _Parameter * 1;
    elseif (_Index == 4) then
        self.Offer2 = _Parameter
    elseif (_Index == 5) then
        _Parameter = _Parameter or 0;
        self.AmountOffer3 = _Parameter * 1;
    elseif (_Index == 6) then
        self.Offer3 = _Parameter
    elseif (_Index == 7) then
        _Parameter = _Parameter or 0;
        self.AmountOffer4 = _Parameter * 1;
    elseif (_Index == 8) then
        self.Offer4 = _Parameter
    end
end

function b_Reward_Merchant:CustomFunction()
    if (self.PlayerID > 1) and (self.PlayerID < 9) then
        local Storehouse = Logic.GetStoreHouse(self.PlayerID)
        Logic.RemoveAllOffers(Storehouse)
        for i =  1,4 do
            if self["Offer"..i] and self["Offer"..i] ~= "-" then
                if Goods[self["Offer"..i]] then
                    AddOffer(Storehouse, self["AmountOffer"..i], Goods[self["Offer"..i]])
                elseif Logic.IsEntityTypeInCategory(Entities[self["Offer"..i]], EntityCategories.Military) == 1 then
                    AddMercenaryOffer(Storehouse, self["AmountOffer"..i], Entities[self["Offer"..i]])
                else
                    AddEntertainerOffer (Storehouse , Entities[self["Offer"..i]])
                end
            end
        end
    end
end

function b_Reward_Merchant:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID ) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(")
        return true
    end
end

function b_Reward_Merchant:GetCustomData(_Index)
    local Players = { 1,2,3,4,5,6,7,8 }
    local Amount = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }
    local Offers = {"-",
                    "G_Beer",
                    "G_Bow",
                    "G_Bread",
                    "G_Broom",
                    "G_Candle",
                    "G_Carcass",
                    "G_Cheese",
                    "G_Clothes",
                    "G_Cow",
                    "G_Grain",
                    "G_Herb",
                    "G_Honeycomb",
                    "G_Iron",
                    "G_Leather",
                    "G_Medicine",
                    "G_Milk",
                    "G_RawFish",
                    "G_Sausage",
                    "G_Sheep",
                    "G_SmokedFish",
                    "G_Soap",
                    "G_Stone",
                    "G_Sword",
                    "G_Wood",
                    "G_Wool",
                    "G_Salt",
                    "G_Dye",
                    "U_AmmunitionCart",
                    "U_BatteringRamCart",
                    "U_CatapultCart",
                    "U_SiegeTowerCart",
                    "U_MilitaryBandit_Melee_ME",
                    "U_MilitaryBandit_Melee_SE",
                    "U_MilitaryBandit_Melee_NA",
                    "U_MilitaryBandit_Melee_NE",
                    "U_MilitaryBandit_Ranged_ME",
                    "U_MilitaryBandit_Ranged_NA",
                    "U_MilitaryBandit_Ranged_NE",
                    "U_MilitaryBandit_Ranged_SE",
                    "U_MilitaryBow_RedPrince",
                    "U_MilitaryBow",
                    "U_MilitarySword_RedPrince",
                    "U_MilitarySword",
                    "U_Entertainer_NA_FireEater",
                    "U_Entertainer_NA_StiltWalker",
                    "U_Entertainer_NE_StrongestMan_Barrel",
                    "U_Entertainer_NE_StrongestMan_Stone",
                    }
    if g_GameExtraNo and g_GameExtraNo >= 1 then
        table.insert(Offers, "G_Gems")
        table.insert(Offers, "G_Olibanum")
        table.insert(Offers, "G_MusicalInstrument")
        table.insert(Offers, "G_MilitaryBandit_Ranged_AS")
        table.insert(Offers, "G_MilitaryBandit_Melee_AS")
        table.insert(Offers, "U_MilitarySword_Khana")
        table.insert(Offers, "U_MilitaryBow_Khana")
    end
    if (_Index == 0) then
        return Players
    elseif (_Index == 1) or (_Index == 3) or (_Index == 5) or (_Index == 7) then
        return Amount
    elseif (_Index == 2) or (_Index == 4) or (_Index == 6) or (_Index == 8) then
        return Offers
    end
end

Core:RegisterBehavior(b_Reward_Merchant)

-- -------------------------------------------------------------------------- --

---
-- Ein benanntes Entity wird entfernt.
--
-- <b>Hinweis</b>: Das Entity wird durch ein XD_ScriptEntity ersetzt. Es
-- behält Name, Besitzer und Ausrichtung.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Reward
--
function Reward_DestroyEntity(...)
    return b_Reward_DestroyEntity:new(...);
end

b_Reward_DestroyEntity = API.InstanceTable(b_Reprisal_DestroyEntity);
b_Reward_DestroyEntity.Name = "Reward_DestroyEntity";
b_Reward_DestroyEntity.Description.en = "Reward: Replaces an entity with an invisible script entity, which retains the entities name.";
b_Reward_DestroyEntity.Description.de = "Lohn: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.";
b_Reward_DestroyEntity.GetReprisalTable = nil;

b_Reward_DestroyEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_DestroyEntity);

-- -------------------------------------------------------------------------- --

---
-- Zerstört einen über ein Behavior erzeugten Effekt.
--
-- @param _EffectName Name des Effekts
--
-- @within Reward
--
function Reward_DestroyEffect(...)
    return b_Reward_DestroyEffect:new(...);
end

b_Reward_DestroyEffect = API.InstanceTable(b_Reprisal_DestroyEffect);
b_Reward_DestroyEffect.Name = "Reward_DestroyEffect";
b_Reward_DestroyEffect.Description.en = "Reward: Destroys an effect.";
b_Reward_DestroyEffect.Description.de = "Lohn: Zerstört einen Effekt.";
b_Reward_DestroyEffect.GetReprisalTable = nil;

b_Reward_DestroyEffect.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Core:RegisterBehavior(b_Reward_DestroyEffect);

-- -------------------------------------------------------------------------- --

---
-- Ersetzt ein Entity mit einem Batallion.
--
-- Ist die Position ein Gebäude, werden die Battalione am Eingang erzeugt und
-- Das Entity wird nicht ersetzt.
--
-- Das erzeugte Battalion kann vor der KI des Besitzers versteckt werden.
--
-- @param _Position    Skriptname des Entity
-- @param _PlayerID    PlayerID des Battalion
-- @param _UnitType    Einheitentyp der Soldaten
-- @param _Orientation Ausrichtung in °
-- @param _Soldiers    Anzahl an Soldaten
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateBattalion(...)
    return b_Reward_CreateBattalion:new(...);
end

b_Reward_CreateBattalion = {
    Name = "Reward_CreateBattalion",
    Description = {
        en = "Reward: Replaces a script entity with a battalion, which retains the entities name",
        de = "Lohn: Ersetzt eine Script-Entity durch ein Bataillon, welches den Namen der Script-Entity übernimmt",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },
        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },
        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },
    },
}

function b_Reward_CreateBattalion:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_CreateBattalion:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_CreateBattalion:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, self.SoldierCount )
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function b_Reward_CreateBattalion:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function b_Reward_CreateBattalion:Debug(_Quest)
    if not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": playerID is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": you can not create a empty batallion!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_CreateBattalion);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Menga von Battalionen an der Position.
--
-- Die erzeugten Battalione können vor der KI ihres Besitzers versteckt werden.
--
-- @param _Amount      Anzahl erzeugter Battalione
-- @param _Position    Skriptname des Entity
-- @param _PlayerID    PlayerID des Battalion
-- @param _UnitType    Einheitentyp der Soldaten
-- @param _Orientation Ausrichtung in °
-- @param _Soldiers    Anzahl an Soldaten
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateSeveralBattalions(...)
    return b_Reward_CreateSeveralBattalions:new(...);
end

b_Reward_CreateSeveralBattalions = {
    Name = "Reward_CreateSeveralBattalions",
    Description = {
        en = "Reward: Creates a given amount of battalions",
        de = "Lohn: Erstellt eine gegebene Anzahl Bataillone",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },
        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },
        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },
    },
}

function b_Reward_CreateSeveralBattalions:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_CreateSeveralBattalions:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 6) then
        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_CreateSeveralBattalions:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local tID = GetID(self.ScriptNameEntity)
    local x,y,z = Logic.EntityGetPos(tID);
    if Logic.IsBuilding(tID) == 1 then
        x,y = Logic.GetBuildingApproachPosition(tID)
    end

    for i=1, self.Amount do
        local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], x, y, self.Orientation, self.PlayerID, self.SoldierCount )
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function b_Reward_CreateSeveralBattalions:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function b_Reward_CreateSeveralBattalions:Debug(_Quest)
    if not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": playerDI is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": you can not create a empty batallion!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_CreateSeveralBattalions);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt einen Effekt an der angegebenen Position.
--
-- Der Effekt kann über seinen Namen jeder Zeit gelöscht werden.
--
-- <b>Achtung</b>: Feuereffekte sind bekannt dafür Abstürzue zu verursachen.
-- Vermeide sie entweder ganz oder unterbinde das Speichern, solange ein
-- solcher Effekt aktiv ist!
--
-- @param _EffectName  Einzigartiger Effektname
-- @param _TypeName    Typ des Effekt
-- @param _PlayerID    PlayerID des Effekt
-- @param _Location    Position des Effekt
-- @param _Orientation Ausrichtung in °
--
-- @within Reward
--
function Reward_CreateEffect(...)
    return b_Reward_CreateEffect:new(...);
end

b_Reward_CreateEffect = {
    Name = "Reward_CreateEffect",
    Description = {
        en = "Reward: Creates an effect at a specified position",
        de = "Lohn: Erstellt einen Effekt an der angegebenen Position",
    },
    Parameter = {
        { ParameterType.Default,    en = "Effect name", de = "Effektname" },
        { ParameterType.Custom,     en = "Type name", de = "Typbezeichnung" },
        { ParameterType.PlayerID,   en = "Player", de = "Spieler" },
        { ParameterType.ScriptName, en = "Location", de = "Ort" },
        { ParameterType.Number,     en = "Orientation (in degrees)(-1: from locating entity)", de = "Ausrichtung (in Grad)(-1: von Positionseinheit)" },
    }
}

function b_Reward_CreateEffect:AddParameter(_Index, _Parameter)

    if _Index == 0 then
        self.EffectName = _Parameter;
    elseif _Index == 1 then
        self.Type = EGL_Effects[_Parameter];
    elseif _Index == 2 then
        self.PlayerID = _Parameter * 1;
    elseif _Index == 3 then
        self.Location = _Parameter;
    elseif _Index == 4 then
        self.Orientation = _Parameter * 1;
    end

end

function b_Reward_CreateEffect:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } };
end

function b_Reward_CreateEffect:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed(self.Location) then
        return;
    end
    local entity = assert(GetID(self.Location), _Quest.Identifier .. "Error in " .. self.Name .. ": CustomFunction: Entity is invalid");
    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then
        return;
    end

    local posX, posY = Logic.GetEntityPosition(entity);
    local orientation = tonumber(self.Orientation);
    local effect = Logic.CreateEffectWithOrientation(self.Type, posX, posY, orientation, self.PlayerID);
    if self.EffectName ~= "" then
        QSB.EffectNameToID[self.EffectName] = effect;
    end
end

function b_Reward_CreateEffect:Debug(_Quest)
    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then
        error(_Quest.Identifier.. ": " ..self.Name..": effect already exists!");
        return true;
    elseif not IsExisting(self.Location) then
        error(_Quest.Identifier.. ": " ..self.Name..": location '" ..self.Location.. "' is missing!");
        return true;
    elseif self.PlayerID and (self.PlayerID < 0 or self.PlayerID > 8) then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid playerID!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid orientation!");
        return true;
    end
end

function b_Reward_CreateEffect:GetCustomData(_Index)
    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");
    local types = {};
    for k, v in pairs(EGL_Effects) do
        table.insert(types, k);
    end
    table.sort(types);
    return types;
end

Core:RegisterBehavior(b_Reward_CreateEffect);

-- -------------------------------------------------------------------------- --

---
-- Ersetzt ein Entity mit dem Skriptnamen durch ein neues Entity.
--
-- Ist die Position ein Gebäude, werden die Entities am Eingang erzeugt und
-- die Position wird nicht ersetzt.
--
-- Das erzeugte Entity kann vor der KI des Besitzers versteckt werden.
--
-- @param _ScriptName  Skriptname des Entity
-- @param _PlayerID    PlayerID des Effekt
-- @param _TypeName    Typname des Entity
-- @param _Orientation Ausrichtung in °
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateEntity(...)
    return b_Reward_CreateEntity:new(...);
end

b_Reward_CreateEntity = {
    Name = "Reward_CreateEntity",
    Description = {
        en = "Reward: Replaces an entity by a new one of a given type",
        de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },
        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },
    },
}

function b_Reward_CreateEntity:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_CreateEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_CreateEntity:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
        NewID       = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
        local l,s = {Logic.GetSoldiersAttachedToLeader(NewID)}
        Logic.SetOrientation(s, API.Round(self.Orientation))
    else
        NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
    end
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function b_Reward_CreateEntity:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 4 or _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function b_Reward_CreateEntity:Debug(_Quest)
    if not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": playerID is not valid!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_CreateEntity);

-- -------------------------------------------------------------------------- --

-- Kompatibelität
b_Reward_CreateSettler = API.InstanceTable(b_Reward_CreateEntity);
b_Reward_CreateSettler.Name = "Reward_CreateSettler";
b_Reward_CreateSettler.Description.en = "Reward: Replaces an entity by a new one of a given type";
b_Reward_CreateSettler.Description.de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs";
Core:RegisterBehavior(b_Reward_CreateSettler);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt mehrere Entities an der angegebenen Position.
--
-- Die erzeugten Entities können vor der KI ihres Besitzers versteckt werden.
--
-- @param _Amount      Anzahl an Entities
-- @param _ScriptName  Skriptname des Entity
-- @param _PlayerID    PlayerID des Effekt
-- @param _TypeName    Einzigartiger Effektname
-- @param _Orientation Ausrichtung in °
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateSeveralEntities(...)
    return b_Reward_CreateSeveralEntities:new(...);
end

b_Reward_CreateSeveralEntities = {
    Name = "Reward_CreateSeveralEntities",
    Description = {
        en = "Reward: Creating serveral battalions at the position of a entity. They retains the entities name and a _[index] suffix",
        de = "Lohn: Erzeugt mehrere Entities an der Position der Entity. Sie übernimmt den Namen der Script Entity und den Suffix _[index]",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },
        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },
    },
}

function b_Reward_CreateSeveralEntities:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_CreateSeveralEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_CreateSeveralEntities:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    for i=1, self.Amount do
        if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
            NewID       = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
            local l,s = {Logic.GetSoldiersAttachedToLeader(NewID)}
            Logic.SetOrientation(s, API.Round(self.Orientation))
        else
            NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
        end
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function b_Reward_CreateSeveralEntities:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 5 or _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data

end

function b_Reward_CreateSeveralEntities:Debug(_Quest)
    if not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_CreateSeveralEntities);

-- -------------------------------------------------------------------------- --

---
-- Bewegt einen Siedler, einen Helden oder ein Battalion zum angegebenen 
-- Zielort.
--
-- @param _Settler     Einheit, die bewegt wird
-- @param _Destination Bewegungsziel
--
-- @within Reward
--
function Reward_MoveSettler(...)
    return b_Reward_MoveSettler:new(...);
end

b_Reward_MoveSettler = {
    Name = "Reward_MoveSettler",
    Description = {
        en = "Reward: Moves a (NPC) settler to a destination. Must not be AI controlled, or it won't move",
        de = "Lohn: Bewegt einen (NPC) Siedler zu einem Zielort. Darf keinem KI Spieler gehören, ansonsten wird sich der Siedler nicht bewegen",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler", de = "Siedler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel" },
    },
}

function b_Reward_MoveSettler:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_MoveSettler:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameUnit = _Parameter
    elseif (_Index == 1) then
        self.ScriptNameDest = _Parameter
    end
end

function b_Reward_MoveSettler:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptNameUnit ) or Logic.IsEntityDestroyed( self.ScriptNameDest ) then
        return false
    end
    local DestID = GetID( self.ScriptNameDest )
    local DestX, DestY = Logic.GetEntityPosition( DestID )
    if Logic.IsBuilding( DestID ) == 1 then
        DestX, DestY = Logic.GetBuildingApproachPosition( DestID )
    end
    Logic.MoveSettler( GetID( self.ScriptNameUnit ), DestX, DestY )
end

function b_Reward_MoveSettler:Debug(_Quest)
    if not IsExisting(self.ScriptNameUnit) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": mover entity does not exist!");
        return true;
    elseif not IsExisting(self.ScriptNameDest) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": destination does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_MoveSettler);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler gewinnt das Spiel.
--
-- @within Reward
--
function Reward_Victory()
    return b_Reward_Victory:new()
end

b_Reward_Victory = {
    Name = "Reward_Victory",
    Description = {
        en = "Reward: The player wins the game.",
        de = "Lohn: Der Spieler gewinnt das Spiel.",
    },
}

function b_Reward_Victory:GetRewardTable()
    return {Reward.Victory};
end

Core:RegisterBehavior(b_Reward_Victory);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler verliert das Spiel.
--
--
-- @within Reward
--
function Reward_Defeat()
    return b_Reward_Defeat:new()
end

b_Reward_Defeat = {
    Name = "Reward_Defeat",
    Description = {
        en = "Reward: The player loses the game.",
        de = "Lohn: Der Spieler verliert das Spiel.",
    },
}

function b_Reward_Defeat:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function b_Reward_Defeat:CustomFunction(_Quest)
    _Quest:TerminateEventsAndStuff()
    Logic.ExecuteInLuaLocalState("GUI_Window.MissionEndScreenSetVictoryReasonText(".. g_VictoryAndDefeatType.DefeatMissionFailed ..")")
    Defeated(_Quest.ReceivingPlayer)
end

Core:RegisterBehavior(b_Reward_Defeat);

-- -------------------------------------------------------------------------- --

---
-- Zeigt die Siegdekoration an dem Quest an.
--
-- Dies ist reine Optik! Der Spieler wird dadurch nicht das Spiel gewinnen.
--
-- @within Reward
--
function Reward_FakeVictory()
    return b_Reward_FakeVictory:new();
end

b_Reward_FakeVictory = {
    Name = "Reward_FakeVictory",
    Description = {
        en = "Reward: Display a victory icon for a quest",
        de = "Lohn: Zeigt ein Siegesicon für diese Quest",
    },
}

function b_Reward_FakeVictory:GetRewardTable()
    return { Reward.FakeVictory }
end

Core:RegisterBehavior(b_Reward_FakeVictory);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Armee, die das angegebene Territorium angreift.
--
-- Die Armee wird versuchen Gebäude auf dem Territrium zu zerstören.
-- <ul>
-- <li>Außenposten: Die Armee versucht den Außenposten zu zerstören</li>
-- <li>Stadt: Die Armee versucht das Lagerhaus zu zerstören</li>
-- </ul>
--
-- @param _PlayerID   PlayerID der Angreifer
-- @param _SpawnPoint Skriptname des Entstehungspunkt
-- @param _Territory  Zielterritorium
-- @param _Sword      Anzahl Schwertkämpfer (Battalion)
-- @param _Bow        Anzahl Bogenschützen (Battalion)
-- @param _Cata       Anzahl Katapulte
-- @param _Towers     Anzahl Belagerungstürme
-- @param _Rams       Anzahl Rammen
-- @param _Ammo       Anzahl Munitionswagen
-- @param _Type       Typ der Soldaten
-- @param _Reuse      Freie Truppen wiederverwenden
--
-- @within Reward
--
function Reward_AI_SpawnAndAttackTerritory(...)
    return b_Reward_AI_SpawnAndAttackTerritory:new(...);
end

b_Reward_AI_SpawnAndAttackTerritory = {
    Name = "Reward_AI_SpawnAndAttackTerritory",
    Description = {
        en = "Reward: Spawns AI troops and attacks a territory (Hint: Use for hidden quests as a surprise)",
        de = "Lohn: Erstellt KI Truppen und greift ein Territorium an (Tipp: Für eine versteckte Quest als Ueberraschung verwenden)",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },
        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },
        { ParameterType.Number, en = "Sword", de = "Schwert" },
        { ParameterType.Number, en = "Bow", de = "Bogen" },
        { ParameterType.Number, en = "Catapults", de = "Katapulte" },
        { ParameterType.Number, en = "Siege towers", de = "Belagerungstürme" },
        { ParameterType.Number, en = "Rams", de = "Rammen" },
        { ParameterType.Number, en = "Ammo carts", de = "Munitionswagen" },
        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },
        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },
    },
}

function b_Reward_AI_SpawnAndAttackTerritory:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_SpawnAndAttackTerritory:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 3) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 4) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 5) then
        self.NumCatapults = _Parameter * 1
    elseif (_Index == 6) then
        self.NumSiegeTowers = _Parameter * 1
    elseif (_Index == 7) then
        self.NumRams = _Parameter * 1
    elseif (_Index == 8) then
        self.NumAmmoCarts = _Parameter * 1
    elseif (_Index == 9) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 10) then
        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)
    end

end

function b_Reward_AI_SpawnAndAttackTerritory:GetCustomData( _Index )

    local Data = {}
    if _Index == 9 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end

    elseif _Index == 10 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )

    else
        assert( false )
    end

    return Data

end

function b_Reward_AI_SpawnAndAttackTerritory:CustomFunction(_Quest)

    local TargetID = Logic.GetTerritoryAcquiringBuildingID( self.TerritoryID )
    if TargetID ~= 0 then
        AIScript_SpawnAndAttackCity( self.AIPlayerID, TargetID, self.Spawnpoint, self.NumSword, self.NumBow, self.NumCatapults, self.NumSiegeTowers, self.NumRams, self.NumAmmoCarts, self.TroopType, self.ReuseTroops)
    end

end

function b_Reward_AI_SpawnAndAttackTerritory:Debug(_Quest)
    if self.AIPlayerID < 2 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif self.TerritoryID == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Territory unknown")
        return true
    elseif self.NumSword < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    elseif self.NumCatapults < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Catapults is negative")
        return true
    elseif self.NumSiegeTowers < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": SiegeTowers is negative")
        return true
    elseif self.NumRams < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Rams is negative")
        return true
    elseif self.NumAmmoCarts < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": AmmoCarts is negative")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_AI_SpawnAndAttackTerritory);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Armee, die sich zum Zielpunkt bewegt und das Gebiet angreift.
--
-- Dabei werden die Soldaten alle erreichbaren Gebäude in Brand stecken. Ist
-- Das Zielgebiet eingemauert, können die Soldaten nicht angreifen und werden
-- sich zurückziehen.
--
-- @param _PlayerID   PlayerID des Angreifers
-- @param _SpawnPoint Skriptname des Entstehungspunktes
-- @param _Target     Skriptname des Ziels
-- @param _Radius     Aktionsradius um das Ziel
-- @param _Sword      Anzahl Schwertkämpfer (Battalione)
-- @param _Bow        Anzahl Bogenschützen (Battalione)
-- @param _Soldier    Typ der Soldaten
-- @param _Reuse      Freie Truppen wiederverwenden
--
-- @within Reward
--
function Reward_AI_SpawnAndAttackArea(...)
    return b_Reward_AI_SpawnAndAttackArea:new(...);
end

b_Reward_AI_SpawnAndAttackArea = {
    Name = "Reward_AI_SpawnAndAttackArea",
    Description = {
        en = "Reward: Spawns AI troops and attacks everything within the specified area, except the players main buildings",
        de = "Lohn: Erstellt KI Truppen und greift ein angegebenes Gebiet an, aber nicht die Hauptgebauede eines Spielers",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },
        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },
        { ParameterType.ScriptName, en = "Target", de = "Ziel" },
        { ParameterType.Number, en = "Radius", de = "Radius" },
        { ParameterType.Number, en = "Sword", de = "Schwert" },
        { ParameterType.Number, en = "Bow", de = "Bogen" },
        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },
        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },
    },
}

function b_Reward_AI_SpawnAndAttackArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_SpawnAndAttackArea:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 5) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 6) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 7) then
        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_AI_SpawnAndAttackArea:GetCustomData( _Index )
    local Data = {}
    if _Index == 6 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end
    elseif _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function b_Reward_AI_SpawnAndAttackArea:CustomFunction(_Quest)
    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndRaidSettlement( self.AIPlayerID, TargetID, self.Spawnpoint, self.Radius, self.NumSword, self.NumBow, self.TroopType, self.ReuseTroops )
    end
end

function b_Reward_AI_SpawnAndAttackArea:Debug(_Quest)
    if self.AIPlayerID < 2 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Radius is to small or negative")
        return true
    elseif self.NumSword < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_AI_SpawnAndAttackArea);

-- -------------------------------------------------------------------------- --

---
-- Erstellt eine Armee, die das Zielgebiet verteidigt.
--
-- @param _PlayerID     PlayerID des Angreifers
-- @param _SpawnPoint   Skriptname des Entstehungspunktes
-- @param _Target       Skriptname des Ziels
-- @param _Radius       Bewachtes Gebiet
-- @param _Time         Dauer der Bewachung (-1 für unendlich)
-- @param _Sword        Anzahl Schwertkämpfer (Battalione)
-- @param _Bow          Anzahl Bogenschützen (Battalione)
-- @param _CaptureCarts Soldaten greifen Karren an
-- @param _Type         Typ der Soldaten
-- @param _Reuse        Freie Truppen wiederverwenden
--
-- @within Reward
--
function Reward_AI_SpawnAndProtectArea(...)
    return b_Reward_AI_SpawnAndProtectArea:new(...);
end

b_Reward_AI_SpawnAndProtectArea = {
    Name = "Reward_AI_SpawnAndProtectArea",
    Description = {
        en = "Reward: Spawns AI troops and defends a specified area",
        de = "Lohn: Erstellt KI Truppen und verteidigt ein angegebenes Gebiet",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },
        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },
        { ParameterType.ScriptName, en = "Target", de = "Ziel" },
        { ParameterType.Number, en = "Radius", de = "Radius" },
        { ParameterType.Number, en = "Time (-1 for infinite)", de = "Zeit (-1 für unendlich)" },
        { ParameterType.Number, en = "Sword", de = "Schwert" },
        { ParameterType.Number, en = "Bow", de = "Bogen" },
        { ParameterType.Custom, en = "Capture tradecarts", de = "Handelskarren angreifen" },
        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },
        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },
    },
}

function b_Reward_AI_SpawnAndProtectArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_SpawnAndProtectArea:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.Time = _Parameter * 1
    elseif (_Index == 5) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 6) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 7) then
        self.CaptureTradeCarts = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 8) then
        if _Parameter == "Normal" or _Parameter == true then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == false then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 9) then
        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)
    end

end

function b_Reward_AI_SpawnAndProtectArea:GetCustomData( _Index )

    local Data = {}
    if _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    elseif _Index == 8 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end

    elseif _Index == 9 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )

    else
        assert( false )
    end

    return Data

end

function b_Reward_AI_SpawnAndProtectArea:CustomFunction(_Quest)

    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndProtectArea( self.AIPlayerID, TargetID, self.Spawnpoint, self.Radius, self.NumSword, self.NumBow, self.Time, self.TroopType, self.ReuseTroops, self.CaptureTradeCarts )
    end

end

function b_Reward_AI_SpawnAndProtectArea:Debug(_Quest)
    if self.AIPlayerID < 2 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Radius is to small or negative")
        return true
    elseif self.Time < -1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Time is smaller than -1")
        return true
    elseif self.NumSword < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_AI_SpawnAndProtectArea);

-- -------------------------------------------------------------------------- --

---
-- Ändert die Konfiguration eines KI-Spielers.
--
-- Optionen:
-- <ul>
-- <li>Courage/FEAR: Angstfaktor (0 bis ?)</li>
-- <li>Reconstruction/BARB: Wiederaufbau von Gebäuden (0 oder 1)</li>
-- <li>Build Order/BPMX: Buildorder ausführen (Nummer der Build Order)</li>
-- <li>Conquer Outposts/FCOP: Außenposten einnehmen (0 oder 1)</li>
-- <li>Mount Outposts/FMOP: Eigene Außenposten bemannen (0 oder 1)</li>
-- <li>max. Bowmen/FMBM: Maximale Anzahl an Bogenschützen (min. 1)</li>
-- <li>max. Swordmen/FMSM: Maximale Anzahl an Schwerkkämpfer (min. 1) </li>
-- <li>max. Rams/FMRA: Maximale Anzahl an Rammen (min. 1)</li>
-- <li>max. Catapults/FMCA: Maximale Anzahl an Katapulten (min. 1)</li>
-- <li>max. Ammunition Carts/FMAC: Maximale Anzahl an Minitionswagen (min. 1)</li>
-- <li>max. Siege Towers/FMST: Maximale Anzahl an Belagerungstürmen (min. 1)</li>
-- <li>max. Wall Catapults/FMBA: Maximale Anzahl an Mauerkatapulten (min. 1)</li>
-- </ul>
--
-- @param _PlayerID PlayerID des KI
-- @param _Fact     Konfigurationseintrag
-- @param _Value    Neuer Wert
--
-- @within Reward
--
function Reward_AI_SetNumericalFact(...)
    return b_Reward_AI_SetNumericalFact:new(...);
end

b_Reward_AI_SetNumericalFact = {
    Name = "Reward_AI_SetNumericalFact",
    Description = {
        en = "Reward: Sets a numerical fact for the AI player",
        de = "Lohn: Setzt eine Verhaltensregel für den KI-Spieler. ",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player",      de = "KI Spieler" },
        { ParameterType.Custom,   en = "Numerical Fact", de = "Verhaltensregel" },
        { ParameterType.Number,   en = "Value",          de = "Wert" },
    },
}

function b_Reward_AI_SetNumericalFact:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_SetNumericalFact:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        -- mapping of numerical facts
        local fact = {
            ["Courage"]               = "FEAR",
            ["Reconstruction"]        = "BARB",
            ["Build Order"]           = "BPMX",
            ["Conquer Outposts"]      = "FCOP",
            ["Mount Outposts"]        = "FMOP",
            ["max. Bowmen"]           = "FMBM",
            ["max. Swordmen"]         = "FMSM",
            ["max. Rams"]             = "FMRA",
            ["max. Catapults"]        = "FMCA",
            ["max. Ammunition Carts"] = "FMAC",
            ["max. Siege Towers"]     = "FMST",
            ["max. Wall Catapults"]   = "FMBA",
            ["FEAR"]                  = "FEAR", -- > 0
            ["BARB"]                  = "BARB", -- 1 or 0
            ["BPMX"]                  = "BPMX", -- >= 0
            ["FCOP"]                  = "FCOP", -- 1 or 0
            ["FMOP"]                  = "FMOP", -- 1 or 0
            ["FMBM"]                  = "FMBM", -- >= 0
            ["FMSM"]                  = "FMSM", -- >= 0
            ["FMRA"]                  = "FMRA", -- >= 0
            ["FMCA"]                  = "FMCA", -- >= 0
            ["FMAC"]                  = "FMAC", -- >= 0
            ["FMST"]                  = "FMST", -- >= 0
            ["FMBA"]                  = "FMBA", -- >= 0
        }
        self.NumericalFact = fact[_Parameter]
    elseif (_Index == 2) then
        self.Value = _Parameter * 1
    end
end

function b_Reward_AI_SetNumericalFact:CustomFunction(_Quest)
    AICore.SetNumericalFact( self.AIPlayerID, self.NumericalFact, self.Value )
end

function b_Reward_AI_SetNumericalFact:GetCustomData(_Index)
    if (_Index == 1) then
        return {
            "Courage",
            "Reconstruction",
            "Build Order",
            "Conquer Outposts",
            "Mount Outposts",
            "max. Bowmen",
            "max. Swordmen",
            "max. Rams",
            "max. Catapults",
            "max. Ammunition Carts",
            "max. Siege Towers",
            "max. Wall Catapults",
        };
    end
end

function b_Reward_AI_SetNumericalFact:Debug(_Quest)
    if Logic.GetStoreHouse(self.AIPlayerID) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong or dead!");
        return true;
    elseif not self.NumericalFact then
        error(_Quest.Identifier.. ": " ..self.Name .. ": invalid numerical fact choosen!");
        return true;
    else
        if self.NumericalFact == "BARB" or self.NumericalFact == "FCOP" or self.NumericalFact == "FMOP" then
            if self.Value ~= 0 and self.Value ~= 1 then
                error(_Quest.Identifier.. ": " ..self.Name .. ": BARB, FCOP, FMOP: value must be 1 or 0!");
                return true;
            end
        elseif self.NumericalFact == "FEAR" then
            if self.Value <= 0 then
                error(_Quest.Identifier.. ": " ..self.Name .. ": FEAR: value must greater than 0!");
                return true;
            end
        else
            if self.Value < 0 then
                error(_Quest.Identifier.. ": " ..self.Name .. ": value must always greater than or equal 0!");
                return true;
            end
        end
    end
    return false
end

Core:RegisterBehavior(b_Reward_AI_SetNumericalFact);

-- -------------------------------------------------------------------------- --

---
-- Stellt den Aggressivitätswert des KI-Spielers nachträglich ein.
--
-- @param _PlayerID         PlayerID des KI-Spielers
-- @param _Aggressiveness   Aggressivitätswert (1 bis 3)
--
-- @within Reward
--
function Reward_AI_Aggressiveness(...)
    return b_Reward_AI_Aggressiveness:new(...);
end

b_Reward_AI_Aggressiveness = {
    Name = "Reward_AI_Aggressiveness",
    Description = {
        en = "Reward: Sets the AI player's aggressiveness.",
        de = "Lohn: Setzt die Aggressivität des KI-Spielers fest.",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler" },
        { ParameterType.Custom, en = "Aggressiveness (1-3)", de = "Aggressivität (1-3)" }
    }
};

function b_Reward_AI_Aggressiveness:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction} };
end

function b_Reward_AI_Aggressiveness:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Aggressiveness = tonumber(_Parameter);
    end
end

function b_Reward_AI_Aggressiveness:CustomFunction()
    local player = (PlayerAIs[self.AIPlayer]
        or AIPlayerTable[self.AIPlayer]
        or AIPlayer:new(self.AIPlayer, AIPlayerProfile_City));
    PlayerAIs[self.AIPlayer] = player;
    if self.Aggressiveness >= 2 then
        player.m_ProfileLoop = AIProfile_Skirmish;
        player.Skirmish = player.Skirmish or {};
        player.Skirmish.Claim_MinTime = SkirmishDefault.Claim_MinTime + (self.Aggressiveness - 2) * 390;
        player.Skirmish.Claim_MaxTime = player.Skirmish.Claim_MinTime * 2;
    else
        player.m_ProfileLoop = AIPlayerProfile_City;
    end
end

function b_Reward_AI_Aggressiveness:Debug(_Quest)
    if self.AIPlayer < 1 or Logic.GetStoreHouse(self.AIPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayer .. " is wrong");
        return true;
    end
end

function b_Reward_AI_Aggressiveness:GetCustomData(_Index)
    return { "1", "2", "3" };
end

Core:RegisterBehavior(b_Reward_AI_Aggressiveness)

-- -------------------------------------------------------------------------- --

---
-- Stellt den Feind des Skirmish-KI ein.
--
-- Der Skirmish-KI (maximale Aggressivität) kann nur einen Spieler als Feind
-- behandeln. Für gewöhnlich ist dies der menschliche Spieler.
--
-- @param _PlayerID      PlayerID des KI
-- @param _EnemyPlayerID PlayerID des Feindes
--
-- @within Reward
--
function Reward_AI_SetEnemy(...)
    return b_Reward_AI_SetEnemy:new(...);
end

b_Reward_AI_SetEnemy = {
    Name = "Reward_AI_SetEnemy",
    Description = {
        en = "Reward:Sets the enemy of an AI player (the AI only handles one enemy properly).",
        de = "Lohn: Legt den Feind eines KI-Spielers fest (die KI behandelt nur einen Feind korrekt).",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler" },
        { ParameterType.PlayerID, en = "Enemy", de = "Feind" }
    }
};

function b_Reward_AI_SetEnemy:GetRewardTable()

    return {Reward.Custom, {self, self.CustomFunction} };

end

function b_Reward_AI_SetEnemy:AddParameter(_Index, _Parameter)

    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Enemy = _Parameter * 1;
    end

end

function b_Reward_AI_SetEnemy:CustomFunction()

    local player = PlayerAIs[self.AIPlayer];
    if player and player.Skirmish then
        player.Skirmish.Enemy = self.Enemy;
    end

end

function b_Reward_AI_SetEnemy:Debug(_Quest)
    if self.AIPlayer < 1 or self.AIPlayer > 8 or Logic.PlayerGetIsHumanFlag(self.AIPlayer) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayer .. " is wrong");
        return true;
    end
    return false;
end
Core:RegisterBehavior(b_Reward_AI_SetEnemy)

-- -------------------------------------------------------------------------- --

---
-- Ein Entity wird durch ein neues anderen Typs ersetzt.
--
-- Das neue Entity übernimmt Skriptname, Besitzer und Ausrichtung des
-- alten Entity.
--
-- @param _Entity Skriptname oder ID des Entity
-- @param _Type   Neuer Typ des Entity
-- @param _Owner  Besitzer des Entity
--
-- @within Reward
--
function Reward_ReplaceEntity(...)
    return b_Reward_ReplaceEntity:new(...);
end

b_Reward_ReplaceEntity = API.InstanceTable(b_Reprisal_ReplaceEntity);
b_Reward_ReplaceEntity.Name = "Reward_ReplaceEntity";
b_Reward_ReplaceEntity.Description.en = "Reward: Replaces an entity with a new one of a different type. The playerID can be changed too.";
b_Reward_ReplaceEntity.Description.de = "Lohn: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.";
b_Reward_ReplaceEntity.GetReprisalTable = nil;

b_Reward_ReplaceEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_ReplaceEntity);

-- -------------------------------------------------------------------------- --

---
-- Setzt die Menge von Rohstoffen in einer Mine.
--
-- <b>Achtung:</b> Im Reich des Ostens darf die Mine nicht eingestürzt sein!
-- Außerdem bringt dieses Behavior die Nachfüllmechanik durcheinander.
--
-- @param _ScriptName Skriptname der Mine
-- @param _Amount     Menge an Rohstoffen
--
-- @within Reward
--
function Reward_SetResourceAmount(...)
    return b_Reward_SetResourceAmount:new(...);
end

b_Reward_SetResourceAmount = {
    Name = "Reward_SetResourceAmount",
    Description = {
        en = "Reward: Set the current and maximum amount of a resource doodad (the amount can also set to 0)",
        de = "Lohn: Setzt die aktuellen sowie maximalen Resourcen in einem Doodad (auch 0 ist möglich)",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Ressource", de = "Resource" },
        { ParameterType.Number, en = "Amount", de = "Menge" },
    },
}

function b_Reward_SetResourceAmount:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_SetResourceAmount:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end

end

function b_Reward_SetResourceAmount:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptName ) then
        return false
    end
    local EntityID = GetID( self.ScriptName )
    if Logic.GetResourceDoodadGoodType( EntityID ) == 0 then
        return false
    end
    Logic.SetResourceDoodadGoodAmount( EntityID, self.Amount )
end

function b_Reward_SetResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": resource entity does not exist!")
        return true
    elseif not type(self.Amount) == "number" or self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": resource amount can not be negative!")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_SetResourceAmount);

-- -------------------------------------------------------------------------- --

---
-- Fügt dem Lagerhaus des Auftragnehmers eine Menge an Rohstoffen hinzu. Die
-- Rohstoffe werden direkt ins Lagerhaus bzw. die Schatzkammer gelegt.
--
-- @param _Type   Rohstofftyp
-- @param _Amount Menge an Rohstoffen
--
-- @within Reward
--
function Reward_Resources(...)
    return b_Reward_Resources:new(...);
end

b_Reward_Resources = {
    Name = "Reward_Resources",
    Description = {
        en = "Reward: The player receives a given amount of Goods in his store.",
        de = "Lohn: Legt der Partei die angegebenen Rohstoffe ins Lagerhaus.",
    },
    Parameter = {
        { ParameterType.RawGoods, en = "Type of good", de = "Resourcentyp" },
        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },
    },
}

function b_Reward_Resources:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function b_Reward_Resources:GetRewardTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Reward.Resources, GoodType, self.GoodAmount }
end

Core:RegisterBehavior(b_Reward_Resources);

-- -------------------------------------------------------------------------- --

---
-- Entsendet einen Karren zum angegebenen Spieler.
--
-- Wenn der Spawnpoint ein Gebäude ist, wird der Wagen am Eingang erstellt.
-- Andernfalls kann der Spawnpoint gelöscht werden und der Wagen übernimmt
-- dann den Skriptnamen.
--
-- @param _ScriptName    Skriptname des Spawnpoint
-- @param _Owner         Empfänger der Lieferung
-- @param _Type          Typ des Wagens
-- @param _Good          Typ der Ware
-- @param _Amount        Menge an Waren
-- @param _OtherPlayer   Anderer Empfänger als Auftraggeber
-- @param _NoReservation Platzreservation auf dem Markt ignorieren (Sinnvoll?)
-- @param _Replace       Spawnpoint ersetzen
--
-- @within Reward
--
function Reward_SendCart(...)
    return b_Reward_SendCart:new(...);
end

b_Reward_SendCart = {
    Name = "Reward_SendCart",
    Description = {
        en = "Reward: Sends a cart to a player. It spawns at a building or by replacing an entity. The cart can replace the entity if it's not a building.",
        de = "Lohn: Sendet einen Karren zu einem Spieler. Der Karren wird an einem Gebäude oder einer Entity erstellt. Er ersetzt die Entity, wenn diese kein Gebäude ist.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Owning player", de = "Besitzer" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Custom, en = "Good type", de = "Warentyp" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.Custom, en = "Override target player", de = "Anderer Zielspieler" },
        { ParameterType.Custom, en = "Ignore reservations", de = "Ignoriere Reservierungen" },
        { ParameterType.Custom, en = "Replace entity", de = "Entity ersetzen" },
    },
}

function b_Reward_SendCart:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_SendCart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.GoodType = _Parameter
    elseif (_Index == 4) then
        self.GoodAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.OverrideTargetPlayer = tonumber(_Parameter)
    elseif (_Index == 6) then
        self.IgnoreReservation = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 7) then
        self.ReplaceEntity = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_SendCart:CustomFunction(_Quest)

    if not IsExisting( self.ScriptNameEntity ) then
        return false;
    end

    local ID = SendCart(self.ScriptNameEntity, self.PlayerID, Goods[self.GoodType], self.GoodAmount, Entities[self.UnitKey], self.IgnoreReservation);

    if self.ReplaceEntity and Logic.IsBuilding(GetID(self.ScriptNameEntity)) == 0 then
        DestroyEntity(self.ScriptNameEntity);
        Logic.SetEntityName(ID, self.ScriptNameEntity);
    end
    if self.OverrideTargetPlayer then
        Logic.ResourceMerchant_OverrideTargetPlayerID(ID,self.OverrideTargetPlayer);
    end
end

function b_Reward_SendCart:GetCustomData( _Index )
    local Data = {};
    if _Index == 2 then
        Data = { "U_ResourceMerchant", "U_Medicus", "U_Marketer", "U_ThiefCart", "U_GoldCart", "U_Noblemen_Cart", "U_RegaliaCart" };
    elseif _Index == 3 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k );
            end
        end
        table.sort( Data );
    elseif _Index == 5 then
        table.insert( Data, "-" );
        for i = 1, 8 do
            table.insert( Data, i );
        end
    elseif _Index == 6 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    elseif _Index == 7 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    end
    return Data;
end

function b_Reward_SendCart:Debug(_Quest)
    if not IsExisting(self.ScriptNameEntity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": got a invalid playerID!");
        return true;
    elseif not Entities[self.UnitKey] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity type '"..self.UnitKey.."' is invalid!");
        return true;
    elseif not Goods[self.GoodType] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": good type '"..self.GoodType.."' is invalid!");
        return true;
    elseif not tonumber(self.GoodAmount) or self.GoodAmount < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": good amount can not be below 1!");
        return true;
    elseif tonumber(self.OverrideTargetPlayer) and (self.OverrideTargetPlayer < 1 or self.OverrideTargetPlayer > 8) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": overwrite target player with invalid playerID!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_SendCart);

-- -------------------------------------------------------------------------- --

---
-- Gibt dem Auftragnehmer eine Menge an Einheiten.
--
-- Die Einheiten erscheinen an der Burg. Hat der Spieler keine Burg, dann
-- erscheinen sie vorm Lagerhaus.
--
-- @param _Type   Typ der Einheit
-- @param _Amount Menge an Einheiten
--
-- @within Reward
--
function Reward_Units(...)
    return b_Reward_Units:new(...)
end

b_Reward_Units = {
    Name = "Reward_Units",
    Description = {
        en = "Reward: Units",
        de = "Lohn: Einheiten",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
    },
}

function b_Reward_Units:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end
end

function b_Reward_Units:GetRewardTable()
    return { Reward.Units, assert( Entities[self.EntityName] ), self.Amount }
end

Core:RegisterBehavior(b_Reward_Units);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest neu.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestRestart(...)
    return b_Reward_QuestRestart:new(...)
end

b_Reward_QuestRestart = API.InstanceTable(b_Reprisal_QuestRestart);
b_Reward_QuestRestart.Name = "Reward_QuestRestart";
b_Reward_QuestRestart.Description.en = "Reward: Restarts a (completed) quest so it can be triggered and completed again.";
b_Reward_QuestRestart.Description.de = "Lohn: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann.";
b_Reward_QuestRestart.GetReprisalTable = nil;

b_Reward_QuestRestart.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestRestart);

-- -------------------------------------------------------------------------- --

---
-- Lässt einen Quest fehlschlagen.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestFailure(...)
    return b_Reward_QuestFailure:new(...)
end

b_Reward_QuestFailure = API.InstanceTable(b_Reprisal_QuestFailure);
b_Reward_QuestFailure.Name = "Reward_QuestFailure";
b_Reward_QuestFailure.Description.en = "Reward: Lets another active quest fail.";
b_Reward_QuestFailure.Description.de = "Lohn: Lässt eine andere aktive Quest fehlschlagen.";
b_Reward_QuestFailure.GetReprisalTable = nil;

b_Reward_QuestFailure.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Wertet einen Quest als erfolgreich.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestSuccess(...)
    return b_Reward_QuestSuccess:new(...)
end

b_Reward_QuestSuccess = API.InstanceTable(b_Reprisal_QuestSuccess);
b_Reward_QuestSuccess.Name = "Reward_QuestSuccess";
b_Reward_QuestSuccess.Description.en = "Reward: Completes another active quest successfully.";
b_Reward_QuestSuccess.Description.de = "Lohn: Beendet eine andere aktive Quest erfolgreich.";
b_Reward_QuestSuccess.GetReprisalTable = nil;

b_Reward_QuestSuccess.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Triggert einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestActivate(...)
    return b_Reward_QuestActivate:new(...)
end

b_Reward_QuestActivate = API.InstanceTable(b_Reprisal_QuestActivate);
b_Reward_QuestActivate.Name = "Reward_QuestActivate";
b_Reward_QuestActivate.Description.en = "Reward: Activates another quest that is not triggered yet.";
b_Reward_QuestActivate.Description.de = "Lohn: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.";
b_Reward_QuestActivate.GetReprisalTable = nil;

b_Reward_QuestActivate.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestActivate)

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestInterrupt(...)
    return b_Reward_QuestInterrupt:new(...)
end

b_Reward_QuestInterrupt = API.InstanceTable(b_Reprisal_QuestInterrupt);
b_Reward_QuestInterrupt.Name = "Reward_QuestInterrupt";
b_Reward_QuestInterrupt.Description.en = "Reward: Interrupts another active quest without success or failure.";
b_Reward_QuestInterrupt.Description.de = "Lohn: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg.";
b_Reward_QuestInterrupt.GetReprisalTable = nil;

b_Reward_QuestInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.
--
-- @param _QuestName   Name des Quest
-- @param _EndetQuests Bereits beendete unterbrechen
--
-- @within Reward
--
function Reward_QuestForceInterrupt(...)
    return b_Reward_QuestForceInterrupt:new(...)
end

b_Reward_QuestForceInterrupt = API.InstanceTable(b_Reprisal_QuestForceInterrupt);
b_Reward_QuestForceInterrupt.Name = "Reward_QuestForceInterrupt";
b_Reward_QuestForceInterrupt.Description.en = "Reward: Interrupts another quest (even when it isn't active yet) without success or failure.";
b_Reward_QuestForceInterrupt.Description.de = "Lohn: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg.";
b_Reward_QuestForceInterrupt.GetReprisalTable = nil;

b_Reward_QuestForceInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Wert einer benutzerdefinierten Variable.
--
-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein. Nutze
-- dieses Behavior bevor die Variable in einem Goal oder Trigger abgefragt
-- wird, um sie zu initialisieren!
--
-- <p>Operatoren</p>
-- <ul>
-- <li>= - Variablenwert wird auf den Wert gesetzt</li>
-- <li>- - Variablenwert mit Wert Subtrahieren</li>
-- <li>+ - Variablenwert mit Wert addieren</li>
-- <li>* - Variablenwert mit Wert multiplizieren</li>
-- <li>/ - Variablenwert mit Wert dividieren</li>
-- <li>^ - Variablenwert mit Wert potenzieren</li>
-- </ul>
--
-- @param _Name     Name der Variable
-- @param _Operator Rechen- oder Zuweisungsoperator
-- @param _Value    Wert oder andere Custom Variable
--
-- @within Reward
--
function Reward_CustomVariables(...)
    return b_Reward_CustomVariables:new(...);
end

b_Reward_CustomVariables = API.InstanceTable(b_Reprisal_CustomVariables);
b_Reward_CustomVariables.Name = "Reward_CustomVariables";
b_Reward_CustomVariables.Description.en = "Reward: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.";
b_Reward_CustomVariables.Description.de = "Lohn: Fuehrt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.";
b_Reward_CustomVariables.GetReprisalTable = nil;

b_Reward_CustomVariables.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} };
end

Core:RegisterBehavior(b_Reward_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Reward aus.
--
-- Wird ein Funktionsname als String übergeben, wird die Funktion mit den
-- Daten des Behavors und des zugehörigen Quest aufgerufen (Standard).
--
-- Wird eine Funktionsreferenz angegeben, wird die Funktion zusammen mit allen
-- optionalen Parametern aufgerufen, als sei es ein gewöhnlicher Aufruf im
-- Skript.
-- <pre>Reward_MapScriptFunction(ReplaceEntity, "block", Entities.XD_ScriptEntity);
-- -- entspricht: ReplaceEntity("block", Entities.XD_ScriptEntity);</pre>
-- <b>Achtung:</b> Nicht über den Assistenten verfügbar!
--
-- @param _FunctionName Name der Funktion oder Funktionsreferenz
--
-- @within Reward
--
function Reward_MapScriptFunction(...)
    return b_Reward_MapScriptFunction:new(...);
end

b_Reward_MapScriptFunction = API.InstanceTable(b_Reprisal_MapScriptFunction);
b_Reward_MapScriptFunction.Name = "Reward_MapScriptFunction";
b_Reward_MapScriptFunction.Description.en = "Reward: Calls a function within the global map script if the quest has failed.";
b_Reward_MapScriptFunction.Description.de = "Lohn: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.";
b_Reward_MapScriptFunction.GetReprisalTable = nil;

b_Reward_MapScriptFunction.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction}};
end

Core:RegisterBehavior(b_Reward_MapScriptFunction);

-- -------------------------------------------------------------------------- --

---
-- Erlaubt oder verbietet einem Spieler ein Recht.
--
-- @param _PlayerID   ID des Spielers
-- @param _Lock       Sperren/Entsperren
-- @param _Technology Name des Rechts
--
-- @within Reward
--
function Reward_Technology(...)
    return b_Reward_Technology:new(...);
end

b_Reward_Technology = API.InstanceTable(b_Reprisal_Technology);
b_Reward_Technology.Name = "Reward_Technology";
b_Reward_Technology.Description.en = "Reward: Locks or unlocks a technology for the given player.";
b_Reward_Technology.Description.de = "Lohn: Sperrt oder erlaubt eine Technolgie für den angegebenen Player.";
b_Reward_Technology.GetReprisalTable = nil;

b_Reward_Technology.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_Technology);

---
-- Gibt dem Auftragnehmer eine Anzahl an Prestigepunkten.
--
-- Prestige hat i.d.R. keine Funktion und wird nur als Zusatzpunkte in der
-- Statistik angezeigt.
--
-- @param _Amount Menge an Prestige
--
-- @within Reward
--
function Reward_PrestigePoints(...)
    return b_Reward_PrestigePoints:mew(...);
end

b_Reward_PrestigePoints  = {
    Name = "Reward_PrestigePoints",
    Description = {
        en = "Reward: Prestige",
        de = "Lohn: Prestige",
    },
    Parameter = {
        { ParameterType.Number, en = "Points", de = "Punkte" },
    },
}

function b_Reward_PrestigePoints :AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Points = _Parameter
    end
end

function b_Reward_PrestigePoints :GetRewardTable()
    return { Reward.PrestigePoints, self.Points }
end

Core:RegisterBehavior(b_Reward_PrestigePoints);

-- -------------------------------------------------------------------------- --

---
-- Besetzt einen Außenposten mit Soldaten.
--
-- @param _ScriptName Skriptname des Außenposten
-- @param _Type       Soldatentyp
--
-- @within Reward
--
function Reward_AI_MountOutpost(...)
    return b_Reward_AI_MountOutpost:new(...);
end

b_Reward_AI_MountOutpost = {
    Name = "Reward_AI_MountOutpost",
    Description = {
        en = "Reward: Places a troop of soldiers on a named outpost.",
        de = "Lohn: Platziert einen Trupp Soldaten auf einem Aussenposten der KI.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
        { ParameterType.Custom,      en = "Soldiers type", de = "Soldatentyp" },
    },
}

function b_Reward_AI_MountOutpost:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_MountOutpost:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Scriptname = _Parameter
    else
        self.SoldiersType = _Parameter
    end
end

function b_Reward_AI_MountOutpost:CustomFunction(_Quest)
    local outpostID = assert(
        not Logic.IsEntityDestroyed(self.Scriptname) and GetID(self.Scriptname),
       _Quest.Identifier .. ": Error in " .. self.Name .. ": CustomFunction: Outpost is invalid"
    )
    local AIPlayerID = Logic.EntityGetPlayer(outpostID)
    local ax, ay = Logic.GetBuildingApproachPosition(outpostID)
    local TroopID = Logic.CreateBattalionOnUnblockedLand(Entities[self.SoldiersType], ax, ay, 0, AIPlayerID, 0)
    AICore.HideEntityFromAI(AIPlayerID, TroopID, true)
    Logic.CommandEntityToMountBuilding(TroopID, outpostID)
end

function b_Reward_AI_MountOutpost:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {}
        for k,v in pairs(Entities) do
            if string.find(k, "U_MilitaryBandit") or string.find(k, "U_MilitarySword") or string.find(k, "U_MilitaryBow") then
                Data[#Data+1] = k
            end
        end
        return Data
    end
end

function b_Reward_AI_MountOutpost:Debug(_Quest)
    if Logic.IsEntityDestroyed(self.Scriptname) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Outpost " .. self.Scriptname .. " is missing")
        return true
    end
end

Core:RegisterBehavior(b_Reward_AI_MountOutpost)

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest neu und lößt ihn sofort aus.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestRestartForceActive(...)
    return b_Reward_QuestRestartForceActive:new(...);
end

b_Reward_QuestRestartForceActive = {
    Name = "Reward_QuestRestartForceActive",
    Description = {
        en = "Reward: Restarts a (completed) quest and triggers it immediately.",
        de = "Lohn: Startet eine (beendete) Quest neu und triggert sie sofort.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reward_QuestRestartForceActive:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_QuestRestartForceActive:AddParameter(_Index, _Parameter)
    self.QuestName = _Parameter
end

function b_Reward_QuestRestartForceActive:CustomFunction(_Quest)
    local QuestID, Quest = self:ResetQuest(_Quest);
    if QuestID then
        Quest:SetMsgKeyOverride();
        Quest:SetIconOverride();
        Quest:Trigger();
    end
end

b_Reward_QuestRestartForceActive.ResetQuest = b_Reward_QuestRestart.CustomFunction;
function b_Reward_QuestRestartForceActive:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_QuestRestartForceActive)

-- -------------------------------------------------------------------------- --

---
-- Baut das angegebene Gabäude um eine Stufe aus. Das Gebäude wird durch einen
-- Arbeiter um eine Stufe erweitert. Der Arbeiter muss zuerst aus dem Lagerhaus
-- kommen und sich zum Gebäude bewegen.
--
-- <b>Achtung:</b> Ein Gebäude muss erst fertig ausgebaut sein, bevor ein
-- weiterer Ausbau begonnen werden kann!
--
-- @param _ScriptName Skriptname des Gebäudes
--
-- @within Reward
--
function Reward_UpgradeBuilding(...)
    return b_Reward_UpgradeBuilding:new(...);
end

b_Reward_UpgradeBuilding = {
    Name = "Reward_UpgradeBuilding",
    Description = {
        en = "Reward: Upgrades a building",
        de = "Lohn: Baut ein Gebäude aus"
    },
    Parameter =    {
        { ParameterType.ScriptName, en = "Building", de = "Gebäude" }
    }
};

function b_Reward_UpgradeBuilding:GetRewardTable()

    return {Reward.Custom, {self, self.CustomFunction}};

end

function b_Reward_UpgradeBuilding:AddParameter(_Index, _Parameter)

    if _Index == 0 then
        self.Building = _Parameter;
    end

end

function b_Reward_UpgradeBuilding:CustomFunction(_Quest)

    local building = GetID(self.Building);
    if building ~= 0
    and Logic.IsBuilding(building) == 1
    and Logic.IsBuildingUpgradable(building, true)
    and Logic.IsBuildingUpgradable(building, false)
    then
        Logic.UpgradeBuilding(building);
    end

end

function b_Reward_UpgradeBuilding:Debug(_Quest)

    local building = GetID(self.Building);
    if not (building ~= 0
            and Logic.IsBuilding(building) == 1
            and Logic.IsBuildingUpgradable(building, true)
            and Logic.IsBuildingUpgradable(building, false) )
    then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Building is wrong")
        return true
    end

end

Core:RegisterBehavior(b_Reward_UpgradeBuilding)

-- -------------------------------------------------------------------------- --
-- Trigger                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Starte den Quest, wenn ein anderer Spieler entdeckt wurde.
--
-- Ein Spieler ist dann entdeckt, wenn sein Heimatterritorium aufgedeckt wird.
--
-- @param _PlayerID Zu entdeckender Spieler
--
-- @within Trigger
--
function Trigger_PlayerDiscovered(...)
    return b_Trigger_PlayerDiscovered:new(...);
end

b_Trigger_PlayerDiscovered = {
    Name = "Trigger_PlayerDiscovered",
    Description = {
        en = "Trigger: if a given player has been discovered",
        de = "Auslöser: wenn ein angegebener Spieler entdeckt wurde",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Trigger_PlayerDiscovered:GetTriggerTable()
    return {Triggers.PlayerDiscovered, self.PlayerID}
end

function b_Trigger_PlayerDiscovered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1;
    end
end

Core:RegisterBehavior(b_Trigger_PlayerDiscovered);

-- -------------------------------------------------------------------------- --

---
-- Starte den Quest, wenn zwischen dem Empfänger und der angegebenen Partei
-- der geforderte Diplomatiestatus herrscht.
--
-- @param _PlayerID ID der Partei
-- @param _State    Diplomatie-Status
--
-- @within Trigger
--
function Trigger_OnDiplomacy(...)
    return b_Trigger_OnDiplomacy:new(...);
end

b_Trigger_OnDiplomacy = {
    Name = "Trigger_OnDiplomacy",
    Description = {
        en = "Trigger: if diplomatic relations have been established with a player",
        de = "Auslöser: wenn ein angegebener Diplomatie-Status mit einem Spieler erreicht wurde.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.DiplomacyState, en = "Relation", de = "Beziehung" },
    },
}

function b_Trigger_OnDiplomacy:GetTriggerTable()
    return {Triggers.Diplomacy, self.PlayerID, assert( DiplomacyStates[self.DiplState] ) }
end

function b_Trigger_OnDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.DiplState = _Parameter
    end
end

Core:RegisterBehavior(b_Trigger_OnDiplomacy);

-- -------------------------------------------------------------------------- --

---
-- Starte den Quest, sobald ein Bedürfnis nicht erfüllt wird.
--
-- @param _PlayerID ID des Spielers
-- @param _Need     Bedürfnis
-- @param _Amount   Menge an skreikenden Siedlern
--
-- @within Trigger
--
function Trigger_OnNeedUnsatisfied(...)
    return b_Trigger_OnNeedUnsatisfied:new(...);
end

b_Trigger_OnNeedUnsatisfied = {
    Name = "Trigger_OnNeedUnsatisfied",
    Description = {
        en = "Trigger: if a specified need is unsatisfied",
        de = "Auslöser: wenn ein bestimmtes Bedürfnis nicht befriedigt ist.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Need, en = "Need", de = "Bedürfnis" },
        { ParameterType.Number, en = "Workers on strike", de = "Streikende Arbeiter" },
    },
}

function b_Trigger_OnNeedUnsatisfied:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnNeedUnsatisfied:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    elseif (_Index == 2) then
        self.WorkersOnStrike = _Parameter * 1
    end
end

function b_Trigger_OnNeedUnsatisfied:CustomFunction(_Quest)
    return Logic.GetNumberOfStrikingWorkersPerNeed( self.PlayerID, Needs[self.Need] ) >= self.WorkersOnStrike
end

function b_Trigger_OnNeedUnsatisfied:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Needs[self.Need] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": " .. self.Need .. " does not exist.")
        return true
    elseif self.WorkersOnStrike < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": WorkersOnStrike value negative")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnNeedUnsatisfied);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn die angegebene Mine erschöpft ist.
--
-- @param _ScriptName Skriptname der Mine
--
-- @within Trigger
--
function Trigger_OnResourceDepleted(...)
    return b_Trigger_OnResourceDepleted:new(...);
end

b_Trigger_OnResourceDepleted = {
    Name = "Trigger_OnResourceDepleted",
    Description = {
        en = "Trigger: if a resource is (temporarily) depleted",
        de = "Auslöser: wenn eine Ressource (zeitweilig) verbraucht ist",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Trigger_OnResourceDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnResourceDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Trigger_OnResourceDepleted:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    return not ID or ID == 0 or Logic.GetResourceDoodadGoodType(ID) == 0 or Logic.GetResourceDoodadGoodAmount(ID) == 0
end

Core:RegisterBehavior(b_Trigger_OnResourceDepleted);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald der angegebene Spieler eine Menge an Rohstoffen
-- im Lagerhaus hat.
--
-- @param  _PlayerID ID des Spielers
-- @param  _Type     Typ des Rohstoffes
-- @param _Amount    Menge an Rohstoffen
--
-- @within Trigger
--
function Trigger_OnAmountOfGoods(...)
    return b_Trigger_OnAmountOfGoods:new(...);
end

b_Trigger_OnAmountOfGoods = {
    Name = "Trigger_OnAmountOfGoods",
    Description = {
        en = "Trigger: if the player has gathered a given amount of resources in his storehouse",
        de = "Auslöser: wenn der Spieler eine bestimmte Menge einer Ressource in seinem Lagerhaus hat",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.RawGoods, en = "Type of good", de = "Resourcentyp" },
        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },
    },
}

function b_Trigger_OnAmountOfGoods:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnAmountOfGoods:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 2) then
        self.GoodAmount = _Parameter * 1
    end
end

function b_Trigger_OnAmountOfGoods:CustomFunction(_Quest)
    local StoreHouseID = Logic.GetStoreHouse(self.PlayerID)
    if (StoreHouseID == 0) then
        return false
    end
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    local GoodAmount = Logic.GetAmountOnOutStockByGoodType(StoreHouseID, GoodType)
    if (GoodAmount >= self.GoodAmount)then
        return true
    end
    return false
end

function b_Trigger_OnAmountOfGoods:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Goods[self.GoodTypeName] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Good type is wrong.")
        return true
    elseif self.GoodAmount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Good amount is negative.")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnAmountOfGoods);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer aktiv ist.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestActive(...)
    return b_Trigger_OnQuestActiveWait:new(...);
end
Trigger_OnQuestActiveWait = Trigger_OnQuestActive;

b_Trigger_OnQuestActiveWait = {
    Name = "Trigger_OnQuestActiveWait",
    Description = {
        en = "Trigger: if a given quest has been activated. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest aktiviert wurde. Optional mit Wartezeit",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestActiveWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestActiveWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestActiveWait:CustomFunction(_Quest)
    local QuestID = GetQuestID(self.QuestName)
    if QuestID ~= nil then
        assert(type(QuestID) == "number");

        if (Quests[QuestID].State == QuestState.Active) then
            self.WasActivated = self.WasActivated or true;
        end
        if self.WasActivated then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestActiveWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestActiveWait:Interrupt(_Quest)
    -- does this realy matter after interrupt?
    -- self.WaitTimeTimer = nil;
    -- self.WasActivated = nil;
end

function b_Trigger_OnQuestActiveWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
    self.WasActivated = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestActiveWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
b_Trigger_OnQuestActive = API.InstanceTable(b_Trigger_OnQuestActiveWait);
b_Trigger_OnQuestActive.Name = "Trigger_OnQuestActive";
b_Trigger_OnQuestActive.Description.en = "Reward: Starts the quest after another has been activated.";
b_Trigger_OnQuestActive.Description.de = "Lohn: Startet den Quest, wenn ein anderer aktiviert wird.";
b_Trigger_OnQuestActive.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
}

function b_Trigger_OnQuestActive:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Core:RegisterBehavior(b_Trigger_OnQuestActive);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest, sobald ein anderer fehlschlägt.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestFailure(...)
    return b_Trigger_OnQuestFailureWait:new(...);
end
Trigger_OnQuestFailureWait = Trigger_OnQuestFailure;

b_Trigger_OnQuestFailureWait = {
    Name = "Trigger_OnQuestFailureWait",
    Description = {
        en = "Trigger: if a given quest has failed. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest fehlgeschlagen ist. Optional mit Wartezeit",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestFailureWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestFailureWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestFailureWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Failure) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestFailureWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestFailureWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function b_Trigger_OnQuestFailureWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestFailureWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
b_Trigger_OnQuestFailure = API.InstanceTable(b_Trigger_OnQuestFailureWait);
b_Trigger_OnQuestFailure.Name = "Trigger_OnQuestFailure";
b_Trigger_OnQuestFailure.Description.en = "Reward: Starts the quest after another has failed.";
b_Trigger_OnQuestFailure.Description.de = "Lohn: Startet den Quest, wenn ein anderer fehlschlägt.";
b_Trigger_OnQuestFailure.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
}

function b_Trigger_OnQuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Core:RegisterBehavior(b_Trigger_OnQuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest, wenn ein anderer noch nicht ausgelöst wurde.
--
-- @param _QuestName Name des Quest
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestNotTriggered(...)
    return b_Trigger_OnQuestNotTriggered:new(...);
end

b_Trigger_OnQuestNotTriggered = {
    Name = "Trigger_OnQuestNotTriggered",
    Description = {
        en = "Trigger: if a given quest is not yet active. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest noch inaktiv ist. Sollte mit weiteren Triggern kombiniert werden.",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
    },
}

function b_Trigger_OnQuestNotTriggered:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestNotTriggered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Trigger_OnQuestNotTriggered:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.NotTriggered) then
            return true;
        end
    end
    return false;
end

function b_Trigger_OnQuestNotTriggered:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnQuestNotTriggered);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer unterbrochen wurde.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestInterrupted(...)
    return b_Trigger_OnQuestInterruptedWait:new(...);
end
Trigger_OnQuestInterruptedWait = Trigger_OnQuestInterrupted;

b_Trigger_OnQuestInterruptedWait = {
    Name = "Trigger_OnQuestInterruptedWait",
    Description = {
        en = "Trigger: if a given quest has been interrupted. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest abgebrochen wurde. Sollte mit weiteren Triggern kombiniert werden.",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestInterruptedWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestInterruptedWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestInterruptedWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result == QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestInterruptedWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestInterruptedWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function b_Trigger_OnQuestInterruptedWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestInterruptedWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
b_Trigger_OnQuestInterrupted = API.InstanceTable(b_Trigger_OnQuestInterruptedWait);
b_Trigger_OnQuestInterrupted.Name = "Trigger_OnQuestInterrupted";
b_Trigger_OnQuestInterrupted.Description.en = "Reward: Starts the quest after another is interrupted.";
b_Trigger_OnQuestInterrupted.Description.de = "Lohn: Startet den Quest, wenn ein anderer abgebrochen wurde.";
b_Trigger_OnQuestInterrupted.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
}

function b_Trigger_OnQuestInterrupted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Core:RegisterBehavior(b_Trigger_OnQuestInterrupted);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer bendet wurde.
--
-- Dabei ist das Resultat egal. Der Quest kann entweder erfolgreich beendet
-- wurden oder fehlgeschlagen sein.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestOver(...)
    return b_Trigger_OnQuestOverWait:new(...);
end
Trigger_OnQuestOverWait = Trigger_OnQuestOver;

b_Trigger_OnQuestOverWait = {
    Name = "Trigger_OnQuestOverWait",
    Description = {
        en = "Trigger: if a given quest has been finished, regardless of its result. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest beendet wurde, unabhängig von deren Ergebnis. Wartezeit optional",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestOverWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestOverWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestOverWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestOverWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestOverWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function b_Trigger_OnQuestOverWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestOverWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
b_Trigger_OnQuestOver = API.InstanceTable(b_Trigger_OnQuestOverWait);
b_Trigger_OnQuestOver.Name = "Trigger_OnQuestOver";
b_Trigger_OnQuestOver.Description.en = "Reward: Starts the quest after another finished.";
b_Trigger_OnQuestOver.Description.de = "Lohn: Startet den Quest, wenn ein anderer abgeschlossen wurde.";
b_Trigger_OnQuestOver.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
}

function b_Trigger_OnQuestOver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Core:RegisterBehavior(b_Trigger_OnQuestOver);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer Quest erfolgreich abgeschlossen wurde.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestSuccess(...)
    return b_Trigger_OnQuestSuccessWait:new(...);
end
Trigger_OnQuestSuccessWait = Trigger_OnQuestSuccess;

b_Trigger_OnQuestSuccessWait = {
    Name = "Trigger_OnQuestSuccessWait",
    Description = {
        en = "Trigger: if a given quest has been finished successfully. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest erfolgreich abgeschlossen wurde. Wartezeit optional",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestSuccessWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestSuccessWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestSuccessWait:CustomFunction()
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Success) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestSuccessWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        error(_Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        error(_Quest.Identifier.. ": " ..self.Name..": waittime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestSuccessWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function b_Trigger_OnQuestSuccessWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestSuccessWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
b_Trigger_OnQuestSuccess = API.InstanceTable(b_Trigger_OnQuestSuccessWait);
b_Trigger_OnQuestSuccess.Name = "Trigger_OnQuestSuccess";
b_Trigger_OnQuestSuccess.Description.en = "Reward: Starts the quest after another finished successfully.";
b_Trigger_OnQuestSuccess.Description.de = "Lohn: Startet den Quest, wenn ein anderer erfolgreich abgeschlossen wurde.";
b_Trigger_OnQuestSuccess.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
}

function b_Trigger_OnQuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

Core:RegisterBehavior(b_Trigger_OnQuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn eine benutzerdefinierte Variable einen bestimmten
-- Wert angenommen hat.
--
-- Benutzerdefinierte Variablen müssen Zahlen sein. Bevor eine
-- Variable in einem Goal abgefragt werden kann, muss sie zuvor mit
-- Reprisal_CustomVariables oder Reward_CutsomVariables initialisiert
-- worden sein.
--
-- @param _Name     Name der Variable
-- @param _Relation Vergleichsoperator
-- @param _Value    Wert oder Custom Variable
--
-- @within Trigger
--
function Trigger_CustomVariables(...)
    return b_Trigger_CustomVariables:new(...);
end

b_Trigger_CustomVariables = {
    Name = "Trigger_CustomVariables",
    Description = {
        en = "Trigger: if the variable has a certain value.",
        de = "Auslöser: wenn die Variable einen bestimmen Wert eingenommen hat.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable", de = "Variablennamen" },
        { ParameterType.Custom,  en = "Relation", de = "Relation" },
        { ParameterType.Default, en = "Value", de = "Wert" }
    }
};

function b_Trigger_CustomVariables:GetTriggerTable()
    return { Triggers.Custom2, {self, self.CustomFunction} };
end

function b_Trigger_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        value = (value ~= nil and value) or _Parameter;
        self.Value = value
    end
end

function b_Trigger_CustomVariables:CustomFunction()
    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;

    if self.Relation == "==" then
        return _G["QSB_CustomVariables_"..self.VariableName] == ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    elseif self.Relation ~= "~=" then
        return _G["QSB_CustomVariables_"..self.VariableName] ~= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    elseif self.Relation == ">" then
        return _G["QSB_CustomVariables_"..self.VariableName] > ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    elseif self.Relation == ">=" then
        return _G["QSB_CustomVariables_"..self.VariableName] >= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    elseif self.Relation == "<=" then
        return _G["QSB_CustomVariables_"..self.VariableName] <= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    else
        return _G["QSB_CustomVariables_"..self.VariableName] < ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    end
    return false;
end

function b_Trigger_CustomVariables:GetCustomData( _Index )
    if _Index == 1 then
        return {"==", "~=", "<=", "<", ">", ">="};
    end
end

function b_Trigger_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "<=", "<", ">", ">="}
    local results    = {true, false, nil}

    if not _G["QSB_CustomVariables_"..self.VariableName] then
        warn(_Quest.Identifier.. ": " ..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not Inside(self.Relation,relations) then
        error(_Quest.Identifier.. ": " ..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sofort.
--
-- @within Trigger
--
function Trigger_AlwaysActive()
    return b_Trigger_AlwaysActive:new()
end

b_Trigger_AlwaysActive = {
    Name = "Trigger_AlwaysActive",
    Description = {
        en = "Trigger: the map has been started.",
        de = "Auslöser: Start der Karte.",
    },
}

function b_Trigger_AlwaysActive:GetTriggerTable()
    return {Triggers.Time, 0 }
end

Core:RegisterBehavior(b_Trigger_AlwaysActive);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest im angegebenen Monat.
--
-- @param _Month Monat
--
-- @within Trigger
--
function Trigger_OnMonth(...)
    return b_Trigger_OnMonth:new(...);
end

b_Trigger_OnMonth = {
    Name = "Trigger_OnMonth",
    Description = {
        en = "Trigger: a specified month",
        de = "Auslöser: ein bestimmter Monat",
    },
    Parameter = {
        { ParameterType.Custom, en = "Month", de = "Monat" },
    },
}

function b_Trigger_OnMonth:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnMonth:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Month = _Parameter * 1
    end
end

function b_Trigger_OnMonth:CustomFunction(_Quest)
    return self.Month == Logic.GetCurrentMonth()
end

function b_Trigger_OnMonth:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for i = 1, 12 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function b_Trigger_OnMonth:Debug(_Quest)
    if self.Month < 1 or self.Month > 12 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Month has the wrong value")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnMonth);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sobald der Monsunregen einsetzt.
--
-- <b>Achtung:</b> Dieses Behavior ist nur für Reich des Ostens verfügbar.
--
-- @within Trigger
--
function Trigger_OnMonsoon()
    return b_Trigger_OnMonsoon:new();
end

b_Trigger_OnMonsoon = {
    Name = "Trigger_OnMonsoon",
    Description = {
        en = "Trigger: on monsoon.",
        de = "Auslöser: wenn der Monsun beginnt.",
    },
    RequiresExtraNo = 1,
}

function b_Trigger_OnMonsoon:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnMonsoon:CustomFunction(_Quest)
    if Logic.GetWeatherDoesShallowWaterFlood(0) then
        return true
    end
end

Core:RegisterBehavior(b_Trigger_OnMonsoon);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sobald der Timer abgelaufen ist.
--
-- Der Timer zählt immer vom Start der Map an.
--
-- @param _Time Zeit bis zum Start
--
-- @within Trigger
--
function Trigger_Time(...)
    return b_Trigger_Time:new(...);
end

b_Trigger_Time = {
    Name = "Trigger_Time",
    Description = {
        en = "Trigger: a given amount of time since map start",
        de = "Auslöser: eine gewisse Anzahl Sekunden nach Spielbeginn",
    },
    Parameter = {
        { ParameterType.Number, en = "Time (sec.)", de = "Zeit (Sek.)" },
    },
}

function b_Trigger_Time:GetTriggerTable()
    return {Triggers.Time, self.Time }
end

function b_Trigger_Time:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Time = _Parameter * 1
    end
end

Core:RegisterBehavior(b_Trigger_Time);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sobald das Wasser gefriert.
--
-- @within Trigger
--
function Trigger_OnWaterFreezes()
    return b_Trigger_OnWaterFreezes:new();
end

b_Trigger_OnWaterFreezes = {
    Name = "Trigger_OnWaterFreezes",
    Description = {
        en = "Trigger: if the water starts freezing",
        de = "Auslöser: wenn die Gewässer gefrieren",
    },
}

function b_Trigger_OnWaterFreezes:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnWaterFreezes:CustomFunction(_Quest)
    if Logic.GetWeatherDoesWaterFreeze(0) then
        return true
    end
end

Core:RegisterBehavior(b_Trigger_OnWaterFreezes);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest niemals.
--
-- Quests, für die dieser Trigger gesetzt ist, müssen durch einen anderen
-- Quest über Reward_QuestActive oder Reprisal_QuestActive gestartet werden.
--
-- @within Trigger
--
function Trigger_NeverTriggered()
    return b_Trigger_NeverTriggered:new();
end

b_Trigger_NeverTriggered = {
    Name = "Trigger_NeverTriggered",
    Description = {
        en = "Never triggers a Quest. The quest may be set active by Reward_QuestActivate or Reward_QuestRestartForceActive",
        de = "Löst nie eine Quest aus. Die Quest kann von Reward_QuestActivate oder Reward_QuestRestartForceActive aktiviert werden.",
    },
}

function b_Trigger_NeverTriggered:GetTriggerTable()

    return {Triggers.Custom2, {self, function() end} }

end

Core:RegisterBehavior(b_Trigger_NeverTriggered)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald wenigstens einer von zwei Quests fehlschlägt.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastOneQuestFailure(...)
    return b_Trigger_OnAtLeastOneQuestFailure:new(...);
end

b_Trigger_OnAtLeastOneQuestFailure = {
    Name = "Trigger_OnAtLeastOneQuestFailure",
    Description = {
        en = "Trigger: if one or both of the given quests have failed.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge fehlgeschlagen sind.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },
    },
}

function b_Trigger_OnAtLeastOneQuestFailure:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_OnAtLeastOneQuestFailure:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function b_Trigger_OnAtLeastOneQuestFailure:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure) then
        return true;
    end
    return false;
end

function b_Trigger_OnAtLeastOneQuestFailure:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnAtLeastOneQuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald wenigstens einer von zwei Quests erfolgreich ist.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastOneQuestSuccess(...)
    return b_Trigger_OnAtLeastOneQuestSuccess:new(...);
end

b_Trigger_OnAtLeastOneQuestSuccess = {
    Name = "Trigger_OnAtLeastOneQuestSuccess",
    Description = {
        en = "Trigger: if one or both of the given quests are won.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge gewonnen wurden.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },
    },
}

function b_Trigger_OnAtLeastOneQuestSuccess:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_OnAtLeastOneQuestSuccess:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function b_Trigger_OnAtLeastOneQuestSuccess:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success) then
        return true;
    end
    return false;
end

function b_Trigger_OnAtLeastOneQuestSuccess:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnAtLeastOneQuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald mindestens X von Y Quests erfolgreich sind.
--
-- @param _MinAmount   Mindestens zu erfüllen (max. 5)
-- @param _QuestAmount Anzahl geprüfter Quests (max. 5 und >= _MinAmount)
-- @param _Quest1      Name des 1. Quest
-- @param _Quest2      Name des 2. Quest
-- @param _Quest3      Name des 3. Quest
-- @param _Quest4      Name des 4. Quest
-- @param _Quest5      Name des 5. Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastXOfYQuestsSuccess(...)
    return b_Trigger_OnAtLeastXOfYQuestsSuccess:new(...);
end

b_Trigger_OnAtLeastXOfYQuestsSuccess = {
    Name = "Trigger_OnAtLeastXOfYQuestsSuccess",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Auslöser: wenn X von Y angegebener Quests erfolgreich abgeschlossen wurden.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl" },
        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5" },
    },
}

function b_Trigger_OnAtLeastXOfYQuestsSuccess:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnAtLeastXOfYQuestsSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function b_Trigger_OnAtLeastXOfYQuestsSuccess:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
        local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
            if (Quests[QuestID].Result == QuestResult.Success) then
                least = least + 1
                if least >= self.LeastAmount then
                    return true
                end
            end
        end
    end
    return false
end

function b_Trigger_OnAtLeastXOfYQuestsSuccess:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount <= 0 or leastAmount >5 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount <= 0 or questAmount > 5 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount > questAmount then
        error(_Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            error(_Quest.Identifier.. ": " ..self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function b_Trigger_OnAtLeastXOfYQuestsSuccess:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

Core:RegisterBehavior(b_Trigger_OnAtLeastXOfYQuestsSuccess)

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Trigger aus.
--
-- Die Funktion muss entweder true or false zurückgeben.
--
-- Nur Skipt: Wird statt einem Funktionsnamen (String) eine Funktionsreferenz
-- übergeben, werden alle weiteren Parameter an die Funktion weitergereicht.
--
-- @param _FunctionName Name der Funktion
--
-- @within Trigger
--
function Trigger_MapScriptFunction(...)
    return b_Trigger_MapScriptFunction:new(...);
end

b_Trigger_MapScriptFunction = {
    Name = "Trigger_MapScriptFunction",
    Description = {
        en = "Calls a function within the global map script. If the function returns true the quest will be started",
        de = "Ruft eine Funktion im globalen Skript auf. Wenn sie true sendet, wird die Quest gestartet.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname" },
    },
}

function b_Trigger_MapScriptFunction:GetTriggerTable(_Quest)
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function b_Trigger_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.FuncName(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function b_Trigger_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        error(_Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        error(_Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_MapScriptFunction);

-- -------------------------------------------------------------------------- --
-- Veränderte Behavior (Build 1410)                                           --
-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss im Chatdialog eine Eingabe tätigen.
--
-- Die Eingabe wird im Quest gespeichert und kann zur späteren Verarbeitung
-- angefragt werden.
--
-- Das Behaviour kann auch eingesetzt werden, um ein Passwort zu prüfen.
-- In diesem Fall wird die Eingabe mit dem Passwort verglichen. Die Anzal der
-- Versuche bestimmt, wie oft falsch eingegeben werden darf.
--
-- Wenn die Anzahl der Versuche begrenzt ist, wird eine Srandardnachricht mit
-- den übrigen Versuchen angezeigt. Optional kann eine Nachricht angegeben
-- werden, die stattdessen nach <u>jeder</u> Falscheingabe, <u>außer</u> der
-- letzten, angezeigt wird.
--
-- @param _Passwords Liste der Passwörter
-- @param _Trials    Anzahl versuche (0 für unendlich)
-- @param _Message   Alternative Fehlernachricht
--
-- @within Goal
--
function Goal_InputDialog(...)
    return b_Goal_InputDialog:new(...);
end

b_Goal_InputDialog  = {
    Name = "Goal_InputDialog",
    Description = {
        en = "Goal: Player must type in something. The passwords have to be seperated by ; and whitespaces will be ignored.",
        de = "Ziel: Oeffnet einen Dialog, der Spieler muss Lösungswörter eingeben. Diese sind durch ; abzutrennen. Leerzeichen werden ignoriert.",
    },
    DefaultMessage = {
        de = "Versuche bis zum Fehlschlag: ",
        en = "Trials remaining until failure: "
    },
    Parameter = {
        {ParameterType.Default, en = "Password to enter", de = "Einzugebendes Passwort" },
        {ParameterType.Number, en = "Trials till failure (0 endless)", de = "Versuche bis Fehlschlag (0 endlos)" },
        {ParameterType.Default, en = "Wrong password message", de = "Text bei Falscheingabe" },
    }
}

function b_Goal_InputDialog:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction}}
end

function b_Goal_InputDialog:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Password = self:LowerCase(_Parameter or "");
    elseif (_Index == 1) then
        self.Trials = (_Parameter or 0) * 1;
    elseif (_Index == 2) then
        self.Message = _Parameter;
        local lang = QSB.Language;
        if type(self.Message) == "table" then
            self.Message = self.Message[lang];
        end
    end
end

function b_Goal_InputDialog:CustomFunction(_Quest)
    local Box = function(_QuestName)
        if not self.Shown then
            self:InitReturnVariable(_QuestName);
            self:ShowBox();
            self.Shown = true;
        end
    end

    if not IsBriefingActive or (IsBriefingActive and IsBriefingActive() == false) then
        if (not self.Trials) or (self.Trials) == 0 then
            Box(_Quest.Identifier);
        elseif not self.Shown then
            self.TrialCounter = self.TrialCounter or self.Trials;
            Box(_Quest.Identifier);
            self.TrialCounter = self.TrialCounter - 1;
        end

        if _Quest.InputDialogResult then
            Logic.ExecuteInLuaLocalState([[
                GUI_Chat.Confirm = GUI_Chat.Confirm_Orig_Goal_InputDialog
                GUI_Chat.Confirm_Orig_Goal_InputDialog = nil
                GUI_Chat.Abort = GUI_Chat.Abort_Orig_Goal_InputDialog
                GUI_Chat.Abort_Orig_Goal_InputDialog = nil
            ]]);

            if self.Password ~= nil and self.Password ~= "" then
                self.Shown = nil;

                if self:LowerCase(_Quest.InputDialogResult) == self.Password then
                    return true;
                elseif (self.Trials == 0) or (self.Trials > 0 and self.TrialCounter > 0) then
                    self:OnWrongInput(_Quest);
                    return;
                else
                    return false;
                end
            end
            return true;
        end
    end
end

function b_Goal_InputDialog:OnWrongInput(_Quest)
    if self.Trials > 0 and not self.Message then
        local lang = QSB.Language;
        Logic.DEBUG_AddNote(self.DefaultMessage .. self.TrialCounter);
        return;
    end
    if self.Message then
        Logic.DEBUG_AddNote(self.Message);
    end
    _Quest.InputDialogResult = nil;
end

function b_Goal_InputDialog:LowerCase(_Text)
    _Text = _Text:lower(_Text);
    -- Umlaute manuell austauschen
    -- FIXME: Ausländische Umlaute auch anpassen.
    _Text = _Text:gsub("Ä", "ä");
    _Text = _Text:gsub("Ö", "ö");
    _Text = _Text:gsub("Ü", "ü");
    return _Text;
end

function b_Goal_InputDialog:ShowBox()
    Logic.ExecuteInLuaLocalState([[
        Input.ChatMode()
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",1)
        XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "")
        XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput")
    ]])
end

function b_Goal_InputDialog:InitReturnVariable(_QuestName)
    Logic.ExecuteInLuaLocalState([[
        GUI_Chat.Abort_Orig_Goal_InputDialog = GUI_Chat.Abort
        GUI_Chat.Confirm_Orig_Goal_InputDialog = GUI_Chat.Confirm

        GUI_Chat.Confirm = function()
            Input.GameMode()
            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",0)
            local ChatMessage = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput")
            g_Chat.JustClosed = 1
            GUI.SendScriptCommand("Quests[GetQuestID(']].. _QuestName ..[[')].InputDialogResult = '"..ChatMessage.."'")
        end
        GUI_Chat.Abort = function()
        end
    ]])
end

function b_Goal_InputDialog:Debug(_Quest)
    return false;
end

function b_Goal_InputDialog:GetIcon()
    return {12,2};
end

function b_Goal_InputDialog:Reset(_Quest)
    _Quest.InputDialogResult = nil;
    self.TrialCounter = nil;
    self.Shown = nil;
end

Core:RegisterBehavior(b_Goal_InputDialog);

-- -------------------------------------------------------------------------- --
-- Behavior Nachimplementiert(Build 1420)                                     --
-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein Effekt zerstört wird oder verschwindet.
--
-- <b>Achtung</b>: Das Behavior kann nur auf Effekte angewand werden, die
-- über Effekt-Behavior erzeugt wurden.
--
-- @param _EffectName Name des Effekt
--
-- @within Trigger
--
function Trigger_OnEffectDestroyed(...)
    return b_Trigger_OnEffectDestroyed:new(...);
end

b_Trigger_OnEffectDestroyed = {
    Name = "Trigger_OnEffectDestroyed",
    Description = {
        en = "Trigger: Starts a quest after an effect was destroyed",
        de = "Ausloeser: Startet eine Quest, nachdem ein Effekt zerstoert wurde",
    },
    Parameter = {
        { ParameterType.Default, en = "Effect name", de = "Effektname" },
    },
}

function b_Trigger_OnEffectDestroyed:GetTriggerTable()
    return { Triggers.Custom2, {self, self.CustomFunction} }
end

function b_Trigger_OnEffectDestroyed:AddParameter(_Index, _Parameter)
    if _Index == 0 then    
        self.EffectName = _Parameter
    end
end

function b_Trigger_OnEffectDestroyed:CustomFunction()
    return not QSB.EffectNameToID[self.EffectName] or not Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]);
end

function b_Trigger_OnEffectDestroyed:Debug(_Quest)
    if not QSB.EffectNameToID[self.EffectName] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Effect has never existed")
        return true
    end
end
Core:RegisterBehavior(b_Trigger_OnEffectDestroyed)

-- -------------------------------------------------------------------------- --

---
-- Setzt das Upgrade Level des angegebenen Gebäudes.
--
-- Ein Geböude erhält sofort eine neue Stufe, ohne dass ein Arbeiter kommen
-- und es ausbauen muss. Für eine Werkstatt wird ein neuer Arbeiter gespawnt.
--
-- @param _ScriptName Skriptname des Gebäudes
-- @param _Level Upgrade Level
--
-- @within Reward
--
function Reward_SetBuildingUpgradeLevel(...)
    return b_Reward_SetBuildingUpgradeLevel:new(...);
end

b_Reward_SetBuildingUpgradeLevel = {
    Name = "Reward_SetBuildingUpgradeLevel",
    Description = {
        en = "Sets the upgrade level of the specified building.",
        de = "Legt das Upgrade-Level eines Gebaeudes fest.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Building", de = "Gebäude" },
        { ParameterType.Custom, en = "Upgrade level", de = "Upgrade-Level" },
    }
};
 
function b_Reward_SetBuildingUpgradeLevel:GetRewardTable()

    return {Reward.Custom, self, self.CustomFunction};

end
 
function b_Reward_SetBuildingUpgradeLevel:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Building = _Parameter;
    elseif _Index == 1 then
        self.UpgradeLevel = tonumber(_Parameter);
    end
end
 
function b_Reward_SetBuildingUpgradeLevel:CustomFunction()
    local building = Logic.GetEntityIDByName(self.Building);
    local upgradeLevel = Logic.GetUpgradeLevel(building);
    local maxUpgradeLevel = Logic.GetMaxUpgradeLevel(building);
    if building ~= 0 
    and Logic.IsBuilding(building) == 1 
    and (Logic.IsBuildingUpgradable(building, true) 
    or (maxUpgradeLevel ~= 0 
    and maxUpgradeLevel == upgradeLevel)) 
    then
        Logic.SetUpgradableBuildingState(building, math.min(self.UpgradeLevel, maxUpgradeLevel), 0);
    end
end

function b_Reward_SetBuildingUpgradeLevel:Debug(_Quest)
    local building = Logic.GetEntityIDByName( self.Building )
    local maxUpgradeLevel = Logic.GetMaxUpgradeLevel(building);
    if not building or Logic.IsBuilding(building) == 0  then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Building " .. self.Building .. " is missing or no building.")
        return true
    elseif not self.UpgradeLevel or self.UpgradeLevel < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Upgrade level is wrong")
        return true
    end
end

function b_Reward_SetBuildingUpgradeLevel:GetCustomData(_Index)
    if _Index == 1 then
        return { "0", "1", "2", "3" };
    end
end

Core:RegisterBehavior(b_Reward_SetBuildingUpgradeLevel);

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleClassicBehaviors = {
    Global = {
        Data = {
            BehaviorQuestCounter = 0,
        }
    },
    Local = {},
    
    Text = {
        DestroySoldiers = {
            de = "{center}SOLDATEN ZERSTÖREN {cr}{cr}von der Partei: %s{cr}{cr}Anzahl: %d",
            en = "{center}DESTROY SOLDIERS {cr}{cr}from faction: %s{cr}{cr}Amount: %d",
        },
        ActivateBuff = {
            Pattern = {
                de = "BONUS AKTIVIEREN{cr}{cr}%s",
                en = "ACTIVATE BUFF{cr}{cr}%s",
            },

            BuffsVanilla = {
                ["Buff_Spice"]                  = {de = "Salz", en = "Salt"},
                ["Buff_Colour"]                 = {de = "Farben", en = "Color"},
                ["Buff_Entertainers"]           = {de = "Entertainer", en = "Entertainer"},
                ["Buff_FoodDiversity"]          = {de = "Vielfältige Nahrung", en = "Food diversity"},
                ["Buff_ClothesDiversity"]       = {de = "Vielfältige Kleidung", en = "Clothes diversity"},
                ["Buff_HygieneDiversity"]       = {de = "Vielfältige Reinigung", en = "Hygiene diversity"},
                ["Buff_EntertainmentDiversity"] = {de = "Vielfältige Unterhaltung", en = "Entertainment diversity"},
                ["Buff_Sermon"]                 = {de = "Predigt", en = "Sermon"},
                ["Buff_Festival"]               = {de = "Fest", en = "Festival"},
                ["Buff_ExtraPayment"]           = {de = "Sonderzahlung", en = "Extra payment"},
                ["Buff_HighTaxes"]              = {de = "Hohe Steuern", en = "High taxes"},
                ["Buff_NoPayment"]              = {de = "Kein Sold", en = "No payment"},
                ["Buff_NoTaxes"]                = {de = "Keine Steuern", en = "No taxes"},
            },
            BuffsEx1 = {
                ["Buff_Gems"]              = {de = "Edelsteine", en = "Gems"},
                ["Buff_MusicalInstrument"] = {de = "Musikinstrumente", en = "Musical instruments"},
                ["Buff_Olibanum"]          = {de = "Weihrauch", en = "Olibanum"},
            }
        },
        SoldierCount = {
            Pattern = {
                de = "SOLDATENANZAHL {cr}Partei: %s{cr}{cr}%s %d",
                en = "SOLDIER COUNT {cr}Faction: %s{cr}{cr}%s %d",
            },
            Relation = {
                ["true"]  = {de = "Weniger als ", en = "Less than "},
                ["false"] = {de = "Mindestens ", en = "At least "},
            }
        },
        Festivals = {
            Pattern = {
                de = "FESTE FEIERN {cr}{cr}Partei: %s{cr}{cr}Anzahl: %d",
                en = "HOLD PARTIES {cr}{cr}Faction: %s{cr}{cr}Amount: %d",
            },
        }
    }
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Global:Install()
    self:OverrideIsObjectiveCompleted();
    self:OverrideQuestMarkers();
end

---
-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog zurück.
--
-- <b>Hinweis</b>: Es wird nur die letzte Eingabe zurückgegeben.
--
-- @param[type=string] _QuestName Name des Quest
-- @return[type=string] Eingabe des Spielers
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Global:GetInputFromQuest(_QuestName)
    local Quest = Quests[GetQuestID(_QuestName)];
    if not Quest then
        return;
    end
    return Quest.InputDialogResult;
end

---
-- Überschreibt die Funktionen zur Steuerung der Questmarker.
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Global:OverrideQuestMarkers()
    QuestTemplate.RemoveQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[4] then
                    DestroyQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end

    QuestTemplate.ShowQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[4] then
                    ShowQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end

    function ShowQuestMarker(_Entity)
        local eID = GetID(_Entity);
        local x,y = Logic.GetEntityPosition(eID);
        local Marker = EGL_Effects.E_Questmarker_low;
        if Logic.IsBuilding(eID) == 1 then
            Marker = EGL_Effects.E_Questmarker;
        end
        DestroyQuestMarker(_Entity);
        Questmarkers[eID] = Logic.CreateEffect(Marker, x, y, 0);
    end

    function DestroyQuestMarker(_Entity)
        local eID = GetID(_Entity);
        if Questmarkers[eID] ~= nil then
            Logic.DestroyEffect(Questmarkers[eID]);
            Questmarkers[eID] = nil;
        end
    end
end

---
-- Überschreibt IsObjectiveCompleted und behebt einen Fehler in dem
-- Objective "DestroyAllPlayerUnits", der Baustellen ignorierte.
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Global:OverrideIsObjectiveCompleted()
    QuestTemplate.IsObjectiveCompleted_Orig_QSB_ClassicBehaviors = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        if objective.Completed ~= nil then
            return objective.Completed;
        end
        local data = objective.Data;

        -- Behebt den Fehler, dass Baustellen eines Spielers fälschlicher
        -- Weise den Spieler als noch nicht besiegt ausweisen.
        if objectiveType == Objective.DestroyAllPlayerUnits then
            local PlayerEntities = GetPlayerEntities(data, 0);
            local IllegalEntities = {};
            
            for i= #PlayerEntities, 1, -1 do
                local Type = Logic.GetEntityType(PlayerEntities[i]);
                if Logic.IsEntityInCategory(PlayerEntities[i], EntityCategories.AttackableBuilding) == 0 or Logic.IsEntityInCategory(PlayerEntities[i], EntityCategories.Wall) == 0 then
                    if Logic.IsConstructionComplete(PlayerEntities[i]) == 0 then
                        table.insert(IllegalEntities, PlayerEntities[i]);
                    end
                end
                local IndestructableEntities = {Entities.XD_ScriptEntity, Entities.S_AIHomePosition, Entities.S_AIAreaDefinition};
                if Inside(Type, IndestructableEntities) then
                    table.insert(IllegalEntities, PlayerEntities[i]);
                end
            end

            if #PlayerEntities == 0 or #PlayerEntities - #IllegalEntities == 0 then
                objective.Completed = true;
            end
        elseif objectiveType == Objective.Distance then
            objective.Completed = BundleClassicBehaviors.Global:IsQuestPositionReached(self, objective);
        else
            return self:IsObjectiveCompleted_Orig_QSB_ClassicBehaviors(objective);
        end
    end
end

---
-- Prüft, ob das Entity das Ziel erreicht hat.
-- @param[type=table] _Quest     Quest Data
-- @param[type=table] _Objective Behavior Data
-- @return[type=boolean] Ziel wurde erreicht
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Global:IsQuestPositionReached(_Quest, _Objective)
    local IDdata2 = GetID(_Objective.Data[1]);
    if IDdata2 == -65566 then
        _Objective.Data[1] = Logic.GetKnightID(_Quest.ReceivingPlayer);
        IDdata2 = _Objective.Data[1];
    end
    local IDdata3 = GetID(_Objective.Data[2]);
    _Objective.Data[3] = _Objective.Data[3] or 2500;
    if not (Logic.IsEntityDestroyed(IDdata2) or Logic.IsEntityDestroyed(IDdata3)) then
        if Logic.GetDistanceBetweenEntities(IDdata2,IDdata3) <= _Objective.Data[3] then
            DestroyQuestMarker(IDdata3);
            return true;
        end
    else
        DestroyQuestMarker(IDdata3);
        return false;
    end
end

---
-- Bricht den Slave Quest eines Tribute Behavior ab.
-- @param[type=table] _Quest     Quest Data
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Global:OnQuestSkipped(_Quest)
    for k, v in pairs(_Quest.Objectives) do
        if  type(v) == "table" 
        and v.Type == Objective.Custom2 
        and v.Data
        and v.Data[1]
        and v.Data[1].Name:find("Goal_Tribute")
        and v.Data[1].InternTributeQuest then
            v.Data[1].InternTributeQuest:Interrupt();
        end
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Local:Install()
    self:OverrideDisplayQuestObjective();
end

---
-- Stellt sicher, dass für Objective.Distance immer ein Icon bereit steht,
-- wenn das Moving Entity der Primary Knight ist.
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Local:OverrideDisplayQuestObjective()
    GUI_Interaction.DisplayQuestObjective_Orig_BundleClasicBehaviors = GUI_Interaction.DisplayQuestObjective
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        if QuestType == Objective.Distance then
            if Quest.Objectives[1].Data[1] == -65566 then
                Quest.Objectives[1].Data[1] = Logic.GetKnightID(Quest.ReceivingPlayer);
            end
        end
        GUI_Interaction.DisplayQuestObjective_Orig_BundleClasicBehaviors(_QuestIndex, _MessageKey);
    end
end

Core:RegisterBundle("BundleClassicBehaviors");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleQuestGeneration                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle ermöglicht es einen Quest, bzw. Auftrag, per Skript zu 
-- erstellen.
--
-- Normaler Weise werden Aufträge im Questassistenten erzeugt. Dies ist aber
-- statisch und das Kopieren von Aufträgen ist nicht möglich. Wenn Aufträge
-- im Skript erzeugt werden, verschwinden alle diese Nachteile. Aufträge
-- können im Skript kopiert und angepasst werden. Es ist ebenfalls machbar,
-- die Aufträge in Sequenzen zu erzeugen.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleQuestGeneration = {};

API = API or {};
QSB = QSB or {};

QSB.GeneratedQuestDialogs = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt einen Quest.
--
-- Ein Auftrag braucht immer wenigstens ein Goal und einen Trigger um ihn
-- erstellen zu können. Hat ein Quest keinen Namen, erhält er automatisch
-- einen mit fortlaufender Nummerierung.
--
-- Ein Quest besteht aus verschiedenen Eigenschaften und Behavior, die nicht
-- alle zwingend gesetzt werden müssen. Behavior werden einfach nach den
-- Eigenschaften nacheinander angegeben.
-- <p><u>Eigenschaften:</u></p>
-- <ul>
-- <li>Name: Der eindeutige Name des Quests</li>
-- <li>Sender: PlayerID des Auftraggeber (Default 1)</li>
-- <li>Receiver: PlayerID des Auftragnehmer (Default 1)</li>
-- <li>Suggestion: Vorschlagnachricht des Quests</li>
-- <li>Success: Erfolgsnachricht des Quest</li>
-- <li>Failure: Fehlschlagnachricht des Quest</li>
-- <li>Description: Aufgabenbeschreibung (Nur bei Custom)</li>
-- <li>Time: Zeit bis zu, Fehlschlag/Abschluss</li>
-- <li>Loop: Funktion, die während der Laufzeit des Quests aufgerufen wird</li>
-- <li>Callback: Funktion, die nach Abschluss aufgerufen wird</li>
-- <li>Skip: Funktion, die beim überspringen aufgerufen wird</li>
-- </ul>
--
-- <p><b>Alias:</b> AddQuest</p>
--
-- @param[type=table] _Data Questdefinition
-- @return[type=string] Name des Quests
-- @return[type=number] Gesamtzahl Quests
-- @within Anwenderfunktionen
--
-- @usage
-- AddQuest {
--     Name        = "ExampleQuest",
--     Suggestion  = "Wir müssen das Kloster finden.",
--     Success     = "Dies sind die berümten Heilermönche.",
--
--     Goal_DiscoverPlayer(4),
--     Reward_Diplomacy(1, 4, "EstablishedContact"),
--     Trigger_Time(0),
-- }
--
function API.CreateQuest(_Data)
    if GUI then
        return;
    end
    if _Data.Name and Quests[GetQuestID(_Data.Name)] then
        error("API.CreateQuest: A quest named " ..tostring(_Data.Name).. " already exists!");
        return;
    end
    return BundleQuestGeneration.Global:QuestCreateNewQuest(_Data);
end
AddQuest = API.CreateQuest;

---
-- Erzeugt eine Nachricht im Questfenster.
--
-- Der Quest wird immer nach Ablauf der Wartezeit nach
-- Abschluss des Ancestor Quest gestartet bzw. unmittelbar, wenn es keinen
-- Ancestor Quest gibt. Das Callback ist eine Funktion, die zur Anzeigezeit
-- des Quests ausgeführt wird.
--
-- Alle Paramater sind optional und können von rechts nach links weggelassen
-- oder mit nil aufgefüllt werden.
--
-- <b>Alias</b>: QuestMessage
--
-- @param[type=string]   _Text        Anzeigetext der Nachricht
-- @param[type=number]   _Sender      Sender der Nachricht
-- @param[type=number]   _Receiver    Receiver der Nachricht
-- @param[type=number]   _AncestorWt  Wartezeit
-- @param[type=function] _Callback    Callback
-- @param[type=string]   _Ancestor    Vorgänger-Quest
-- @return[type=string] QuestName
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateQuestMessage("Das ist ein Text", 4, 1);
--
function API.CreateQuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor)
    if GUI then
        return;
    end
    if tonumber(_Sender) == nil or _Sender < 1 or _Sender > 8 then
        error("API.GetResourceOfProduct: _Sender is wrong!");
        return;
    end
    if tonumber(_Receiver) == nil or _Receiver < 1 or _Receiver > 8 then
        error("API.GetResourceOfProduct: _Receiver is wrong!");
        return;
    end
    return BundleQuestGeneration.Global:QuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor);
end
QuestMessage = API.CreateQuestMessage;

---
-- Erzeugt aus einer Table mit Daten eine Reihe von Nachrichten, die nach
-- einander angezeigt werden.
--
-- Dabei sind die eingestellten Wartezeiten in Echtzeit gemessen. Somit ist es
-- egal, wie hoch die Spielgeschwindigkeit ist. Die Dialoge warten alle
-- automatisch 12 Sekunden, wenn nichts anderes eingestellt wird.
--
-- Ein Dialog kann als Nachfolge auf einen Quest oder einen anderen Dialog
-- erzeugt werden, indem Ancestor gleich dem Questnamen gesetzt wird. Die
-- Wartezeit ist automatisch 0 Sekunden. Will man eine andere Wartezeit,
-- so muss Delay gesetzt werden.
--
-- Diese Funktion ist geeignet um längere Quest-Dialoge zu konfigurieren!
--
-- <b>Alias</b>: QuestDialog
--
-- Einzelne Parameter pro Eintrag:
-- <ul>
-- <li>Anzeigetext der Nachricht</li>
-- <li>PlayerID des Sender der Nachricht</li>
-- <li>PlayerID des Empfängers der Nachricht</li>
-- <li>Wartezeit zur vorangegangenen Nachricht</li>
-- <li>Action-Funktion der Nachricht</li>
-- </ul>
--
-- @param[type=table] _Messages Liste der anzuzeigenden Nachrichten
-- @return[type=string] Name des letzten Quest
-- @return[type=table] Namensliste der Quests
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateQuestDialog{
--     Name = "DialogName",
--     Ancestor = "SomeQuestName",
--     Delay = 12,
--
--     {"Hallo, wie geht es dir?", 4, 1, 8},
--     {"Mir geht es gut, wie immer!", 1, 1, 8, SomeCallbackFunction},
--     {"Das ist doch schön.", 4, 1, 8},
-- };
--
function API.CreateQuestDialog(_Messages)
    if GUI then
        return;
    end

    table.insert(_Messages, {"KEY(NO_MESSAGE)", 1, 1});

    local QuestName;
    local GeneratedQuests = {};
    for i= 1, #_Messages, 1 do
        _Messages[i][4] = _Messages[i][4] or 12;
        if i > 1 then
            _Messages[i][6] = _Messages[i][6] or QuestName;
        else
            _Messages[i][6] = _Messages[i][6] or _Messages.Ancestor;
            _Messages[i][4] = _Messages.Delay or 0;
        end
        if i == #_Messages and #_Messages[i-1] then
            _Messages[i][7] = _Messages.Name;
            _Messages[i][4] = _Messages[i-1][4];
        end
        QuestName = BundleQuestGeneration.Global:QuestMessage(unpack(_Messages[i]));
        table.insert(GeneratedQuests, QuestName);
    end

    -- Benannte Dialoge für spätere Zugriffe speichern.
    if _Messages.Name then
        QSB.GeneratedQuestDialogs[_Messages.Name] = GeneratedQuests;
    end
    return GeneratedQuests[#GeneratedQuests], GeneratedQuests;
end
QuestDialog = API.CreateQuestDialog;

---
-- Unterbricht einen laufenden oder noch nicht gestarteten Quest-Dialog.
--
-- Die Funktion kann entweder anhand eines Dialognamen den Dialog zurücksetzen
-- oder direkt die Table der erzeugten Quests annehmen.
--
-- <b>Alias</b>: QuestDialogInterrupt
--
-- @param[type=string] _Dialog Dialog der abgebrochen wird
-- @within Anwenderfunktionen
--
function API.InterruptQuestDialog(_Dialog)
    if GUI then
        return;
    end

    local QuestDialog = _Dialog;
    if type(QuestDialog) == "string" then
        QuestDialog = QSB.GeneratedQuestDialogs[QuestDialog];
    end
    if QuestDialog == nil then
        error("API.InterruptQuestDialog: Dialog is invalid!");
        return;
    end
    for i= 1, #QuestDialog-1, 1 do
        API.StopQuest(QuestDialog[i], true);
    end
    API.WinQuest(QuestDialog[#QuestDialog], true);
end
QuestDialogInterrupt = API.InterruptQuestDialog;

---
-- Setzt einen Quest-Dialog zurück sodass er erneut gestartet werden kann.
--
-- Die Funktion kann entweder anhand eines Dialognamen den Dialog zurücksetzen
-- oder direkt die Table der erzeugten Quests annehmen.
--
-- <b>Alias</b>: QuestDialogRestart
--
-- @param[type=string] _Dialog Dialog der neu gestartet wird
-- @within Anwenderfunktionen
--
function API.RestartQuestDialog(_Dialog)
    if GUI then
        return;
    end

    local QuestDialog = _Dialog;
    if type(QuestDialog) == "string" then
        QuestDialog = QSB.GeneratedQuestDialogs[QuestDialog];
    end
    if QuestDialog == nil then
        error("API.ResetQuestDialog: Dialog is invalid!");
        return;
    end
    for i= 1, #QuestDialog, 1 do
        Quests[GetQuestID(QuestDialog[i])].Triggers[1][2][1].WaitTimeTimer = nil;
        API.RestartQuest(QuestDialog[i], true);
    end

    local CurrentQuest = Quests[GetQuestID(QuestDialog[1])];
    CurrentQuest:Trigger();
end
QuestDialogRestart = API.RestartQuestDialog;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleQuestGeneration = {
    Global = {
        Data = {
            QuestMessageID = 0,
        }
    },
};

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:Install()
    Quest_Loop = self.QuestLoop;
end

---
-- Erzeugt eine Nachricht im Questfenster.
--
-- Der erzeugte Quest wird immer fehlschlagen. Der angezeigte Test ist die
-- Failure Message. Der Quest wird immer nach Ablauf der Wartezeit nach
-- Abschluss des Ancestor Quest gestartet bzw. unmittelbar, wenn es keinen
-- Ancestor Quest gibt. Das Callback ist eine Funktion, die zur Anzeigezeit
-- des Quests ausgeführt wird.
--
-- Alle Paramater sind optional und können von rechts nach links weggelassen
-- oder mit nil aufgefüllt werden.
--
-- @param[type=string]   _Text        Anzeigetext der Nachricht
-- @param[type=number]   _Sender      Sender der Nachricht
-- @param[type=number]   _Receiver    Receiver der Nachricht
-- @param[type=number]   _AncestorWt  Wartezeit
-- @param[type=function] _Callback    Callback
-- @param[type=string]   _Ancestor    Vorgänger-Quest
-- @param[type=string]   _QuestName   Questname überschreiben
-- @return[type=string] QuestName
--
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:QuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor, _QuestName)
    self.Data.QuestMessageID = self.Data.QuestMessageID +1;

    -- Lokalisierung
    if _Text then
        _Text = API.ConvertPlaceholders(API.Localize(_Text));
    end

    -- Quest erzeugen
    local _, CreatedQuest = QuestTemplate:New(
        (_QuestName ~= nil and _QuestName) or "QSB_QuestMessage_" ..self.Data.QuestMessageID,
        (_Sender or 1),
        (_Receiver or 1),
        { {Objective.Dummy} },
        { self:GetRealTimeWaitInlineTrigger(_Ancestor, _AncestorWt) },
        0, nil, nil, _Callback, nil, false, (_Text ~= nil), nil, nil, _Text, nil
    );
    return CreatedQuest.Identifier;
end

---
-- Erzeugt einen Quest.
--
-- @param[type=table] _Data Daten des Quest.
-- @return[type=string] Name des erzeugten Quests
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:QuestCreateNewQuest(_Data)
    if not _Data.Name then
        QSB.AutomaticQuestNameCounter = (QSB.AutomaticQuestNameCounter or 0) +1;
        _Data.Name = string.format("AutoNamed_Quest_%d", QSB.AutomaticQuestNameCounter);
    end
    if not Core:CheckQuestName(_Data.Name) then
        error("Quest '"..tostring(_Data.Name).."': invalid questname! Contains forbidden characters!");
        return;
    end

    -- Questdaten erzeugen
    local QuestData = {
        _Data.Name,
        (_Data.Sender ~= nil and _Data.Sender) or 1,
        (_Data.Receiver ~= nil and _Data.Receiver) or 1,
        {},
        {},
        (_Data.Time ~= nil and _Data.Time) or 0,
        {},
        {},
        _Data.Callback,
        _Data.Loop,
        _Data.Visible == true or _Data.Suggestion ~= nil,
        _Data.EndMessage == true or (_Data.Failure ~= nil or _Data.Success ~= nil),
        API.ConvertPlaceholders((type(_Data.Description) == "table" and API.Localize(_Data.Description)) or _Data.Description),
        API.ConvertPlaceholders((type(_Data.Suggestion) == "table" and API.Localize(_Data.Suggestion)) or _Data.Suggestion),
        API.ConvertPlaceholders((type(_Data.Success) == "table" and API.Localize(_Data.Success)) or _Data.Success),
        API.ConvertPlaceholders((type(_Data.Failure) == "table" and API.Localize(_Data.Failure)) or _Data.Failure)
    };

    -- Daten validieren
    if not self:QuestValidateQuestData(QuestData) then
        error("BundleQuestGeneration: Failed to vaidate quest data. Table has been copied to log.");
        API.DumpTable(QuestData, "Quest");
        return;
    end

    -- Behaviour
    for k,v in pairs(_Data) do
        if tonumber(k) ~= nil then
            if type(v) == "table" then
                if v.GetGoalTable then
                    table.insert(QuestData[4], v:GetGoalTable());

                    local Idx = #QuestData[4];
                    QuestData[4][Idx].Context            = v;
                    QuestData[4][Idx].FuncOverrideIcon   = QuestData[4][Idx].Context.GetIcon;
                    QuestData[4][Idx].FuncOverrideMsgKey = QuestData[4][Idx].Context.GetMsgKey;
                elseif v.GetReprisalTable then
                    table.insert(QuestData[8], v:GetReprisalTable());
                elseif v.GetRewardTable then
                    table.insert(QuestData[7], v:GetRewardTable());
                else
                    table.insert(QuestData[5], v:GetTriggerTable());
                end
            end
        end
    end

    -- Default Goal
    if #QuestData[4] == 0 then
        table.insert(QuestData[4], {Objective.Dummy});
    end
    -- Default Trigger
    if #QuestData[5] == 0 then
        table.insert(QuestData[5], {Triggers.Time, 0 });
    end
    -- Genug Platz Behavior
    if QuestData[11] then
        table.insert(QuestData[5], self:GetFreeSpaceInlineTrigger());
    end

    -- Quest erzeugen
    local QuestID, Quest = QuestTemplate:New(unpack(QuestData, 1, 16));
    Quest.MsgTableOverride = _Data.MSGKeyOverwrite;
    Quest.IconOverride = _Data.IconOverwrite;
    Quest.SkipFunction = _Data.Skip;
    Quest.QuestNotes = true;
    Quest.Arguments = (_Data.Arguments ~= nil and API.InstanceTable(_Data.Arguments)) or {};
    return _Data.Name, Quests[0];
end

---
-- Validiert die Felder eines Quests.
--
-- @param[type=table] _Data Daten des Quest.
-- @return[type=boolean] Quest OK
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:QuestValidateQuestData(_Data)
    return (
        (type(_Data[1]) == "string" and self:QuestValidateQuestName(_Data[1]) and Quests[GetQuestID(_Data[1])] == nil) and
        (type(_Data[2]) == "number" and _Data[2] >= 1 and _Data[2] <= 8) and
        (type(_Data[3]) == "number" and _Data[3] >= 1 and _Data[3] <= 8) and
        (type(_Data[6]) == "number" and _Data[6] >= 0) and
        ((_Data[9] ~= nil and type(_Data[9]) == "function") or (_Data[9] == nil)) and
        ((_Data[10] ~= nil and type(_Data[10]) == "function") or (_Data[10] == nil)) and
        (type(_Data[11]) == "boolean") and
        (type(_Data[12]) == "boolean") and
        ((_Data[13] ~= nil and type(_Data[13]) == "string") or (_Data[13] == nil)) and
        ((_Data[14] ~= nil and type(_Data[14]) == "string") or (_Data[14] == nil)) and
        ((_Data[15] ~= nil and type(_Data[15]) == "string") or (_Data[15] == nil)) and
        ((_Data[16] ~= nil and type(_Data[16]) == "string") or (_Data[16] == nil))
    );
end

---
-- Validiert den Namen eines Quests.
--
-- @param[type=string] _Name Name des Quest.
-- @return[type=boolean] Name OK
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:QuestValidateQuestName(_Name)
    return string.find(_Name, "^[A-Za-z0-9_ @ÄÖÜäöüß]+$") ~= nil;
end

---
-- Erzeugt einen Inline-Behavior welches In Echtzeit auf das Ende eines
-- Quests wartet.
--
-- @param[type=string] _Ancestor   Name des Vorgängers
-- @param[type=number] _AncestorWt Wartezeit in realen Sekunden
-- @return[type=table] Trigger Behavior
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:GetRealTimeWaitInlineTrigger(_Ancestor, _AncestorWt)
    return {
        Triggers.Custom2, {
            {QuestName = _Ancestor, WaitTime = _AncestorWt or 1,},
            function(_Data, _Quest)
                if not _Data.QuestName then
                    return true;
                end
                local QuestID = GetQuestID(_Data.QuestName);
                if (Quests[QuestID] and Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then
                    _Data.WaitTimeTimer = _Data.WaitTimeTimer or API.RealTimeGetSecondsPassedSinceGameStart();
                    if API.RealTimeGetSecondsPassedSinceGameStart() >= _Data.WaitTimeTimer + _Data.WaitTime then
                        return true;
                    end
                end
                return false;
            end
        }
    };
end

---
-- Erzeugt einen Inline-Behavior welches den Quest solange warten lässt, bis
-- wieder weniger als 6 sichtbare Quests aktiv sind.
--
-- @return[type=table] Trigger Behavior
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:GetFreeSpaceInlineTrigger()
    return {
        Triggers.Custom2, {
            {},
            function(_Data, _Quest)
                local VisbleQuests = 0;
                if Quests[0] > 0 then
                    for i= 1, Quests[0], 1 do
                        if Quests[i].State == QuestState.Active and Quests[i].Visible == true then
                            VisbleQuests = VisbleQuests +1;
                        end
                    end
                end
                return VisbleQuests < 6;
            end
        }
    };
end

-- -------------------------------------------------------------------------- --

---
-- Neue Implementierung des Quest Loop um Statuscallbacks auszulösen.
--
-- @param[type=table] _arguments Argumente
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global.QuestLoop(_arguments)
    local self = JobQueue_GetParameter(_arguments);
    if self.LoopCallback ~= nil then
        self:LoopCallback();
    end
    if self.State == QuestState.NotTriggered then
        local triggered = true;
        for i = 1, self.Triggers[0] do
            -- Write Trigger to Log
            local Text = BundleQuestGeneration.Global:SerializeBehavior(self.Triggers[i], Triggers.Custom2, 4);
            if Text then
                Core:LogToFile("Quest '" ..self.Identifier.. "' " ..Text, LEVEL_DEBUG);
            end
            -- Check Trigger
            triggered = triggered and self:IsTriggerActive(self.Triggers[i]);
        end
        if triggered then
            self:SetMsgKeyOverride();
            self:SetIconOverride();
            self:Trigger();
        end
    elseif self.State == QuestState.Active then
        local allTrue = true;
        local anyFalse = false;
        for i = 1, self.Objectives[0] do
            -- Write Trigger to Log
            local Text = BundleQuestGeneration.Global:SerializeBehavior(self.Objectives[i], Objective.Custom2, 1);
            if Text then
                Core:LogToFile("Quest '" ..self.Identifier.. "' " ..Text, LEVEL_DEBUG);
            end
            -- Check Goal
            local completed = self:IsObjectiveCompleted(self.Objectives[i]);
            
            if self.Objectives[i].Type == Objective.Deliver and completed == nil then
                if self.Objectives[i].Data[4] == nil then
                    self.Objectives[i].Data[4] = 0;
                end
                if self.Objectives[i].Data[3] ~= nil then
                    self.Objectives[i].Data[4] = self.Objectives[i].Data[4] + 1;
                end
                
                local st = self.StartTime;
                local sd = self.Duration;
                local dt = self.Objectives[i].Data[4];
                local sum = self.StartTime + self.Duration - self.Objectives[i].Data[4];
                if self.Duration > 0 and self.StartTime + self.Duration + self.Objectives[i].Data[4] < Logic.GetTime() then
                    completed = false;
                end
            else
                if self.Duration > 0 and self.StartTime + self.Duration < Logic.GetTime() then
                    if completed == nil and
                        (self.Objectives[i].Type == Objective.Protect or self.Objectives[i].Type == Objective.Dummy or self.Objectives[i].Type == Objective.NoChange) then
                        completed = true;
                    elseif completed == nil or self.Objectives[i].Type == Objective.DummyFail then
                        completed = false;
                   end
                end
            end
            allTrue = (completed == true) and allTrue;
            anyFalse = completed == false or anyFalse;
        end
        if allTrue then
            self:Success();
        elseif anyFalse then
            self:Fail();
        end
    else
        if self.IsEventQuest == true then
            Logic.ExecuteInLuaLocalState("StopEventMusic(nil, "..self.ReceivingPlayer..")");
        end
        if self.Result == QuestResult.Success then
            for i = 1, self.Rewards[0] do
                -- Write Trigger to Log
                local Text = BundleQuestGeneration.Global:SerializeBehavior(self.Rewards[i], Reward.Custom, 3);
                if Text then
                    Core:LogToFile("Quest '" ..self.Identifier.. "' " ..Text, LEVEL_DEBUG);
                end
                -- Add Reward
                self:AddReward(self.Rewards[i]);
            end
        elseif self.Result == QuestResult.Failure then
            for i = 1, self.Reprisals[0] do
                -- Write Trigger to Log
                local Text = BundleQuestGeneration.Global:SerializeBehavior(self.Reprisals[i], Reprisal.Custom, 3);
                if Text then
                    Core:LogToFile("Quest '" ..self.Identifier.. "' " ..Text, LEVEL_DEBUG);
                end
                -- Add Reward
                self:AddReprisal(self.Reprisals[i]);
            end
        end
        if self.EndCallback ~= nil then
            self:EndCallback();
        end
        return true;
    end
end

---
-- Serialisiert das übergebene Behavior, damit es geloggt werden kann.
--
-- @param[type=table] _Data        Behavior Data
-- @param[type=number] _CustomType Typ der Custom Daten
-- @param[type=number] _Typ        Behavior Typ
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:SerializeBehavior(_Data, _CustomType, _Typ)
    local BehaviorType = "Objective";
    local BehaTable = Objective;
    if _Typ == 2 then
        BehaviorType = "Reprisal";
        BehaTable = Reprisal;
    elseif _Typ == 3 then
        BehaviorType = "Reward";
        BehaTable = Reward;
    elseif _Typ == 4 then
        BehaviorType = "Trigger";
        BehaTable = Triggers;
    end

    local Info = "Running {";
    local Beha = GetNameOfKeyInTable(BehaTable, _Data.Type);

    if _Data.Type == _CustomType then
        local FunctionName = _Data.Data[1].FuncName;
        Info = Info.. BehaviorType.. "." ..Beha.. "";
        if FunctionName == nil then
            return;
        else
            Info = Info.. ", " ..tostring(FunctionName);
        end
        if _Data.Data and _Data.Data[1].i47ya_6aghw_frxil and #_Data.Data[1].i47ya_6aghw_frxil > 0 then
            for j= 1, #_Data.Data[1].i47ya_6aghw_frxil, 1 do
                Info = Info.. ", (" ..type(_Data.Data[1].i47ya_6aghw_frxil[j]).. ") " ..tostring(_Data.Data[1].i47ya_6aghw_frxil[j]);
            end
        end
    else
        Info = Info.. BehaviorType.. "." ..Beha.. "";
        if _Data.Data then
            if type(_Data.Data) == "table" then
                for j= 1, #_Data.Data do
                    Info = Info.. ", (" ..type(_Data.Data[j]).. ") " ..tostring(_Data.Data[j]);
                end
            else
                Info = Info.. ", (" ..type(_Data.Data).. ") " ..tostring(_Data.Data);
            end
        end
    end
    Info = Info.. "}";
    return Info;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleQuestGeneration");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleBuildingButtons                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle erweitert das Gebäudemenü für verschiedene Gebäude um weitere
-- Funktionen. Es ist bspw. möglich ungenutzte Schalter frei zu programmieren.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleBuildingButtons = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert oder deaktiviert die Single Stop Buttons. Single Stop ermöglicht
-- das Anhalten eines einzelnen Betriebes, anstelle des Anhaltens aller
-- Betriebe des gleichen Typs.
--
-- Im Gegensatz zur Viehzucht und zum Rückbau, welche feste eigeständige
-- Buttons sind, handelt es sich hierbei um einen Custom Button. Single
-- Stop belegt Index 1.
--
-- @param[type=boolean] _Flag Single Stop nutzen
-- @within Anwenderfunktionen
-- @see API.AddCustomBuildingButton
--
function API.UseSingleStop(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.UseSingleStop(" ..tostring(_Flag).. ")");
        return;
    end

    if _Flag then
        BundleBuildingButtons.Local:AddOptionalButton(
            2,
            BundleBuildingButtons.Local.ButtonDefaultSingleStop_Action,
            BundleBuildingButtons.Local.ButtonDefaultSingleStop_Tooltip,
            BundleBuildingButtons.Local.ButtonDefaultSingleStop_Update
        );
    else
        BundleBuildingButtons.Local:DeleteOptionalButton(2);
    end
end

---
-- Aktiviere oder deaktiviere Rückbau bei Stadt- und Rohstoffgebäuden. Die
-- Rückbaufunktion erlaubt es dem Spieler bei Stadt- und Rohstoffgebäude
-- der Stufe 2 und 3 jeweils eine Stufe zu zerstören. Der überflüssige
-- Arbeiter wird entlassen.
--
-- @param[type=boolean] _Flag Downgrade nutzen
-- @within Anwenderfunktionen
--
function API.UseDowngrade(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.UseDowngrade(" ..tostring(_Flag == true).. ")");
        return;
    end
    BundleBuildingButtons.Local.Data.Downgrade = _Flag == true;
end

---
-- Fügt einen optionalen Gebäudeschalter hinzu. Der Index bestimmt, welcher
-- der beiden möglichen Buttons verwendet wird.
--
-- Mit dieser Funktion können zwei ungenutzte Buttons im Gebäudemenu mit einer
-- Funktionalität versehen werden. Es obliegt dem Mapper für welche Gebäude
-- der Button angezeigt wird und welche Funktion er hat. Es ist nicht möglich
-- Kosten im Tooltip anzuzeigen.
--
-- Jeder Button kann immer nur mit einer Aktion versehen werden. Soll die
-- Aktion für verschiedene Gebäudetypen unterschiedlich sein, muss in der
-- Aktion eine Fallunterscheidung durchgeführt werden.
--
-- Ein optionaler Button benötigt immer drei Funktionen:
-- <ul>
-- <li>Action: Steuert, was der Button tut.</li>
-- <li>Tooltip: Steuert, welcher Beschreibungstext angezeigt wird.</li>
-- <li>Update: Steuert, wann und wie der Button angezeigt wird.</li>
-- </ul>
-- Alle drei Funktionen erhalten die ID des Buttons und die ID des Gebäudes,
-- das gerade selektiert ist.
--
-- <p><b>Alias:</b> AddBuildingButton</p>
--
-- @param[type=number]   _Index Index des Buttons
-- @param[type=function] _Action Aktion des Buttons
-- @param[type=function] _Tooltip Tooltip Control
-- @param[type=function] _Update Button Update
-- @within Anwenderfunktionen
--
-- @usage
-- -- Aktion
-- function ExampleButtonAction(_WidgetID, _BuildingID)
--     GUI.AddNote("Hier passiert etwas!");
-- end
-- -- Tooltip
-- function ExampleButtonTooltip(_WidgetID, _BuildingID)
--     UserSetTextNormal("Beschreibung", "Das ist die Beschreibung!");
-- end
-- -- Update
-- function ExampleButtonUpdate(_WidgetID, _BuildingID)
--     SetIcon(_WidgetID, {1, 1});
-- end
--
-- -- Beispiel für einen einfachen Button, der immer angezeigt wird, das Bild
-- -- eines Apfels trägt und eine Nachricht anzeigt.
-- API.AddCustomBuildingButton(1, ExampleButtonAction, ExampleButtonTooltip, ExampleButtonUpdate);
--
function API.AddCustomBuildingButton(_Index, _Action, _Tooltip, _Update)
    if not GUI then
        return;
    end
    if (type(_Index) ~= "number" or (_Index < 1 or _Index > 2)) then
        error("API.AddCustomBuildingButton: Index must be 1 or 2!");
        return;
    end
    if (type(_Action) ~= "function" or type(_Tooltip) ~= "function" or type(_Update) ~= "function") then
        error("API.AddCustomBuildingButton: Action, tooltip and update must be functions!");
        return;
    end
    return BundleBuildingButtons.Local:AddOptionalButton(
        _Index, _Action, _Tooltip, _Update
    );
end
AddBuildingButton = API.AddCustomBuildingButton;

---
-- Entfernt den optionalen Gebäudeschalter mit dem angegebenen Index.
--
-- <p><b>Alias:</b> DeleteBuildingButton</p>
--
-- @param[type=number] _Index Index des Buttons
-- @within Anwenderfunktionen
--
-- @usage
-- -- Entfernt die Konfiguration für Button 1
-- API.RemoveCustomBuildingButton(1);
--
function API.RemoveCustomBuildingButton(_Index)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.RemoveCustomBuildingButton("..tostring(_Index)..")");
        return;
    end
    if (type(_Index) ~= "number" or (_Index < 1 or _Index > 2)) then
        error("API.RemoveCustomBuildingButton: Index must be 1 or 2!");
        return;
    end
    return BundleBuildingButtons.Local:DeleteOptionalButton(_Index);
end
DeleteBuildingButton = API.RemoveCustomBuildingButton;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleBuildingButtons = {
    Local = {
        Data = {
            OptionalButton1 = {
                UseButton = false,
            },
            OptionalButton2 = {
                UseButton = false,
            },

            StoppedBuildings = {},
            Downgrade = true,
        },

        Description = {
            Downgrade = {
                Title = {
                    de = "Rückbau",
                    en = "Downgrade",
                },
                Text = {
                    de = "- Reißt eine Stufe des Gebäudes ein {cr}- Der überschüssige Arbeiter wird entlassen",
                    en = "- Destroy one level of this building {cr}- The surplus worker will be dismissed",
                },
                Disabled = {
                    de = "Kann nicht zurückgebaut werden!",
                    en = "Can not be downgraded yet!",
                },
            },

            SingleStop = {
                Title = {
                    de = "Arbeit anhalten/aufnehmen",
                    en = "Start/Stop Work",
                },
                Text = {
                    de = "- Startet oder stoppe die Arbeit in diesem Betrieb",
                    en = "- Continue or stop work for this building",
                },
            },
        },
    },
}

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:Install()
    self:OverwriteHouseMenuButtons();
    self:OverwriteToggleTrap();
    self:OverwriteGateOpenClose();
    self:OverwriteAutoToggle();

    Core:AppendFunction("GameCallback_GUI_SelectionChanged", self.OnSelectionChanged);
end

---
-- Das aktuell selektierte Gebäude wird um eine Stufe zurückgebaut.
--
-- Ein Gebäude der Stufe 1 wird zerstört. Aktuell ist dies aber inaktiv.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:DowngradeBuilding()
    Sound.FXPlay2DSound("ui\\menu_click");
    local Selected = GUI.GetSelectedEntity();
    GUI.DeselectEntity(Selected);
    if Logic.GetUpgradeLevel(Selected) > 0 then
        local AmountToHurt = math.ceil(Logic.GetEntityMaxHealth(Selected) / 2);
        if Logic.GetEntityHealth(Selected) >= AmountToHurt then
            GUI.SendScriptCommand([[Logic.HurtEntity(]] ..Selected.. [[, ]] ..AmountToHurt.. [[)]]);
        end
    else
        local AmountToHurt = Logic.GetEntityMaxHealth(Selected);
        GUI.SendScriptCommand([[Logic.HurtEntity(]] ..Selected.. [[, ]] ..AmountToHurt.. [[)]]);
    end
end

---
-- Fügt einen Button dem Hausmenü hinzu. Es können nur 2 Buttons
-- hinzugefügt werden. Buttons brauchen immer eine Action-, eine
-- Tooltip- und eine Update-Funktion.
--
-- @param[type=number]   _idx              Indexposition des Button (1 oder 2)
-- @param[type=function] _actionFunction   Action-Funktion (String in Global)
-- @param[type=function] _tooltipFunction  Tooltip-Funktion (String in Global)
-- @param[type=function] _updateFunction   Update-Funktion (String in Global)
-- @within Internal
-- @local
-- @see API.AddCustomBuildingButton
--
function BundleBuildingButtons.Local:AddOptionalButton(_idx, _actionFunction, _tooltipFunction, _updateFunction)
    assert(_idx == 1 or _idx == 2);
    local wID = {
        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateAutoToggle"),
        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateOpenClose"),
    };
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].WidgetID = wID[_idx];
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UseButton = true;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].ActionFunction = _actionFunction;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].TooltipFunction = _tooltipFunction;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UpdateFunction = _updateFunction;
end

---
-- Entfernt den Zusatz-Button auf dem Index.
--
-- @param[type=number] _idx Indexposition des Button (1 oder 2)
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:DeleteOptionalButton(_idx)
    assert(_idx == 1 or _idx == 2);
    local wID = {
        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateAutoToggle"),
        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateOpenClose"),
    };
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].WidgetID = wID[_idx];
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UseButton = false;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].ActionFunction = nil;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].TooltipFunction = nil;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UpdateFunction = nil;
end

---
-- Überschreibt die GUI-Funktionen des inaktiven Schalters für automatisches
-- Umschalten von Torsperren.
--
-- Diese Funktion implementiert den optionalen Schalter #1.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:OverwriteAutoToggle()
    GUI_BuildingButtons.GateAutoToggleClicked = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if not BundleBuildingButtons.Local.Data.OptionalButton1.ActionFunction then
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton1.ActionFunction(CurrentWidgetID, EntityID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.GateAutoToggleMouseOver = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if not BundleBuildingButtons.Local.Data.OptionalButton1.TooltipFunction then
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton1.TooltipFunction(CurrentWidgetID, EntityID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.GateAutoToggleUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        local Health = Logic.GetEntityHealth(EntityID);

        SetIcon(CurrentWidgetID, {8,16});

        if EntityID == nil
        or Logic.IsBuilding(EntityID) == 0
        or not BundleBuildingButtons.Local.Data.OptionalButton1.UpdateFunction
        or not BundleBuildingButtons.Local.Data.OptionalButton1.UseButton
        or Logic.IsConstructionComplete(EntityID) == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end

        if Logic.BuildingDoWorkersStrike(EntityID) == true
        or Logic.IsBuildingBeingUpgraded(EntityID) == true
        or Logic.IsBuildingBeingKnockedDown(EntityID) == true
        or Logic.IsBurning(EntityID) == true
        or MaxHealth-Health > 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton1.UpdateFunction(CurrentWidgetID, EntityID);
    end
end

---
-- Überschreibt den inaktiven Button zum öffnen/schließen von Toren.
--
-- Diese Funktion implementiert den optionalen Schalter #2.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:OverwriteGateOpenClose()
    GUI_BuildingButtons.GateOpenCloseClicked = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if not BundleBuildingButtons.Local.Data.OptionalButton2.ActionFunction then
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton2.ActionFunction(CurrentWidgetID, EntityID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.GateOpenCloseMouseOver = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if not BundleBuildingButtons.Local.Data.OptionalButton2.TooltipFunction then
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton2.TooltipFunction(CurrentWidgetID, EntityID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.GateOpenCloseUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        local Health = Logic.GetEntityHealth(EntityID);

        SetIcon(CurrentWidgetID, {8,16});

        if EntityID == nil
        or Logic.IsBuilding(EntityID) == 0
        or not BundleBuildingButtons.Local.Data.OptionalButton2.UpdateFunction
        or not BundleBuildingButtons.Local.Data.OptionalButton2.UseButton
        or Logic.IsConstructionComplete(EntityID) == 0
        or Logic.IsBuilding(EntityID) == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end

        if Logic.BuildingDoWorkersStrike(EntityID) == true
        or Logic.IsBuildingBeingUpgraded(EntityID) == true
        or Logic.IsBuildingBeingKnockedDown(EntityID) == true
        or Logic.IsBurning(EntityID) == true
        or MaxHealth-Health > 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton2.UpdateFunction(CurrentWidgetID, EntityID);
    end
end

---
-- Überschreibt den inaktiven Button zum umschalten der Torhausfallen.
--
-- Diese Funktion implementiert den Rückbau.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:OverwriteToggleTrap()
    GUI_BuildingButtons.TrapToggleClicked = function()
        BundleBuildingButtons.Local:DowngradeBuilding();
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.TrapToggleMouseOver = function()
        BundleBuildingButtons.Local:TextNormal(
            API.ConvertPlaceholders(API.Localize(BundleBuildingButtons.Local.Description.Downgrade.Title)),
            API.ConvertPlaceholders(API.Localize(BundleBuildingButtons.Local.Description.Downgrade.Text)),
            API.ConvertPlaceholders(API.Localize(BundleBuildingButtons.Local.Description.Downgrade.Disabled))
        );
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.TrapToggleUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        local eName = Logic.GetEntityName(EntityID);
        local eType = Logic.GetEntityType(EntityID);
        local tID = GetTerritoryUnderEntity(EntityID);
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        local Health = Logic.GetEntityHealth(EntityID);
        local Level = Logic.GetUpgradeLevel(EntityID);

        local x,y = XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/Upgrade");
        SetIcon(CurrentWidgetID, {3,15});
        XGUIEng.SetWidgetLocalPosition(CurrentWidgetID, x+64, y);

        if EntityID == nil or Logic.IsBuilding(EntityID) == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end

        -- Protection - Submodul
        if BundleDestructionControl then
            -- Prüfe auf Namen
            if Inside(eName, BundleDestructionControl.Local.Data.Entities) then
                XGUIEng.ShowWidget(CurrentWidgetID, 0);
                return;
            end

            -- Prüfe auf Typen
            if Inside(eType, BundleDestructionControl.Local.Data.EntityTypes) then
                XGUIEng.ShowWidget(CurrentWidgetID, 0);
                return;
            end

            -- Prüfe auf Territorien
            if Inside(tID, BundleDestructionControl.Local.Data.OnTerritory) then
                XGUIEng.ShowWidget(CurrentWidgetID, 0);
                return;
            end

            -- Prüfe auf Category
            for k,v in pairs(BundleDestructionControl.Local.Data.EntityCategories) do
                if Logic.IsEntityInCategory(EntityID, v) == 1 then
                    XGUIEng.ShowWidget(CurrentWidgetID, 0);
                    return;
                end
            end
        end

        if Logic.IsConstructionComplete(EntityID) == 0
        or (Logic.IsEntityInCategory(EntityID, EntityCategories.OuterRimBuilding) == 0
        and Logic.IsEntityInCategory(EntityID, EntityCategories.CityBuilding) == 0)
        or not BundleBuildingButtons.Local.Data.Downgrade
        or Level == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end
        if Logic.BuildingDoWorkersStrike(EntityID) == true
        or Logic.IsBuildingBeingUpgraded(EntityID) == true
        or Logic.IsBuildingBeingKnockedDown(EntityID) == true
        or Logic.IsBurning(EntityID) == true
        or MaxHealth-Health > 0 then
            XGUIEng.DisableButton(CurrentWidgetID, 1);
        else
            XGUIEng.DisableButton(CurrentWidgetID, 0);
        end
    end
end

---
-- Diese Funktion überschreibt das House Menu, sodass Single stop fehlerfrei
-- funktioniert.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:OverwriteHouseMenuButtons()
    HouseMenuStopProductionClicked_Orig_SingleStop = HouseMenuStopProductionClicked;
    HouseMenuStopProductionClicked = function()
        HouseMenuStopProductionClicked_Orig_SingleStop();
        local WidgetName = HouseMenu.Widget.CurrentBuilding;
        local EntityType = Entities[WidgetName];
        local PlayerID = GUI.GetPlayerID();
        local Buildings = GetPlayerEntities(PlayerID, EntityType);

        for i=1, #Buildings, 1 do
            if BundleBuildingButtons.Local.Data.StoppedBuildings[Buildings[i]] ~= HouseMenu.StopProductionBool then
                BundleBuildingButtons.Local.Data.StoppedBuildings[Buildings[i]] = HouseMenu.StopProductionBool;
                GUI.SetStoppedState(Buildings[i], HouseMenu.StopProductionBool);
            end
        end
    end
end

---
-- Setzt einen für den Tooltip des aktuellen Widget einen neuen Text.
--
-- @param[type=string] _Title        Titel des Tooltip
-- @param[type=string] _Text         Text des Tooltip
-- @param[type=string] _DisabledText (optional) Textzusatz wenn inaktiv
-- @within BundleBuildingButtons
-- @local
--
function BundleBuildingButtons.Local:TextNormal(_Title, _Text, _DisabledText)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);
    local TooltipContainerSizeWidgets = {TooltipBGWidget};
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);

    _DisabledText = _DisabledText or "";
    local disabled = ""
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title);
    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);
end

---
-- Diese Funktion ist die Action von Single Stop.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local.ButtonDefaultSingleStop_Action(WidgetID, EntityID)
    local StoppedState = BundleBuildingButtons.Local.Data.StoppedBuildings[EntityID] == true;
    GUI.SetStoppedState(EntityID, not StoppedState);
    BundleBuildingButtons.Local.Data.StoppedBuildings[EntityID] = not StoppedState;
end

---
-- Diese Funktion steuert den Tooltip von Single Stop.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local.ButtonDefaultSingleStop_Tooltip(WidgetID, EntityID)
    BundleBuildingButtons.Local:TextNormal(
        API.ConvertPlaceholders(API.Localize(BundleBuildingButtons.Local.Description.SingleStop.Title)),
        API.ConvertPlaceholders(API.Localize(BundleBuildingButtons.Local.Description.SingleStop.Text))
    );
end

---
-- Diese Funktion ist der Update Job von Single Stop.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local.ButtonDefaultSingleStop_Update(_WidgetID, _EntityID)
    local IsOuterRimBuilding = Logic.IsEntityInCategory(_EntityID, EntityCategories.OuterRimBuilding) == 1;
    local IsCityBuilding = Logic.IsEntityInCategory(_EntityID, EntityCategories.CityBuilding) == 1;
    if IsOuterRimBuilding == false and IsCityBuilding == false then
        XGUIEng.ShowWidget(_WidgetID, 0);
    end

    if BundleBuildingButtons.Local.Data.StoppedBuildings[_EntityID] == true then
        SetIcon(_WidgetID, {4, 12});
    else
        SetIcon(_WidgetID, {4, 13});
    end
end

---
-- Diese Funktion wird aufgerufen, sobald sich die Selektion ändert.
--
-- Hier werden die ausgeblendeten ungenutzten Gebäudeschalter eingeblendet.
--
-- @param[type=number] _Source Quelle der Änderung
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local.OnSelectionChanged(_Source)
    local eID = GUI.GetSelectedEntity();
    local eType = Logic.GetEntityType(eID);

    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/GateAutoToggle",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/GateOpenClose",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/TrapToggle",1);
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleBuildingButtons");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleCamera                                                 # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Manchmal ist der maximale Zoom nicht genug! Löse Dich von den Fesseln, die
-- Dich einschränken! Dieses Bundle ermöglicht es den tatsächlichen maximalen
-- Zoom zu nutzen.
--
-- Außerdem kannst du die Kamera auf ein bestimmtes Entity zentrieren. Du
-- kannst Rotation und Zoomfaktor bestimmen.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleCamera = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert den Hotkey zum Wechsel zwischen normalen und erweiterten Zoom.
--
-- <p><b>Alias:</b> AllowExtendedZoom</p>
--
-- @param _Flag [boolean] Erweiterter Zoom gestattet
-- @within Anwenderfunktionen
--
function API.AllowExtendedZoom(_Flag)
    if GUI then
        GUI.SendScriptCommand("API.AllowExtendedZoom(".. tostring(_Flag == true) ..")");
        return;
    end
    BundleCamera.Global.Data.ExtendedZoomAllowed = _Flag == true;
    if _Flag == false then
        BundleCamera.Global:DeactivateExtendedZoom();
    end
end
AllowExtendedZoom = API.AllowExtendedZoom;

---
-- Fokusiert die Kamera auf dem Primärritter des Spielers.
--
-- <p><b>Alias:</b> SetCameraToPlayerKnight</p>
--
-- @param[type=number] _Player Partei
-- @param[type=number] _Rotation Kamerawinkel
-- @param[type=number] _ZoomFactor Zoomfaktor
-- @within Anwenderfunktionen
--
function API.FocusCameraOnKnight(_Player, _Rotation, _ZoomFactor)
    API.FocusCameraOnEntity(Logic.GetKnightID(_Player), _Rotation, _ZoomFactor)
end
SetCameraToPlayerKnight = API.FocusCameraOnKnight;

---
-- Fokusiert die Kamera auf dem Entity.
--
-- <p><b>Alias:</b> SetCameraToEntity</p>
--
-- @param _Entity Entity (Skriptname oder ID)
-- @param[type=number] _Rotation Kamerawinkel
-- @param[type=number] _ZoomFactor Zoomfaktor
-- @within Anwenderfunktionen
--
function API.FocusCameraOnEntity(_Entity, _Rotation, _ZoomFactor)
    if not GUI then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        Logic.ExecuteInLuaLocalState("API.FocusCameraOnEntity(" ..Subject.. ", " ..tostring(_Rotation).. ", " ..tostring(_ZoomFactor).. ")");
        return;
    end
    if type(_Rotation) ~= "number" then
        error("API.FocusCameraOnEntity: Rotation is wrong!");
        return;
    end
    if type(_ZoomFactor) ~= "number" then
        error("API.FocusCameraOnEntity: Zoom factor is wrong!");
        return;
    end
    if not IsExisting(_Entity) then
        error("API.FocusCameraOnEntity: Entity " ..tostring(_Entity).." does not exist!");
        return;
    end
    return BundleCamera.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor);
end
SetCameraToEntity = API.FocusCameraOnEntity;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleCamera = {
    Global = {
        Data = {
            ExtendedZoomAllowed = true,
        }
    },
    Local = {
        Data = {}
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleCamera.Global:Install()
    self:InitExtendedZoomHotkeyFunction();
    self:InitExtendedZoomHotkeyDescription();
    API.AddSaveGameAction(BundleCamera.Global.OnSaveGameLoaded);
end

-- -------------------------------------------------------------------------- --

---
-- Schaltet zwischen dem normalen und dem erweiterten Zoom um.
--
-- @within Internal
-- @local
--
function BundleCamera.Global:ToggleExtendedZoom()
    if self.Data.ExtendedZoomAllowed then
        if self.Data.ExtendedZoomActive then
            self:DeactivateExtendedZoom();
        else
            self:ActivateExtendedZoom();
        end
    end
end

---
-- Aktiviert den erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleCamera.Global:ActivateExtendedZoom()
    self.Data.ExtendedZoomActive = true;
    Logic.ExecuteInLuaLocalState("BundleCamera.Local:ActivateExtendedZoom()");
end

---
-- Deaktiviert den erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleCamera.Global:DeactivateExtendedZoom()
    self.Data.ExtendedZoomActive = false;
    Logic.ExecuteInLuaLocalState("BundleCamera.Local:DeactivateExtendedZoom()");
end

---
-- Initialisiert den erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleCamera.Global:InitExtendedZoomHotkeyFunction()
    Logic.ExecuteInLuaLocalState([[
        if not BundleCamera then
            StartSimpleJobEx(function()
                if BundleCamera then
                    BundleCamera.Local:ActivateExtendedZoomHotkey();
                    return true;
                end
            end)
        else
            BundleCamera.Local:ActivateExtendedZoomHotkey();
        end
    ]]);
end

---
-- Initialisiert den erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleCamera.Global:InitExtendedZoomHotkeyDescription()
    Logic.ExecuteInLuaLocalState([[
        if not BundleCamera then
            StartSimpleJobEx(function()
                if BundleCamera then
                    BundleCamera.Local:RegisterExtendedZoomHotkey();
                    return true;
                end
            end)
        else
            BundleCamera.Local:RegisterExtendedZoomHotkey()
        end
    ]]);
end

-- -------------------------------------------------------------------------- --

---
-- Stellt nicht-persistente Änderungen nach dem laden wieder her.
--
-- @within Internal
-- @local
--
function BundleCamera.Global.OnSaveGameLoaded()
    -- Geänderter Zoom --
    if BundleCamera.Global.Data.ExtendedZoomActive then
        BundleCamera.Global:ActivateExtendedZoom();
    end
    BundleCamera.Global:InitExtendedZoomHotkeyFunction();
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleCamera.Local:Install()
end

-- -------------------------------------------------------------------------- --

---
-- Fokusiert die Kamera auf dem Entity.
--
-- @param _Entity Entity (Skriptname oder ID)
-- @param[type=number] _Rotation Kamerawinkel
-- @param[type=number] _ZoomFactor Zoomfaktor
-- @within Internal
-- @local
--
function BundleCamera.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor)
    local pos = GetPosition(_Entity);
    local rotation = (_Rotation or -45);
    local zoomFactor = (_ZoomFactor or 0.5);
    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);
    Camera.RTS_SetRotationAngle(rotation);
    Camera.RTS_SetZoomFactor(zoomFactor);
end

-- -------------------------------------------------------------------------- --

---
-- Schreibt den Hotkey für den erweiterten Zoom in das Hotkey-Register.
--
-- @within Internal
-- @local
--
function BundleCamera.Local:RegisterExtendedZoomHotkey()
    API.AddHotKey(
        {de = "Strg + Umschalt + K",
         en = "Ctrl + Shift + K"},
        {de = "Alternativen Zoom ein/aus",
         en = "Alternative zoom on/off"}
    )
end

---
-- Aktiviert den Hotkey zum Wechsel zwischen normalen und erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleCamera.Local:ActivateExtendedZoomHotkey()
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.K,
        "BundleCamera.Local:ToggleExtendedZoom()",
        2,
        false
    );
end

---
-- Wechselt zwischen erweitertem und normalen Zoom.
--
-- @within Internal
-- @local
--
function BundleCamera.Local:ToggleExtendedZoom()
    GUI.SendScriptCommand("BundleCamera.Global:ToggleExtendedZoom()");
end

---
-- Erweitert die Zoomrestriktion auf das Maximum.
--
-- @within Internal
-- @local
--
function BundleCamera.Local:ActivateExtendedZoom()
    self.Data.ExtendedZoomActive = true;
    Camera.RTS_SetZoomFactorMax(0.8701);
    Camera.RTS_SetZoomFactor(0.8700);
    Camera.RTS_SetZoomFactorMin(0.0999);
end

---
-- Stellt die normale Zoomrestriktion wieder her.
--
-- @within Internal
-- @local
--
function BundleCamera.Local:DeactivateExtendedZoom()
    self.Data.ExtendedZoomActive = false;
    Camera.RTS_SetZoomFactor(0.5000);
    Camera.RTS_SetZoomFactorMax(0.5001);
    Camera.RTS_SetZoomFactorMin(0.0999);
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleCamera");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleCheats                                                 # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle kann die Nutzung der Cheats verboten oder erlaubt werden.
--
-- Es sind nur die normalen Cheats betroffen. Wenn der Debug der QSB aktiv
-- ist, können Cheats nicht deaktiviert werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleCheats = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- <p><b>Alias:</b> KillCheats</p>
--
-- @within Anwenderfunktionen
--
function API.ForbidCheats()
    if GUI then
        GUI.SendScriptCommand("API.ForbidCheats()");
        return;
    end
    return BundleCheats.Global:KillCheats();
end
KillCheats = API.ForbidCheats;

---
-- Aktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- <p><b>Alias:</b> RessurectCheats</p>
--
-- @within Anwenderfunktionen
--
function API.AllowCheats()
    if GUI then
        GUI.SendScriptCommand("API.AllowCheats()");
        return;
    end
    return BundleCheats.Global:RessurectCheats();
end
RessurectCheats = API.AllowCheats;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleCheats = {
    Global = {
        Data = {}
    },
    Local = {
        Data = {}
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleCheats.Global:Install()
    API.AddSaveGameAction(BundleCheats.Global.OnSaveGameLoaded);
end

-- -------------------------------------------------------------------------- --

---
-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- @within Internal
-- @local
--
function BundleCheats.Global:KillCheats()
    self.Data.CheatsForbidden = true;
    Logic.ExecuteInLuaLocalState("BundleCheats.Local:KillCheats()");
end

---
-- Aktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- @within Internal
-- @local
--
function BundleCheats.Global:RessurectCheats()
    self.Data.CheatsForbidden = false;
    Logic.ExecuteInLuaLocalState("BundleCheats.Local:RessurectCheats()");
end

-- -------------------------------------------------------------------------- --

---
-- Stellt nicht-persistente Änderungen nach dem laden wieder her.
--
-- @within Internal
-- @local
--
function BundleCheats.Global.OnSaveGameLoaded()
    -- Cheats sperren --
    if BundleCheats.Global.Data.CheatsForbidden == true then
        BundleCheats.Global:KillCheats();
    end
end

-- -------------------------------------------------------------------------- --

---
-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- @within Internal
-- @local
--
function BundleCheats.Local:KillCheats()
    info("BundleCheats: Cheats deactivated");
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.Divide,
        "KeyBindings_EnableDebugMode(0)",
        2,
        false
    );
end

---
-- Aktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- @within Internal
-- @local
--
function BundleCheats.Local:RessurectCheats()
    info("BundleCheats: Cheats activated");
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.Divide,
        "KeyBindings_EnableDebugMode(2)",
        2,
        false
    );
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleCheats");

-- -------------------------------------------------------------------------- --

-- ########################################################################## --

-- #  Symfonia BundleConstructionControl                                    # --

-- ########################################################################## --

-- -------------------------------------------------------------------------- --



---

-- Mit diesem Bundle kann der Bau von Gebäudetypen oder Gebäudekategorien

-- unterbunden werden. Verbote können für bestimmte Bereiche (kreisförmige

-- Gebiete um ein Zentrum) oder ganze Territorien vereinbart werden.

--

-- @within Modulbeschreibung

-- @set sort=true

--

BundleConstructionControl = {};



API = API or {};

QSB = QSB or {};



-- -------------------------------------------------------------------------- --

-- User-Space                                                                 --

-- -------------------------------------------------------------------------- --



---

-- Untersagt den Bau des Typs im Territorium.

--

-- @param[type=number] _type      Entitytyp

-- @param[type=number] _territory Territorium

-- @within Anwenderfunktionen

--

-- @usage API.BanTypeAtTerritory(Entities.B_Bakery, 1);

--

function API.BanTypeAtTerritory(_type, _territory)

    if GUI then

        return;

    end

    local Territories = {Logic.GetTerritories()};

    if type(_territory) == "string" then

        _territory = GetTerritoryIDByName(_territory);

    end

    if _territory == 0 or #Territories-1 < _territory then

        error("API.BanTypeAtTerritory: Territory does not exist!");

        return;

    end

    if GetNameOfKeyInTable(Entities, _type) == nil then

        error("API.BanTypeAtTerritory: Entity type is invalid!");

        return;

    end



    BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] = BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] or {};

    if not Inside(_territory, BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type]) then

        info("API.BanTypeAtTerritory: Banning type " ..Logic.GetEntityTypeName(_type).. " from territory " ..tostring(_territory)..".");

        table.insert(BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], _territory);

    end

end



---

-- Untersagt den Bau der Kategorie im Territorium.

--

-- @param[type=number] _eCat      Entitykategorie

-- @param[type=number] _territory Territorium

-- @within Anwenderfunktionen

--

-- @usage API.BanCategoryAtTerritory(EntityCategories.AttackableBuilding, 2);

--

function API.BanCategoryAtTerritory(_eCat, _territory)

    if GUI then

        return;

    end

    local Territories = {Logic.GetTerritories()};

    if type(_territory) == "string" then

        _territory = GetTerritoryIDByName(_territory);

    end

    if _territory == 0 or #Territories-1 < _territory then

        error("API.BanCategoryAtTerritory: Territory does not exist!");

        return;

    end

    if GetNameOfKeyInTable(EntityCategories, _eCat) == nil then

        error("API.BanCategoryAtTerritory: Entity category is invalid!");

        return;

    end



    BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] = BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] or {};

    if not Inside(_territory, BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat]) then

        info("API.BanTypeAtTerritory: Banning category " ..Logic.GetEntityCategoryName(_eCat).. " from territory " ..tostring(_territory)..".");

        table.insert(BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], _territory);

    end

end



---

-- Untersagt den Bau des Typs im Gebiet.

--

-- @param[type=number] _type   Entitytyp

-- @param[type=string] _center Gebietszentrum

-- @param[type=number] _area   Gebietsgröße

-- @within Anwenderfunktionen

--

-- @usage API.BanTypeInArea(Entities.B_Bakery, "groundZero", 4000);

--

function API.BanTypeInArea(_type, _center, _area)

    if GUI then

        return;

    end

    if type(_center) ~= "string" or not IsExisting(_center) then

        error("API.BanTypeInArea: _center must be the name of an existing entity!");

        return;

    end

    if type(_area) ~= "number" or _area < 1 then

        error("API.BanTypeInArea: _area must be a positive number!");

        return;

    end

    if GetNameOfKeyInTable(Entities, _type) == nil then

        error("API.BanTypeInArea: Entity type is invalid!");

        return;

    end



    BundleConstructionControl.Global.Data.AreaBlockEntities[_center] = BundleConstructionControl.Global.Data.AreaBlockEntities[_center] or {};

    if not Inside(_type, BundleConstructionControl.Global.Data.AreaBlockEntities[_center], true) then

        info("API.BanTypeAtTerritory: Banning type " ..Logic.GetEntityTypeName(_type).. " from area " ..tostring(_center).." (" ..tostring(_area)..").");

        table.insert(BundleConstructionControl.Global.Data.AreaBlockEntities[_center], {_type, math.floor(_area)});

    end

end



---

-- Untersagt den Bau der Kategorie im Gebiet.

--

-- @param[type=number] _eCat   Entitytyp

-- @param[type=string] _center Gebietszentrum

-- @param[type=number] _area   Gebietsgröße

-- @within Anwenderfunktionen

--

-- @usage API.BanTypeInArea(EntityCategories.CityBuilding, "groundZero", 4000);

--

function API.BanCategoryInArea(_eCat, _center, _area)

    if GUI then

        return;

    end

    if type(_center) ~= "string" or not IsExisting(_center) then

        error("API.BanCategoryInArea: _center must be the name of an existing entity!");

        return;

    end

    if type(_area) ~= "number" or _area < 1 then

        error("API.BanCategoryInArea: _area must be a positive number!");

        return;

    end

    if GetNameOfKeyInTable(EntityCategories, _eCat) == nil then

        error("API.BanCategoryInArea: Entity category is invalid!");

        return;

    end



    BundleConstructionControl.Global.Data.AreaBlockCategories[_center] = BundleConstructionControl.Global.Data.AreaBlockCategories[_center] or {};

    if not Inside(_eCat, BundleConstructionControl.Global.Data.AreaBlockCategories[_center], true) then

        info("API.BanTypeAtTerritory: Banning category " ..Logic.GetEntityCategoryName(_eCat).. " from area " ..tostring(_center).." (" ..tostring(_area)..").");

        table.insert(BundleConstructionControl.Global.Data.AreaBlockCategories[_center], {_eCat, _area});

    end

end



---

-- Gibt einen Typ zum Bau im Territorium wieder frei.

--

-- @param[type=number] _type      Entitytyp

-- @param[type=number] _territory Territorium

-- @within Anwenderfunktionen

--

-- @usage API.UnbanTypeAtTerritory(Entities.B_Bakery, 1);

--

function API.UnbanTypeAtTerritory(_type, _territory)

    if GUI then

        return;

    end

    local Territories = {Logic.GetTerritories()};

    if type(_territory) == "string" then

        _territory = GetTerritoryIDByName(_territory);

    end

    if _territory == 0 or #Territories-1 < _territory then

        error("API.UnbanTypeAtTerritory: Territory does not exist!");

        return;

    end

    if GetNameOfKeyInTable(Entities, _type) == nil then

        error("API.UnbanTypeAtTerritory: Entity type is invalid!");

        return;

    end



    if not BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] then

        return;

    end

    for i= #BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], 1, -1 do

        if BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type][i] == _territory then

            info("API.BanTypeAtTerritory: Unbanning type " ..Logic.GetEntityTypeName(_type).. " from territory " ..tostring(_territory)..".");

            table.remove(BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], i);

            break;

        end

    end

end



---

-- Gibt eine Kategorie zum Bau im Territorium wieder frei.

--

-- @param[type=number] _eCat      Entitykategorie

-- @param[type=number] _territory Territorium

-- @within Anwenderfunktionen

--

-- @usage API.UnbanCategoryAtTerritory(EntityCategories.AttackableBuilding, 1);

--

function API.UnbanCategoryAtTerritory(_eCat, _territory)

    if GUI then

        return;

    end

    local Territories = {Logic.GetTerritories()};

    if type(_territory) == "string" then

        _territory = GetTerritoryIDByName(_territory);

    end

    if _territory == 0 or #Territories-1 < _territory then

        error("API.UnbanCategoryAtTerritory: Territory does not exist!");

        return;

    end

    if GetNameOfKeyInTable(EntityCategories, _eCat) == nil then

        error("API.UnbanCategoryAtTerritory: Entity category is invalid!");

        return;

    end



    if not BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] then

        return;

    end

    for i= #BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], 1, -1 do

        if BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat][i] == _territory then

            info("API.BanTypeAtTerritory: Unbanning category " ..Logic.GetEntityCategoryName(_eCat).. " from territory " ..tostring(_territory)..".");

            table.remove(BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], i);

            break;

        end

    end

end



---

-- Gibt einen Typ zum Bau im Gebiet wieder frei.

--

-- @param[type=number] _type   Entitytyp

-- @param[type=string] _center Gebiet

-- @within Anwenderfunktionen

--

-- @usage API.UnbanTypeInArea(Entities.B_Bakery, "groundZero");

--

function API.UnbanTypeInArea(_type, _center)

    if GUI then

        return;

    end

    if type(_center) ~= "string" or not IsExisting(_center) then

        error("API.UnbanTypeInArea: _center must be the name of an existing entity!");

        return;

    end

    if GetNameOfKeyInTable(Entities, _type) == nil then

        error("API.UnbanTypeInArea: Entity type is invalid!");

        return;

    end



    if not BundleConstructionControl.Global.Data.AreaBlockEntities[_center] then

        return;

    end

    for i= #BundleConstructionControl.Global.Data.AreaBlockEntities[_center], 1, -1 do

        if BundleConstructionControl.Global.Data.AreaBlockEntities[_center][i][1] == _type then

            info("API.BanTypeAtTerritory: Unbanning type " ..Logic.GetEntityTypeName(_type).. " in area " ..tostring(_center)..".");

            table.remove(BundleConstructionControl.Global.Data.AreaBlockEntities[_center], i);

            break;

        end

    end

end



---

-- Gibt eine Kategorie zum Bau im Gebiet wieder frei.

--

-- @param[type=number] _eCat   Entitykategorie

-- @param[type=string] _center Gebiet

-- @within Anwenderfunktionen

--

-- @usage API.UnbanCategoryInArea(EntityCategories.CityBuilding, "groundZero");

--

function API.UnbanCategoryInArea(_eCat, _center)

    if GUI then

        return;

    end

    if type(_center) ~= "string" or not IsExisting(_center) then

        error("API.UnbanCategoryInArea: _center must be the name of an existing entity!");

        return;

    end

    if GetNameOfKeyInTable(EntityCategories, _eCat) == nil then

        error("API.UnbanCategoryInArea: Entity category is invalid!");

        return;

    end



    if not BundleConstructionControl.Global.Data.AreaBlockCategories[_center] then

        return;

    end

    for i= #BundleConstructionControl.Global.Data.AreaBlockCategories[_center], 1, -1 do

        if BundleConstructionControl.Global.Data.AreaBlockCategories[_center][i][1] == _eCat then

            info("API.BanTypeAtTerritory: Unbanning category " ..Logic.GetEntityCategoryName(_eCat).. " from territory " ..tostring(_center)..".");

            table.remove(BundleConstructionControl.Global.Data.AreaBlockCategories[_center], i);

            break;

        end

    end

end



-- -------------------------------------------------------------------------- --

-- Application-Space                                                          --

-- -------------------------------------------------------------------------- --



BundleConstructionControl = {

    Global = {

        Data = {

            TerritoryBlockCategories = {},

            TerritoryBlockEntities = {},

            AreaBlockCategories = {},

            AreaBlockEntities = {},

        }

    },

}



-- Global Script ---------------------------------------------------------------



---

-- Initalisiert das Bundle im globalen Skript.

--

-- @within Internal

-- @local

--

function BundleConstructionControl.Global:Install()

    Core:AppendFunction(

        "GameCallback_CanPlayerPlaceBuilding",

        BundleConstructionControl.Global.CanPlayerPlaceBuilding

    );

end



---

-- Verhindert den Bau von Entities in Gebieten und Territorien.

--

-- @param[type=number] _PlayerID Spieler

-- @param[type=number] _Type     Gebäudetyp

-- @param[type=number] _x        X-Position

-- @param[type=number] _y        Y-Position

-- @within Internal

-- @local

--

function BundleConstructionControl.Global.CanPlayerPlaceBuilding(_PlayerID, _Type, _x, _y)

    -- Auf Territorium ---------------------------------------------



    -- Prüfe Kategorien

    for k,v in pairs(BundleConstructionControl.Global.Data.TerritoryBlockCategories) do

        if v then

            for key, val in pairs(v) do

                if val and Logic.GetTerritoryAtPosition(_x, _y) == val then

                    if Logic.IsEntityTypeInCategory(_Type, k) == 1 then

                        return false;

                    end

                end

            end

        end

    end



    -- Prüfe Typen

    for k,v in pairs(BundleConstructionControl.Global.Data.TerritoryBlockEntities) do

        if v then

            for key,val in pairs(v) do

                if val and Logic.GetTerritoryAtPosition(_x, _y) == val then

                    if _Type == k then

                        return false;

                    end

                end

            end

        end

    end



    -- In einem Gebiet ---------------------------------------------



    -- Prüfe Kategorien

    for k, v in pairs(BundleConstructionControl.Global.Data.AreaBlockCategories) do

        if v then

            for key, val in pairs(v) do

                if Logic.IsEntityTypeInCategory(_Type, val[1]) == 1 then

                    if GetDistance(k, {X= _x, Y= _y}) < val[2] then

                        return false;

                    end

                end

            end

        end

    end



    -- Prüfe Typen

    for k, v in pairs(BundleConstructionControl.Global.Data.AreaBlockEntities) do

        if v then

            for key, val in pairs(v) do

                if _Type == val[1] then

                    if GetDistance(k, {X= _x, Y= _y}) < val[2] then

                        return false;

                    end

                end

            end

        end

    end



    return true;

end



-- -------------------------------------------------------------------------- --



Core:RegisterBundle("BundleConstructionControl");



-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleDestructionControl                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht es einzelne Gebäude, Typen oder Kategorien von Gebäuden vor
-- dem Abriss zu schützen. Ebenso kann jeglicher Abriss von Gebäuden auf
-- einem Territrium komplett unterbunden werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleDestructionControl = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Fügt ein Entity hinzu, dass nicht abgerissen werden darf.
--
-- @param[type=string] _entry Nicht abreißbares Entity
-- @within Anwenderfunktionen
--
-- @usage API.ProtectEntity("bakery");
--
function API.ProtectEntity(_entry)
    if not GUI then
        Logic.ExecuteInLuaLocalState([[
            API.ProtectEntity("]]..tostring(_entry)..[[")
        ]]);
    else
        if not Inside(_entry, BundleDestructionControl.Local.Data.Entities) then
            info("API.ProtectEntity: Adding " ..tostring(_entry).. " to protected list.");
            table.insert(BundleDestructionControl.Local.Data.Entities, _entry);
        end
    end
end

---
-- Fügt einen Entitytyp hinzu, der nicht abgerissen werden darf.
--
-- @param[type=number] _entry Nicht abreißbarer Typ
-- @within Anwenderfunktionen
--
-- @usage API.ProtectEntityType(Entities.B_Bakery);
--
function API.ProtectEntityType(_entry)
    if not GUI then
        Logic.ExecuteInLuaLocalState([[
            API.ProtectEntityType(]]..tostring(_entry)..[[)
        ]]);
    else
        if not Inside(_entry, BundleDestructionControl.Local.Data.EntityTypes) then
            info("API.ProtectEntityType: Adding " ..tostring(_entry).. " to protected list.");
            table.insert(BundleDestructionControl.Local.Data.EntityTypes, _entry);
        end
    end
end

---
-- Fügt eine Kategorie hinzu, die nicht abgerissen werden darf.
--
-- @param[type=number] _entry Nicht abreißbare Kategorie
-- @within Anwenderfunktionen
--
-- @usage API.ProtectCategory(EntityCategories.CityBuilding);
--
function API.ProtectCategory(_entry)
    if not GUI then
        Logic.ExecuteInLuaLocalState([[
            API.ProtectCategory(]]..tostring(_entry)..[[)
        ]]);
    else
        if not Inside(_entry, BundleDestructionControl.Local.Data.EntityCategories) then
            info("API.ProtectCategory: Adding " ..tostring(_entry).. " to protected list.");
            table.insert(BundleDestructionControl.Local.Data.EntityCategories, _entry);
        end
    end
end

---
-- Fügt ein Territory hinzu, auf dem nichts abgerissen werden kann.
--
-- @param[type=number] _entry Geschütztes Territorium
-- @within Anwenderfunktionen
--
-- @usage API.ProtectTerritory(1);
--
function API.ProtectTerritory(_entry)
    if not GUI then
        Logic.ExecuteInLuaLocalState([[
            API.ProtectTerritory(]]..tostring(_entry)..[[)
        ]]);
    else
        if not Inside(_entry, BundleDestructionControl.Local.Data.OnTerritory) then
            info("API.ProtectTerritory: Adding " ..tostring(_entry).. " to protected list.");
            table.insert(BundleDestructionControl.Local.Data.OnTerritory, _entry);
        end
    end
end

---
-- Entfernt ein Entity, dass nicht abgerissen werden darf.
--
-- @param[type=string] _entry Nicht abreißbares Entity
-- @within Anwenderfunktionen
--
-- @usage API.UnprotectEntity("bakery");
--
function API.UnprotectEntity(_entry)
    if not GUI then
        Logic.ExecuteInLuaLocalState([[
            API.UnprotectEntity("]]..tostring(_entry)..[[")
        ]]);
    else
        for i=1,#BundleDestructionControl.Local.Data.Entities do
            if BundleDestructionControl.Local.Data.Entities[i] == _entry then
                info("API.UnprotectEntity: Remove " ..tostring(_entry).. " from protected list.");
                table.remove(BundleDestructionControl.Local.Data.Entities, i);
                return;
            end
        end
    end
end

---
-- Entfernt einen Entitytyp, der nicht abgerissen werden darf.
--
-- @param[type=number] _entry Nicht abreißbarer Typ
-- @within Anwenderfunktionen
--
-- @usage API.UnprotectEntityType(Entities.B_Bakery);
--
function API.UnprotectEntityType(_entry)
    if not GUI then
        Logic.ExecuteInLuaLocalState([[
            API.UnprotectEntityType(]]..tostring(_entry)..[[)
        ]]);
    else
        for i=1,#BundleDestructionControl.Local.Data.EntityTypes do
            if BundleDestructionControl.Local.Data.EntityTypes[i] == _entry then
                info("API.UnprotectEntityType: Remove " ..tostring(_entry).. " from protected list.");
                table.remove(BundleDestructionControl.Local.Data.EntityTypes, i);
                return;
            end
        end
    end
end

---
-- Entfernt eine Kategorie, die nicht abgerissen werden darf.
--
-- @param[type=number] _entry Nicht abreißbare Kategorie
-- @within Anwenderfunktionen
--
-- @usage API.UnprotectCategory(EntityCategories.CityBuilding);
--
function API.UnprotectCategory(_entry)
    if not GUI then
        Logic.ExecuteInLuaLocalState([[
            API.UnprotectCategory(]]..tostring(_entry)..[[)
        ]]);
    else
        for i=1,#BundleDestructionControl.Local.Data.EntityCategories do
            if BundleDestructionControl.Local.Data.EntityCategories[i] == _entry then
                info("API.UnprotectCategory: Remove " ..tostring(_entry).. " from protected list.");
                table.remove(BundleDestructionControl.Local.Data.EntityCategories, i);
                return;
            end
        end
    end
end

---
-- Entfernt ein Territory, auf dem nichts abgerissen werden kann.
--
-- @param[type=number] _entry Geschütztes Territorium
-- @within Anwenderfunktionen
--
-- @usage API.UnprotectTerritory(1);
--
function API.UnprotectTerritory(_entry)
    if not GUI then
        Logic.ExecuteInLuaLocalState([[
            API.UnprotectTerritory(]]..tostring(_entry)..[[)
        ]]);
    else
        for i=1,#BundleDestructionControl.Local.Data.OnTerritory do
            if BundleDestructionControl.Local.Data.OnTerritory[i] == _entry then
                info("API.UnprotectTerritory: Remove " ..tostring(_entry).. " from protected list.");
                table.remove(BundleDestructionControl.Local.Data.OnTerritory, i);
                return;
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleDestructionControl = {
    Local = {
        Data = {
            Entities = {},
            EntityTypes = {},
            EntityCategories = {},
            OnTerritory = {},
        }
    },
}

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleDestructionControl.Local:Install()
    Core:AppendFunction(
        "GameCallback_GUI_DeleteEntityStateBuilding",
        BundleDestructionControl.Local.DeleteEntityStateBuilding
    );
end

---
-- Verhindert den Abriss von Entities.
--
-- @param[type=number] _BuildingID EntityID des Gebäudes
-- @within Internal
-- @local
--
function BundleDestructionControl.Local.DeleteEntityStateBuilding(_BuildingID)
    local eType = Logic.GetEntityType(_BuildingID);
    local eName = Logic.GetEntityName(_BuildingID);
    local tID   = GetTerritoryUnderEntity(_BuildingID);

    if Logic.IsConstructionComplete(_BuildingID) == 1 then
        -- Prüfe auf Namen
        if Inside(eName, BundleDestructionControl.Local.Data.Entities) then
            GUI.CancelBuildingKnockDown(_BuildingID);
            return;
        end

        -- Prüfe auf Typen
        if Inside(eType, BundleDestructionControl.Local.Data.EntityTypes) then
            GUI.CancelBuildingKnockDown(_BuildingID);
            return;
        end

        -- Prüfe auf Territorien
        if Inside(tID, BundleDestructionControl.Local.Data.OnTerritory) then
            GUI.CancelBuildingKnockDown(_BuildingID);
            return;
        end

        -- Prüfe auf Category
        for k,v in pairs(BundleDestructionControl.Local.Data.EntityCategories) do
            if Logic.IsEntityInCategory(_BuildingID, v) == 1 then
                GUI.CancelBuildingKnockDown(_BuildingID);
                return;
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleDestructionControl");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleDialogWindows                                          # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle können Dialogfenster ernstellt werden. Über Dialogfenster
-- kann der Spieler informiert werden. Er kann aber auch aufgefordert werden
-- eine Antwort auf eine Frage zu geben. Sollte bereits ein Dialog zu sehen
-- sein, werden neue Dialoge einer Warteschlange hinzugefügt und nacheinander
-- angezeigt.
--
-- Zudem bietet das Bundle ein Textfenster an, welches eine nicht limitierte
-- Menge an Text anzeigen kann. Erreicht der Text eine entsprechende Menge,
-- wird automatisch eine Scrollbar eingeblendet.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleDialogWindows = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Öffnet einen Info-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- <b>Alias</b>: UserOpenDialog
--
-- @param[type=string]   _Title  Titel des Dialog
-- @param[type=string]   _Text   Text des Dialog
-- @param[type=function] _Action Callback-Funktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.DialogInfoBox("Wichtige Information", "Diese Information ist Spielentscheidend!");
--
function API.DialogInfoBox(_Title, _Text, _Action)
    if not GUI then
        return;
    end

    _Title = API.ConvertPlaceholders(API.Localize(_Title));
    _Text  = API.ConvertPlaceholders(API.Localize(_Text));
    return BundleDialogWindows.Local:OpenDialog(_Title, _Text, _Action);
end
UserOpenDialog = API.DialogInfoBox;

---
-- Öffnet einen Ja-Nein-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- Um die Entscheigung des Spielers abzufragen, wird ein Callback benötigt.
-- Das Callback bekommt eine Boolean übergeben, sobald der Spieler die
-- Entscheidung getroffen hat.
--
-- <b>Alias</b>: UserOpenRequesterDialog
--
-- @param[type=string]   _Title    Titel des Dialog
-- @param[type=string]   _Text     Text des Dialog
-- @param[type=function] _Action   Callback-Funktion
-- @param[type=boolean]  _OkCancel Okay/Abbrechen statt Ja/Nein
-- @within Anwenderfunktionen
--
-- @usage
-- function YesNoAction(_yes)
--     if _yes then GUI.AddNote("Ja wurde gedrückt"); end
-- end
-- API.DialogRequestBox("Frage", "Möchtest du das wirklich tun?", YesNoAction, false);
--
function API.DialogRequestBox(_Title, _Text, _Action, _OkCancel)
    if not GUI then
        return;
    end
    _Title = API.ConvertPlaceholders(API.Localize(_Title));
    _Text = API.ConvertPlaceholders(API.Localize(_Text));
    return BundleDialogWindows.Local:OpenRequesterDialog(_Title, _Text, _Action, _OkCancel);
end
UserOpenRequesterDialog = API.DialogRequestBox;

---
-- Öffnet einen Auswahldialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- In diesem Dialog wählt der Spieler eine Option aus einer Liste von Optionen
-- aus. Anschließend erhält das Callback den Index der selektierten Option.
--
-- <b>Alias</b>: UserOpenSelectionDialog
--
-- @param[type=string]   _Title  Titel des Dialog
-- @param[type=string]   _Text   Text des Dialog
-- @param[type=function] _Action Callback-Funktion
-- @param[type=table]    _List   Liste der Optionen
-- @within Anwenderfunktionen
--
-- @usage
-- function OptionsAction(_idx)
--     GUI.AddNote(_idx.. " wurde ausgewählt!");
-- end
-- local List = {"Option A", "Option B", "Option C"};
-- API.DialogSelectBox("Auswahl", "Wähle etwas aus!", OptionsAction, List);
--
function API.DialogSelectBox(_Title, _Text, _Action, _List)
    if not GUI then
        return;
    end
    _Title = API.ConvertPlaceholders(API.Localize(_Title));
    _Text = API.ConvertPlaceholders(API.Localize(_Text));
    _Text = _Text .. "{cr}";
    return BundleDialogWindows.Local:OpenSelectionDialog(_Title, _Text, _Action, _List);
end
UserOpenSelectionDialog = API.DialogSelectBox;

---
-- Öffnet ein einfaches Textfenster mit dem angegebenen Text.
--
-- Die Länge des Textes ist nicht beschränkt. Überschreitet der Text die
-- Größe des Fensters, wird automatisch eine Bildlaufleiste eingeblendet.
--
-- @param[type=string] _Caption Titel des Fenster
-- @param[type=string] _content Inhalt des Fenster
-- @within Anwenderfunktionen
--
-- @usage
-- local Text = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, "..
--              "sed diam nonumy eirmod tempor invidunt ut labore et dolore"..
--              "magna aliquyam erat, sed diam voluptua. At vero eos et"..
--              " accusam et justo duo dolores et ea rebum. Stet clita kasd"..
--              " gubergren, no sea takimata sanctus est Lorem ipsum dolor"..
--              " sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing"..
--              " elitr, sed diam nonumy eirmod tempor invidunt ut labore et"..
--              " dolore magna aliquyam erat, sed diam voluptua. At vero eos"..
--              " et accusam et justo duo dolores et ea rebum. Stet clita"..
--              " kasd gubergren, no sea takimata sanctus est Lorem ipsum"..
--              " dolor sit amet.";
-- API.SimpleTextWindow("Überschrift", Text);
--
function API.SimpleTextWindow(_Caption, _Content)
    _Caption = API.ConvertPlaceholders(API.Localize(_Caption));
    _Content = API.ConvertPlaceholders(API.Localize(_Content));
    if not GUI then
        Logic.ExecuteInLuaLocalState(
            string.format([[API.SimpleTextWindow("%s", "%s")]], _Caption, _Content)
        );
        return;
    end
    QSB.TextWindow:New(_Caption, _Content):Show();
end

---
-- Blendet einen Text Zeichen für Zeichen auf schwarzem oder halbtransparentem
-- Grund ein.
--
-- Der Effekt startet erst, nachdem die Map geladen ist. Wenn ein Briefing
-- läuft, wird gewartet, bis das Briefing beendet ist. Wärhend der Effekt
-- läuft, können wiederrum keine Briefings starten.
--
-- <b>Hinweis</b>: Steuerzeichen wie {cr} oder {@color} werden als ein Token
-- gewertet und immer sofort eingeblendet. Steht z.B. {cr}{cr} im Text, werden
-- die Zeichen atomar behandelt, als seien sie ein einzelnes Zeichen.
-- Gibt es mehr als 1 Leerzeichen hintereinander, werden alle zusammenhängenden
-- Leerzeichen auf ein Leerzeichen reduziert!
--
-- @param[type=table] _Data Konfiguration
--
-- @usage
-- API.SimpleTypewriter {
--     Text =     "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, "..
--                "sed diam nonumy eirmod tempor invidunt ut labore et dolore"..
--                "magna aliquyam erat, sed diam voluptua. At vero eos et"..
--                " accusam et justo duo dolores et ea rebum. Stet clita kasd"..
--                " gubergren, no sea takimata sanctus est Lorem ipsum dolor"..
--                " sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing"..
--                " elitr, sed diam nonumy eirmod tempor invidunt ut labore et"..
--                " dolore magna aliquyam erat, sed diam voluptua. At vero eos"..
--                " et accusam et justo duo dolores et ea rebum. Stet clita"..
--                " kasd gubergren, no sea takimata sanctus est Lorem ipsum"..
--                " dolor sit amet.",
--     Callback = function(_Data)
--         -- Hier kann was passieren
--     end
-- };
-- @within Anwenderfunktionen
--
function API.SimpleTypewriter(_Data)
    if GUI then
        return;
    end
    local Text = API.ConvertPlaceholders(API.Localize(_Data.Text));
    local Instance = QSB.SimpleTypewriter:New(Text);
    if _Data.Callback then
        Instance:SetCallback(_Data.Callback);
    end
    if _Data.Position then
        Instance:SetPosition(_Data.Position);
    end
    if _Data.Speed and _Data.Speed > 0 then
        Instance:SetSpeed(_Data.Speed);
    end
    if _Data.Waittime and _Data.Waittime > 0 then
        Instance:SetWaittime(_Data.Waittime);
    end
    if _Data.Opacity and _Data.Opacity >= 0 and _Data.Opacity <= 1 then
        Instance:SetOpacity(_Data.Opacity);
    end
    if _Data.Color then
        Instance:SetColor(_Data.Color.R, _Data.Color.G, _Data.Color.B);
    end
    Instance:Start();
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleDialogWindows = {
    Global = {
        Data = {}
    },
    Local = {
        Data = {
            Requester = {
                ActionFunction = nil,
                ActionRequester = nil,
                Next = nil,
                Queue = {},
            },
        },
    },
}

-- Typewriter class ------------------------------------------------------------

QSB.SimpleTypewriter = {
    m_Tokens     = {},
    m_Delay      = 15,
    m_Waittime   = 80,
    m_Speed      = 1,
    m_Color      = {R = 0, G = 0, B = 0, A = 255},
    m_Index      = 0,
    m_Position   = 0,
    m_Text       = nil,
    m_JobID      = nil,
    m_Callback   = nil,
};

---
-- Erzeugt eine Neue Instanz der Schreibmaschinenschrift.
-- @param[type=string]   _Text     Anzuzeigender Text
-- @return[type=table] Neue Instanz
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:New(_Text)
    local typewriter = API.InstanceTable(self);
    typewriter.m_Text = _Text;
    return typewriter;
end

---
-- Setzt das Callback, welches am Ende der Anzeige aufgerufen wird.
-- @param[type=function] _Callback Funktion, die am Ende ausgeführt wird
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:SetCallback(_Callback)
    self.m_Callback = _Callback;
    return self;
end

---
-- Setzt das Entity auf das die Kamera fixiert wird.
-- @param _Position Skriptname oder ID
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:SetPosition(_Position)
    self.m_Position = _Position;
    return self;
end

---
-- Legt fest, wie transparent der Hintergund dargestellt wird.
-- @param[type=number] _Opacity Transparenz des Hintergrund
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:SetOpacity(_Opacity)
    self.m_Color.A = 255 * _Opacity;
    return self;
end

---
-- Legt fest, welche Farbe der Hindergrund hat.
-- @param[type=number] _Red   Rotwert des Hintergrund
-- @param[type=number] _Green Grünwert des Hintergrund
-- @param[type=number] _Blue  Blauwert des Hintergrund
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:SetColor(_Red, _Green, _Blue)
    self.m_Color.R = _Red;
    self.m_Color.G = _Green;
    self.m_Color.B = _Blue;
    return self;
end

---
-- Stellt ein, wie viele Zeichen in einer Interation angezeigt werden.
-- @param[type=number] _Speed Anzahl an Zeichen pro 1/10 Sekunde
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:SetSpeed(_Speed)
    self.m_Speed = _Speed;
    return self;
end

---
-- Stellt ein, wie lange nach Ausgabe des letzten Zeichens gewartet wird, bis
-- die Schreibmaschine endet.
-- @param[type=number] _Waittime Zeit in 1/10 Sekunden (8 Sekunden = 80)
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:SetWaittime(_Waittime)
    self.m_Waittime = _Waittime;
    return self;
end

---
-- Startet die Laufschrift. Wenn ein Briefing aktiv ist, oder die Map noch
-- nicht geladen ist, wird gewartet.
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:Start()
    if self:CanBePlayed() then
        self:Play();
        return self;
    end
    StartSimpleHiResJobEx(self.WaitForBriefingEnd, self);
    return self;
end

---
-- Spielt die Schreibmaschine ab.
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:Play()
    if BundleBriefingSystem then
        BundleBriefingSystem.Global.Data.BriefingActive = true;
    end
    self.m_InitialWaittime = self.m_Delay;
    self:TokenizeText();
    Logic.ExecuteInLuaLocalState(string.format(
        [[
            if BundleBriefingSystem then
                BundleBriefingSystem.Local.Data.BriefingActive = true
            end
			
			local Position = %d
			local ColorR, ColorG, ColorB, ColorA = %d,%d,%d,%d
			Core:InterfaceDeactivateNormalInterface()
            Core:InterfaceDeactivateBorderScroll(Position)
			Core:InterfaceActivateBlackBackground(ColorR, ColorG, ColorB, ColorA)
			
			if ColorA >= 255 then
				Camera.SwitchCameraBehaviour(5)
			end
			GUI.ActivateCutSceneState()
			Input.CutsceneMode()
			
            GUI.ClearNotes()
        ]],
		GetID(self.m_Position),
        self.m_Color.R,
        self.m_Color.G,
        self.m_Color.B,
        self.m_Color.A
    ));
    self.m_JobID = StartSimpleHiResJobEx(self.ControllerJob, self);
    return self;
end

---
-- Stoppt eine aktive Schreibmaschine.
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:Stop()
    if BundleBriefingSystem then
        BundleBriefingSystem.Global.Data.BriefingActive = false
    end
    Logic.ExecuteInLuaLocalState([[
        if BundleBriefingSystem then
            BundleBriefingSystem.Local.Data.BriefingActive = false
        end
		
		if Camera.GetCameraBehaviour() == 5 then
			Camera.SwitchCameraBehaviour(0)
		end
		GUI.ActivateSelectionState()
		Input.GameMode()

        Core:InterfaceActivateNormalInterface()
        Core:InterfaceActivateBorderScroll()
		Core:InterfaceDeactivateBlackBackground()

        GUI.ClearNotes()
    ]]);
    EndJob(self.m_JobID);
    return self;
end

---
-- Spaltet den Text in Tokens auf und speichert die Tokens für die Wiedergabe.
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:TokenizeText()
    self.m_Text = self.m_Text:gsub("%s+", " ");
    local TempTokens = {};
    local Text = self.m_Text;
    while (true) do
        local s1, e1 = Text:find("{");
        local s2, e2 = Text:find("}");
        if not s1 or not s2 then
            table.insert(TempTokens, Text);
            break;
        end
        if s1 > 1 then
            table.insert(TempTokens, Text:sub(1, s1 -1));
        end
        table.insert(TempTokens, Text:sub(s1, e2));
        Text = Text:sub(e2 +1);
    end

    local LastWasPlaceholder = false;
    for i= 1, #TempTokens, 1 do
        if TempTokens[i]:find("{") then
            local Index = #self.m_Tokens;
            if LastWasPlaceholder then
                self.m_Tokens[Index] = self.m_Tokens[Index] .. TempTokens[i];
            else
                table.insert(self.m_Tokens, Index+1, TempTokens[i]);
            end
            LastWasPlaceholder = true;
        else
            local Index = 1;
            while (Index <= #TempTokens[i]) do
                if string.byte(TempTokens[i]:sub(Index, Index)) == 195 then
                    table.insert(self.m_Tokens, TempTokens[i]:sub(Index, Index+1));
                    Index = Index +1;
                else
                    table.insert(self.m_Tokens, TempTokens[i]:sub(Index, Index)); 
                end
                Index = Index +1;
            end
            LastWasPlaceholder = false;
        end
    end
    return self;
end

---
-- Prüft, ob die Schreibmaschine gestartet werden kann.
-- @return[type=boolean] Schreibmaschine kann starten
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:CanBePlayed()
    if API.IsLoadscreenVisible() then
        return false;
    end
    if BundleBriefingSystem and IsBriefingActive() then
        return false;
    end
    if AddOnCutsceneSystem and IsCutsceneActive() then
        return false;
    end
    return true;
end

---
-- Job: Warte solange, bis Briefings beendet sind.
-- @param[type=table] Data
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter.WaitForBriefingEnd(_Data)
    if _Data:CanBePlayed() == true then
        _Data:Play();
        return true;
    end
end

---
-- Job: Kontrolliert die Anzeige der Schreibmaschine.
-- @param[type=table] Data
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter.ControllerJob(_Data)
    if _Data.m_InitialWaittime > 0 then
        _Data.m_InitialWaittime = _Data.m_InitialWaittime -1;
    end
    if _Data.m_InitialWaittime == 0 then
        _Data.m_Index = _Data.m_Index + _Data.m_Speed;
        if _Data.m_Index > #_Data.m_Tokens then
            _Data.m_Index = #_Data.m_Tokens;
        end
        local Index = math.ceil(_Data.m_Index);

        local Text = "";
        for i= 1, Index, 1 do
            Text = Text .. _Data.m_Tokens[i];
        end
        Logic.ExecuteInLuaLocalState([[
            GUI.ClearNotes()
            GUI.AddNote("]] ..Text.. [[");
        ]])
        
        if Index == #_Data.m_Tokens then
            _Data.m_Waittime = _Data.m_Waittime -1;
            if _Data.m_Waittime <= 0 then
                _Data:Stop();
                if _Data.m_Callback then
                    _Data.m_Callback(_Data);
                end
                return true;
            end
        end
    end
end

-- TextWindow class ------------------------------------------------------------

QSB.TextWindow = {
    Data = {
        Shown       = false,
        Caption     = "",
        Text        = "",
        ButtonText  = "",
        Picture     = nil,
        Action      = nil,
        Pause       = true,
        Callback    = function() end,
    },
};

---
-- Erzeugt ein Textfenster, dass einen beliebig großen Text anzeigen kann.
-- Optional kann ein Button genutzt werden, der eine Aktion ausführt, wenn
-- er gedrückt wird.
--
-- <p><b>Alias</b>: TextWindow:New</p>
--
-- Parameterliste:
-- <table>
-- <tr>
-- <th>Index</th>
-- <th>Beschreibung</th>
-- </tr>
-- <tr>
-- <td>1</td>
-- <td>Titel des Fensters</td>
-- </tr>
-- <tr>
-- <td>2</td>
-- <td>Text des Fensters</td>
-- </tr>
-- <tr>
-- <td>3</td>
-- <td>Aktion nach dem Schließen</td>
-- </tr>
-- <tr>
-- <td>4</td>
-- <td>Beschriftung des Buttons</td>
-- </tr>
-- <tr>
-- <td>5</td>
-- <td>Callback des Buttons</td>
-- </tr>
-- </table>
--
-- @param ... Parameterliste
-- @return[type=table] Instanz des konfigurierten Fensters
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- local MyWindow = TextWindow:New("Fenster", "Das ist ein Text");
--
function QSB.TextWindow:New(...)
    assert(self == QSB.TextWindow, "Can not be used from instance!")
    local window           = API.InstanceTable(self);
    window.Data.Caption    = arg[1] or window.Data.Caption;
    window.Data.Text       = arg[2] or window.Data.Text;
    window.Data.Action     = arg[3];
    window.Data.ButtonText = arg[4] or window.Data.ButtonText;
    window.Data.Callback   = arg[5] or window.Data.Callback;
    return window;
end

---
-- Fügt einen beliebigen Parameter hinzu. Parameter müssen immer als
-- Schlüssel-Wert-Paare angegeben werden und dürfen vorhandene Pare nicht
-- überschreiben.
--
-- <p><b>Alias</b>: TextWindow:AddParamater</p>
--
-- @param[type=string] _Key   Schlüssel
-- @param              _Value Wert
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- MyWindow:AddParameter("Name", "Horst");
--
function QSB.TextWindow:AddParamater(_Key, _Value)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    assert(self.Data[_Key] ~= nil, "Key '" .._Key.. "' already exists!");
    self.Data[_Key] = _Value;
    return self;
end

---
-- Setzt die Überschrift des TextWindow.
--
-- <p><b>Alias</b>: TextWindow:SetCaption</p>
--
-- @param[type=string] _Flag Spiel pausieren
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- MyWindow:SetPause(false);
--
function QSB.TextWindow:SetPause(_Flag)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    self.Data.Pause = _Flag == true;
    return self;
end

---
-- Setzt die Überschrift des TextWindow.
--
-- <p><b>Alias</b>: TextWindow:SetCaption</p>
--
-- @param[type=string] _Text Titel des Textfenster
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- MyWindow:SetCaption("Das ist der Titel");
--
function QSB.TextWindow:SetCaption(_Text)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    assert(type(_Text) == "string");
    self.Data.Caption = API.Localize(_Text);
    return self;
end

---
-- Setzt den Inhalt des TextWindow.
--
-- <p><b>Alias</b>: TextWindow:SetContent</p>
--
-- @param[type=string] _Text Inhalt des Textfenster
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- MyWindow:SetCaption("Das ist der Text. Er ist sehr informativ!");
--
function QSB.TextWindow:SetContent(_Text)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    assert(type(_Text) == "string");
    self.Data.Text = API.Localize(_Text);
    return self;
end

---
-- Setzt die Close Action des TextWindow. Die Funktion wird beim schließen
-- des Fensters ausgeführt.
--
-- <p><b>Alias</b>: TextWindow:SetAction</p>
--
-- @param[type=function] _Function Close Callback
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- local MyAction = function(_Window)
--     -- Something is done here!
-- end
-- MyWindow:SetAction(MyAction);
--
function QSB.TextWindow:SetAction(_Function)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    assert(nil or type(_Function) == "function");
    self.Data.Callback = _Function;
    return self;
end

---
-- Setzt einen Aktionsbutton im TextWindow.
--
-- Der Button muss mit einer Funktion versehen werden. Sobald der Button
-- betätigt wird, wird die Funktion ausgeführt.
--
-- <p><b>Alias</b>: TextWindow:SetButton</p>
--
-- @param[type=string]   _Text     Beschriftung des Buttons
-- @param[type=function] _Callback Aktion des Buttons
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- local MyButtonAction = function(_Window)
--     -- Something is done here!
-- end
-- MyWindow:SetAction("Button Text", MyButtonAction);
--
function QSB.TextWindow:SetButton(_Text, _Callback)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    if _Text then
        _Text = API.Localize(_Text);
        assert(type(_Text) == "string");
        assert(type(_Callback) == "function");
    end
    self.Data.ButtonText = _Text;
    self.Data.Action     = _Callback;
    return self;
end

---
-- Zeigt ein erzeigtes Fenster an.
--
-- <p><b>Alias</b>: TextWindow:Show</p>
--
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- MyWindow:Show();
--
function QSB.TextWindow:Show()
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    QSB.TextWindow.Data.Shown = true;
    self.Data.Shown = true;
    self:Prepare();

    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",1);
    if not self.Data.Action then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",0);
    end
    XGUIEng.SetText("/InGame/Root/Normal/MessageLog/Name","{center}"..self.Data.Caption);
    XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget","{center}"..self.Data.ButtonText);
    GUI_Chat.ClearMessageLog();
    GUI_Chat.ChatlogAddMessage(self.Data.Text);

    local stringlen = string.len(self.Data.Text);
    local iterator  = 1;
    local carreturn = 0;
    while (true)
    do
        local s,e = string.find(self.Data.Text, "{cr}", iterator);
        if not e then
            break;
        end
        if e-iterator <= 58 then
            stringlen = stringlen + 58-(e-iterator);
        end
        iterator = e+1;
    end
    if (stringlen + (carreturn*55)) > 1000 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",1);
    end
    if self.Data.Pause then
        Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);
    end
end

---
-- Initialisiert das TextWindow, bevor es angezeigt wird.
--
-- @within QSB.TextWindow
-- @local
--
function QSB.TextWindow:Prepare()
    function GUI_Chat.CloseChatMenu()
        QSB.TextWindow.Data.Shown = false;
        self.Data.Shown = false;
        if self.Data.Callback then
            self.Data.Callback(self);
        end
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",0);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",0);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",1);
        Game.GameTimeReset(GUI.GetPlayerID());
    end

    function GUI_Chat.ToggleWhisperTargetUpdate()
        if self.Data.Pause then
            Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);
        end
    end

    function GUI_Chat.CheckboxMessageTypeWhisperUpdate()
        XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/TextCheckbox","{center}"..self.Data.Caption);
    end

    function GUI_Chat.ToggleWhisperTarget()
        if self.Data.Action then
            self.Data.Action(self);
        end
    end

    function GUI_Chat.ClearMessageLog()
        g_Chat.ChatHistory = {}
    end

    function GUI_Chat.ChatlogAddMessage(_Message)
        table.insert(g_Chat.ChatHistory, _Message)
        local ChatlogMessage = ""
        for i,v in ipairs(g_Chat.ChatHistory) do
            ChatlogMessage = ChatlogMessage .. v .. "{cr}"
        end
        XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ChatLog", ChatlogMessage)
    end

    if type(self.Data.Caption) == "table" then
        self.Data.Caption = API.Localize(self.Data.Caption);
    end
    if type(self.Data.ButtonText) == "table" then
        self.Data.ButtonText = API.Localize(self.Data.ButtonText);
    end
    if type(self.Data.Text) == "table" then
        self.Data.Text = API.Localize(self.Data.Text);
    end

    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeAllPlayers",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeTeam",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeWhisper",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatChooseModeCaption",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Background/TitleBig",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Background/TitleBig/Info",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogCaption",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/BGChoose",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/BGChatLog",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",0);

    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",0);

    XGUIEng.DisableButton("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",0);

    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog",0,95);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog/Name",0,0);
    XGUIEng.SetTextColor("/InGame/Root/Normal/MessageLog/Name",51,51,121,255);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ChatLog",140,150);
    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/Background/DialogBG/1 (2)/2",150,400);
    XGUIEng.SetWidgetPositionAndSize("/InGame/Root/Normal/ChatOptions/Background/DialogBG/1 (2)/3",400,500,350,400);
    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/ChatLog",640,580);
    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/ChatLogSlider",46,660);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ChatLogSlider",780,130);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",110,760);
end

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Global:Install()
    API.AddSaveGameAction(function ()
        Logic.ExecuteInLuaLocalState("BundleDialogWindows.Local.DialogAltF4Hotkey()");
    end);
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:Install()
    self:DialogOverwriteOriginal();
    self:DialogAltF4Hotkey();
end

---
-- Überschreibt den Alt + F4 Hotkey.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:DialogAltF4Hotkey()
    StartSimpleJobEx(function ()
        if not API.IsLoadscreenVisible() then
            Input.KeyBindDown(Keys.ModifierAlt + Keys.F4, "BundleDialogWindows.Local:DialogAltF4Action()", 30, false);
            return true;
        end
    end);
end

---
-- Öffnet den Dialog mit der Frage, ob das Spiel verlassen werden
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:DialogAltF4Action()
    -- Muss leider sein, sonst werden mehr Elemente in die Queue geladen
    Input.KeyBindDown(Keys.ModifierAlt + Keys.F4, "", 30, false);

    -- Selbstgebauten Dialog öffnen
    self:OpenRequesterDialog(
        XGUIEng.GetStringTableText("UI_Texts/MainMenuExitGame_center"),
        XGUIEng.GetStringTableText("UI_Texts/ConfirmQuitCurrentGame"),
        function (_Yes) 
            if _Yes then 
                Framework.ExitGame(); 
            end
            BundleDialogWindows.Local:DialogAltF4Hotkey();
            Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
        end
    );

    -- Zeit anhelten
    Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);
end

---
-- Führt das Callback eines Info-Fensters oder eines Selektionsfensters aus.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:Callback()
    if self.Data.Requester.ActionFunction then
        self.Data.Requester.ActionFunction(CustomGame.Knight + 1);
    end
    self:OnDialogClosed();
end

---
-- Führt das Callback eines Ja-Nein-Dialogs aus.
--
-- @param[type=boolean] _yes Gegebene Antwort
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:CallbackRequester(_yes)
    if self.Data.Requester.ActionRequester then
        self.Data.Requester.ActionRequester(_yes);
    end
    self:OnDialogClosed();
end

---
-- Läd den nächsten Dialog aus der Warteschlange und stellt die Speicher-Hotkeys
-- wieder her.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:OnDialogClosed()
    self:DialogQueueStartNext();
    self:RestoreSaveGame();
end

---
-- Startet den nächsten Dialog in der Warteschlange, sofern möglich.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:DialogQueueStartNext()
    self.Data.Requester.Next = table.remove(self.Data.Requester.Queue, 1);

    DialogQueueStartNext_HiResControl = function()
        local Entry = BundleDialogWindows.Local.Data.Requester.Next;
        if Entry and Entry[1] and Entry[2] then
            local Methode = Entry[1];
            BundleDialogWindows.Local[Methode]( BundleDialogWindows.Local, unpack(Entry[2]) );
            BundleDialogWindows.Local.Data.Requester.Next = nil;
        end
        return true;
    end
    StartSimpleHiResJob("DialogQueueStartNext_HiResControl");
end

---
-- Fügt der Dialogwarteschlange einen neuen Dialog hinten an.
--
-- @param[type=string] _Methode Dialogfunktion als String
-- @param[type=table] _Args    Argumente als Table
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:DialogQueuePush(_Methode, _Args)
    local Entry = {_Methode, _Args};
    table.insert(self.Data.Requester.Queue, Entry);
end

---
-- Öffnet einen Info-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- @param[type=string]   _Title  Titel des Dialog
-- @param[type=string]   _Text   Text des Dialog
-- @param[type=function] _Action Callback-Funktion
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:OpenDialog(_Title, _Text, _Action)
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        assert(type(_Title) == "string");
        assert(type(_Text) == "string");

        _Title = "{center}" .. _Title;
        if string.len(_Text) < 35 then
            _Text = _Text .. "{cr}";
        end

        g_MapAndHeroPreview.SelectKnight = function()
        end

        XGUIEng.ShowAllSubWidgets("/InGame/Dialog/BG",1);
        XGUIEng.ShowWidget("/InGame/Dialog/Backdrop",0);
        XGUIEng.ShowWidget(RequesterDialog,1);
        XGUIEng.ShowWidget(RequesterDialog_Yes,0);
        XGUIEng.ShowWidget(RequesterDialog_No,0);
        XGUIEng.ShowWidget(RequesterDialog_Ok,1);

        if type(_Action) == "function" then
            self.Data.Requester.ActionFunction = _Action;
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)";
            Action = Action .. "; XGUIEng.PopPage()";
            Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
        else
            self.Data.Requester.ActionFunction = nil;
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)";
            Action = Action .. "; XGUIEng.PopPage()";
            Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
        end

        XGUIEng.SetText(RequesterDialog_Message, "{center}" .. _Text);
        XGUIEng.SetText(RequesterDialog_Title, _Title);
        XGUIEng.SetText(RequesterDialog_Title.."White", _Title);
        XGUIEng.PushPage(RequesterDialog,false);

        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", 0);
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", 0);
        if not KeyBindings_SaveGame_Orig_QSB_Windows then
            KeyBindings_SaveGame_Orig_QSB_Windows = KeyBindings_SaveGame;
            KeyBindings_SaveGame = function() end;
        end
        Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);
    else
        self:DialogQueuePush("OpenDialog", {_Title, _Text, _Action});
    end
end

---
-- Öffnet einen Ja-Nein-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- @param[type=string]   _Title    Titel des Dialog
-- @param[type=string]   _Text     Text des Dialog
-- @param[type=function] _Action   Callback-Funktion
-- @param[type=boolean]  _OkCancel Okay/Abbrechen statt Ja/Nein
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:OpenRequesterDialog(_Title, _Text, _Action, _OkCancel)
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        assert(type(_Title) == "string");
        assert(type(_Text) == "string");
        _Title = "{center}" .. _Title;

        self:OpenDialog(_Title, _Text, _Action);
        XGUIEng.ShowWidget(RequesterDialog_Yes,1);
        XGUIEng.ShowWidget(RequesterDialog_No,1);
        XGUIEng.ShowWidget(RequesterDialog_Ok,0);

        if _OkCancel ~= nil then
            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Ok_center"));
            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/Cancel_center"));
        else
            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Yes_center"));
            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/No_center"));
        end

        self.Data.Requester.ActionRequester = nil;
        if _Action then
            assert(type(_Action) == "function");
            self.Data.Requester.ActionRequester = _Action;
        end
        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
        Action = Action .. "; Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; BundleDialogWindows.Local.CallbackRequester(BundleDialogWindows.Local, true)"
        XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);
        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)"
        Action = Action .. "; Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; BundleDialogWindows.Local.CallbackRequester(BundleDialogWindows.Local, false)"
        XGUIEng.SetActionFunction(RequesterDialog_No, Action);
    else
        self:DialogQueuePush("OpenRequesterDialog", {_Title, _Text, _Action, _OkCancel});
    end
end

---
-- Öffnet einen Auswahldialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- @param[type=string]   _Title  Titel des Dialog
-- @param[type=string]   _Text   Text des Dialog
-- @param[type=function] _Action Callback-Funktion
-- @param[type=table]    _List   Liste der Optionen
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:OpenSelectionDialog(_Title, _Text, _Action, _List)
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        self:OpenDialog(_Title, _Text, _Action);

        local HeroComboBoxID = XGUIEng.GetWidgetID(CustomGame.Widget.KnightsList);
        XGUIEng.ListBoxPopAll(HeroComboBoxID);
        for i=1,#_List do
            XGUIEng.ListBoxPushItem(HeroComboBoxID, _List[i] );
        end
        XGUIEng.ListBoxSetSelectedIndex(HeroComboBoxID, 0);
        CustomGame.Knight = 0;

        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)"
        Action = Action .. "; Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";
        XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);

        local Container = "/InGame/Singleplayer/CustomGame/ContainerSelection/";
        XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", "");
        if _List[1] then
            XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", _List[1]);
        end
        XGUIEng.PushPage(Container .. "HeroComboBoxContainer", false);
        XGUIEng.PushPage(Container .. "HeroComboBoxMain",false);
        XGUIEng.ShowWidget(Container .. "HeroComboBoxContainer", 0);
        local screen = {GUI.GetScreenSize()};
        local x1, y1 = XGUIEng.GetWidgetScreenPosition(RequesterDialog_Ok);
        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxMain", x1-25, y1-(90*(screen[2]/1080)));
        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxContainer", x1-25, y1-(20*(screen[2]/1080)));
    else
        self:DialogQueuePush("OpenSelectionDialog", {_Title, _Text, _Action, _List});
    end
end

---
-- Stellt die Hotkeys zum Speichern des Spiels wieder her.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:RestoreSaveGame()
    if BundleGameHelperFunctions and not BundleGameHelperFunctions.Local.Data.ForbidSave then
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", 1);
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", 1);
    end
    if KeyBindings_SaveGame_Orig_QSB_Windows then
        KeyBindings_SaveGame = KeyBindings_SaveGame_Orig_QSB_Windows;
        KeyBindings_SaveGame_Orig_QSB_Windows = nil;
    end
end

---
-- Überschreibt die originalen Dialogfunktionen, um Fehler in den vorhandenen
-- Funktionen zu vermeiden.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:DialogOverwriteOriginal()
    OpenDialog_Orig_Windows = OpenDialog;
    OpenDialog = function(_Message, _Title, _IsMPError)
        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
            OpenDialog_Orig_Windows(_Title, _Message);
        end
    end

    OpenRequesterDialog_Orig_Windows = OpenRequesterDialog;
    OpenRequesterDialog = function(_Message, _Title, action, _OkCancel, no_action)
        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_No, Action);
            OpenRequesterDialog_Orig_Windows(_Message, _Title, action, _OkCancel, no_action);
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleDialogWindows");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleEntityCommandFunctions                                 # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Stellt Hilfsfunktionen bereit um Entities Befehle zu erteilen oder sie
-- von A nach B zu bewegen.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleEntityCommandFunctions = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Setzt ein Entity oder ein Battalion an eine neue Position.
--
-- <p><b>Alias:</b> SetPosition</p>
--
-- @param _Entity   Entity zum versetzen (Skriptname oder ID)
-- @param _Position Neue Position (Skriptname, ID oder Position)
-- @within Anwenderfunktionen
--
-- @usage
-- API.SetPosition("hakim", "hakimPos1");
--
function API.SetPosition(_Entity, _Position)
    if GUI then
        return;
    end
    if not IsExisting(_Entity) then
        error("API.SetPosition: Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    local Position = API.LocateEntity(_Position)
    if not API.ValidatePosition(Position) then
        error("API.SetPosition: Position is invalid!");
        return;
    end
    local EntityID = GetID(_Entity);
    info("API.SetPosition: Relocating entity " ..tostring(EntityID).. " to {X= " ..Position.X.. ", Y= " ..Position.Y.."}");
    return BundleEntityCommandFunctions.Global:SetPosition(_Entity, Position);
end
SetPosition = API.SetPosition;

---
-- Das Entity wird relativ zu einem Winkel zum Ziel bewegt. Nachdem das Entity
-- angekommen ist, wird es zum Ziel ausgerichtet.
--
-- <b>Hinweis</b>: Beim Alias MoveEntityToPositionToAnotherOne sind die
-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!
--
-- <p><b>Alias:</b> MoveEntityToPositionToAnotherOne</p>
-- <p><b>Alias:</b> MoveEx</br></p>
--
-- @param               _Entity       Entity zum versetzen (Skriptname oder ID)
-- @param               _Position     Neue Position (Skriptname oder ID)
-- @param[type=number]  _Distance     Entfernung zum Ziel
-- @param[type=number]  _Angle        Winkel
-- @param[type=boolean] _moveAsEntity Blocking ignorieren
-- @within Anwenderfunktionen
--
-- @usage
-- API.MoveToPosition("hakim", "saraya", 300, 0);
--
function API.MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity)
    if GUI then
        return;
    end
    if not IsExisting(_Entity) then
        error("API.MoveToPosition: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if not IsExisting(_Position) then
        error("API.MoveToPosition: _Position (" ..tostring(_Position).. ") does not exist!");
        return;
    end
    return BundleEntityCommandFunctions.Global:MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity);
end
MoveEntityToPositionToAnotherOne = function(_Entity, _Distance, _Position, _Angle, _moveAsEntity)
    API.MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity);
end
MoveEx = API.MoveToPosition;

---
-- Das Entity wird zum Ziel bewegt und schaut es anschließend an.
--
-- <b>Hinweis</b>: Beim Alias MoveEntityFaceToFaceToAnotherOne sind die
-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!
--
-- <p><b>Alias:</b> MoveEntityFaceToFaceToAnotherOne</p>
--
-- @param               _Entity       Entity zum versetzen (Skriptname oder ID)
-- @param               _Position     Neue Ziel (Skriptname oder ID)
-- @param[type=number]  _Distance     Entfernung zum Ziel
-- @param[type=boolean] _moveAsEntity Blocking ignorieren
-- @within Anwenderfunktionen
--
-- @usage
-- API.MoveAndLookAt("hakim", "saraya", 300);
--
function API.MoveAndLookAt(_Entity, _Position, _Distance, _moveAsEntity)
    if GUI then
        return;
    end
    if not IsExisting(_Entity) then
        error("API.MoveAndLookAt: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if not IsExisting(_Position) then
        error("API.MoveAndLookAt: _Position (" ..tostring(_Position).. ") does not exist!");
        return;
    end
    return BundleEntityCommandFunctions.Global:MoveToPosition(_Entity, _Position, _Distance, 0, _moveAsEntity);
end
MoveEntityFaceToFaceToAnotherOne = function(_Entity, _Distance, _Position, _moveAsEntity)
    API.MoveAndLookAt(_Entity, _Position, _Distance, _moveAsEntity)
end

---
-- Das Entity wird relativ zu einem Winkel zum Zielpunkt gesetzt.
--
-- <b>Hinweis</b>: Beim Alias PlaceEntityToPositionToAnotherOne sind die
-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!
--
-- <p><b>Alias:</b> PlaceEntityToPositionToAnotherOne</p>
--
-- @param               _Entity   Entity zum versetzen (Skriptname oder ID)
-- @param               _Position Neue Ziel (Skriptname oder ID)
-- @param[type=number]  _Distance Entfernung zum Ziel
-- @param[type=number]  _Angle    Winkel um die Position
-- @within Anwenderfunktionen
--
-- @usage
-- API.PlaceToPosition("hakim", "saraya", 300, 45);
--
function API.PlaceToPosition(_Entity, _Position, _Distance, _Angle)
    if GUI then
        return;
    end
    if not IsExisting(_Entity) then
        error("API.PlaceToPosition: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if not IsExisting(_Position) then
        error("API.PlaceToPosition: _Position (" ..tostring(_Position).. ") does not exist!");
        return;
    end
    local Position = BundleEntityCommandFunctions.Shared:GetRelativePos(_Position, _Distance, _Angle, true);
    API.SetPosition(_Entity, Position);
end
PlaceEntityToPositionToAnotherOne = function(_Entity, _Distance, _Position, _Angle)
    API.PlaceToPosition(_Entity, _Position, _Distance, _Angle);
end

---
-- Das Entity wird zum Zielpunkt gesetzt und schaut das Ziel an.
--
-- <b>Hinweis</b>: Beim Alias PlaceEntityFaceToFaceToAnotherOne sind die
-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!
--
-- <p><b>Alias:</b> PlaceEntityFaceToFaceToAnotherOne</p>
-- <p><b>Alias:</b> SetPositionEx<br></p>
--
-- @param              _Entity   Entity zum versetzen (Skriptname oder ID)
-- @param              _Position Neue Ziel (Skriptname oder ID)
-- @param[type=number] _Distance Entfernung
-- @within Anwenderfunktionen
--
-- @usage
-- API.PlaceAndLookAt("hakim", "saraya", 300);
--
function API.PlaceAndLookAt(_Entity, _Position, _Distance)
    if GUI then
        return;
    end
    API.PlaceToPosition(_Entity, _Position, _Distance, 0);
    LookAt(_Entity, _Position);
end
PlaceEntityFaceToFaceToAnotherOne = function(_Entity, _Distance, _Position)
    API.PlaceAndLookAt(_Entity, _Position, _Distance);
end
SetPositionEx = API.PlaceAndLookAt;

---
-- Das Entity greift ein anderes Entity an, sofern möglich.
--
-- <p><b>Alias:</b> Attack</p>
--
-- @param _Entity Entity zum versetzen (Skriptname oder ID)
-- @param _Target Neue Ziel (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.CommandAttack("hakim", "marcus");
--
function API.CommandAttack(_Entity, _Target)
    if GUI then
        return;
    end
    if not IsExisting(_Entity) then
        error("API.CommandAttack: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if not IsExisting(_Target) then
        local Subject = (type(_Target) == "string" and "'" .._Target.. "'") or _Target;
        error("API.CommandAttack: _Target (" ..tostring(_Target).. ") does not exist!");
        return;
    end
    local EntityID = GetID(_Entity);
    local TargetID = GetID(_Target);
    info("API.CommandAttack: Entity " ..EntityID.. " is attacking entity " ..TargetID);
    Logic.GroupAttack(EntityID, TargetID);
end
Attack = API.CommandAttack;

---
-- Ein Entity oder ein Battalion wird zu einer Position laufen und
-- alle gültigen Ziele auf dem Weg angreifen.
--
-- <p><b>Alias:</b> AttackMove</p>
--
-- @param              _Entity   Angreifendes Entity (Skriptname oder ID)
-- @param[type=string] _Position Zielposition
-- @within Anwenderfunktionen
--
-- @usage
-- API.CommandAttackMove("hakim", "area");
--
function API.CommandAttackMove(_Entity, _Position)
    if GUI then
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;
        error("API.CommandAttackMove: Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    local Position = API.LocateEntity(_Position)
    if not API.ValidatePosition(Position) then
        error("API.CommandAttackMove: Position is invalid!");
        return;
    end
    local EntityID = GetID(_Entity);
    info("API.CommandAttackMove: Entity " ..EntityID.. " is attacking position {X= " ..Position.X..", Y= " ..Position.Y.. "}");
    Logic.GroupAttackMove(EntityID, Position.X, Position.Y);
end
AttackMove = API.CommandAttackMove;

---
-- Bewegt das Entity zur Zielposition.
--
-- <p><b>Alias:</b> Move</p>
--
-- @param             _Entity   Angreifendes Entity (Skriptname oder ID)
-- @param[type=table] _Position  Positionstable
-- @within Anwenderfunktionen
--
-- @usage
-- API.CommandMove("hakim", "pos");
--
function API.CommandMove(_Entity, _Position)
    if GUI then
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;
        error("API.CommandMove: Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    local Position = API.LocateEntity(_Position)
    if not API.ValidatePosition(Position) then
        error("API.CommandMove: Position is invalid!");
        return;
    end
    local EntityID = GetID(_Entity);
    info("API.CommandMove: Moving entity " ..EntityID.. " to position {X= " ..Position.X..", Y= " ..Position.Y.. "}");
    Logic.MoveSettler(EntityID, Position.X, Position.Y);
end
Move = API.CommandMove;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleEntityCommandFunctions = {
    Global = {
        Data = {}
    },
    Shared = {
        Data = {}
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleEntityCommandFunctions.Global:Install()
end

-- Setzt ein Entity oder ein Battalion an eine neue Position.
--
-- @param _Entity   Entity zum versetzen (Skriptname oder ID)
-- @param _Position Neue Position (Skriptname, ID oder Position)
-- @within Internal
-- @local
--
function BundleEntityCommandFunctions.Global:SetPosition(_Entity,_Position)
    if not IsExisting(_Entity)then
        return
    end
    local EntityID = GetEntityId(_Entity);
    info("BundleEntityCommandFunctions: Moving entity " ..tostring(EntityID).. " to position {X= " .._Position.X..", Y= " .._Position.Y.. "}");
    Logic.DEBUG_SetSettlerPosition(EntityID, _Position.X, _Position.Y);
    if Logic.IsLeader(EntityID) == 1 then
        info("BundleEntityCommandFunctions: Entity " ..tostring(EntityID).. " is leader, so soldiers are dislocated as well.");
        local soldiers = {Logic.GetSoldiersAttachedToLeader(EntityID)};
        if soldiers[1] > 0 then
            for i=1,#soldiers do
                Logic.DEBUG_SetSettlerPosition(soldiers[i], _Position.X, _Position.Y);
            end
        end
    end
end

---
-- Das Entity wird relativ zu einem Winkel zum Zielpunkt bewegt.
--
-- @param               _Entity       Entity zum versetzen (Skriptname oder ID)
-- @param               _Position     Neue Position (Skriptname oder ID)
-- @param[type=number]  _Distance     Entfernung zum Ziel
-- @param[type=number]  _Angle        Winkel
-- @param[type=boolean] _moveAsEntity Blocking ignorieren
-- @within Internal
-- @local
--
function BundleEntityCommandFunctions.Global:MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity)
    if not IsExisting(_Entity)then
        return
    end
    local eID = GetID(_Entity);
    local tID = GetID(_Position);
    local pos = BundleEntityCommandFunctions.Shared:GetRelativePos(_Position, _Distance or 0, _Angle or 0);

    info("BundleEntityCommandFunctions: Moving entity " ..eID.. " to position {X= " ..pos.X..", Y= " ..pos.Y.. "}");
    if _moveAsEntity then
        Logic.MoveEntity(eID, pos.X, pos.Y);
    else
        Logic.MoveSettler(eID, pos.X, pos.Y);
    end

    StartSimpleJobEx( function(_EntityID, _TargetID)
        if not IsExisting(_EntityID) or not IsExisting(_TargetID) then
            return true;
        end
        if not Logic.IsEntityMoving(_EntityID) then
            LookAt(_EntityID, _TargetID);
            return true;
        end
    end, eID, tID);
end

-- Shared ----------------------------------------------------------------------

---
-- Errechnet eine Position relativ im angegebenen Winkel und Position zur
-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.
--
-- @param               _target          Basisposition (Skriptname, ID oder Position)
-- @param[type=number]  _distance        Entfernung
-- @param[type=number]  _angle           Winkel
-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang
-- @return[type=table] Position
-- @within Internal
-- @local
--
function BundleEntityCommandFunctions.Shared:GetRelativePos(_target,_distance,_angle,_buildingRealPos)
    if not type(_target) == "table" and not IsExisting(_target)then
        return;
    end
    if _angle == nil then
        _angle = 0;
    end

    local pos1;
    if type(_target) == "table" then
        local pos = _target;
        local ori = 0+_angle;
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};

        info("BundleEntityCommandFunctions: relative position for position {X= " ..pos.X.. ", Y= " ..pos.Y.."} is {X= " ..pos1.X..", Y= " ..pos1.Y.. "}");
    else
        local eID = GetID(_target);
        local pos = GetPosition(eID);
        local ori = Logic.GetEntityOrientation(eID)+_angle;
        if Logic.IsBuilding(eID) == 1 and not _buildingRealPos then
            x, y = Logic.GetBuildingApproachPosition(eID);
            pos = {X= x, Y= y};
            ori = ori -90;
        end
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};

        info("BundleEntityCommandFunctions: relative position of entity " ..eID.." is {X= " ..pos1.X..", Y= " ..pos1.Y.. "}");
    end
    return pos1;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleEntityCommandFunctions");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleEntityHelperFunctions                                  # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Stellt Hilfsfunktionen bereit um die Eigenschaften von Entities zu
-- ermitteln oder zu verändern.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleEntityHelperFunctions = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Sucht auf den angegebenen Territorium nach Entities mit bestimmten
-- Kategorien. Dabei kann für eine Partei oder für mehrere Parteien gesucht
-- werden.
--
-- <p><b>Alias:</b> GetEntitiesOfCategoriesInTerritories<br></p>
-- <p><b>Alias:</b> EntitiesInCategories</p>
--
-- @param _player      PlayerID [0-8] oder Table mit PlayerIDs (Einzelne Spielernummer oder Table)
-- @param _category    Kategorien oder Table mit Kategorien (Einzelne Kategorie oder Table)
-- @param _territory   Zielterritorium oder Table mit Territorien (Einzelnes Territorium oder Table)
-- @return[type=table] Liste mit Resultaten
-- @within Anwenderfunktionen
--
-- @usage
-- local Result = API.GetEntitiesOfCategoriesInTerritories({1, 2, 3}, EntityCategories.Hero, {5, 12, 23, 24});
--
function API.GetEntitiesOfCategoriesInTerritories(_player, _category, _territory)
    -- Tables erzwingen
    local p = (type(_player) == "table" and _player) or {_player};
    local c = (type(_category) == "table" and _category) or {_category};
    local t = (type(_territory) == "table" and _territory) or {_territory};

    local PlayerEntities = {};
    for i=1, #p, 1 do
        for j=1, #c, 1 do
            for k=1, #t, 1 do  
                local Units = API.GetEntitiesOfCategoryInTerritory(p[i], c[j], t[k]);
                PlayerEntities = Array_Append(PlayerEntities, Units);
            end
        end
    end
    return PlayerEntities;
end
GetEntitiesOfCategoriesInTerritories = API.GetEntitiesOfCategoriesInTerritories;
EntitiesInCategories = API.GetEntitiesOfCategoriesInTerritories;

---
-- Gibt alle Entities zurück, deren Name mit dem Prefix beginnt.
--
-- <p><b>Alias:</b> GetEntitiesNamedWith</p>
--
-- @param[type=string] _Prefix Präfix des Skriptnamen
-- @return[type=table] Liste mit Entities
-- @within Anwenderfunktionen
--
-- @usage
-- -- Alle Entities mit "entranceCave" -> entranceCave1, entranceCave2, ...
-- local Result = API.GetEntitiesByPrefix("entranceCave");
--
function API.GetEntitiesByPrefix(_Prefix)
    local list = {};
    local i = 1;
    local bFound = true;
    while bFound do
        local entity = GetID(_Prefix ..i);
        if entity ~= 0 then
            table.insert(list, entity);
        else
            bFound = false;
        end
        i = i + 1;
    end
    return list;
end
GetEntitiesNamedWith = API.GetEntitiesByPrefix;

---
-- Setzt die Menge an Rohstoffen und die durchschnittliche Auffüllmenge
-- in einer Mine.
--
-- <p><b>Alias:</b> SetResourceAmount</p>
--
-- @param              _Entity       Rohstoffvorkommen (Skriptname oder ID)
-- @param[type=number] _StartAmount  Menge an Rohstoffen
-- @param[type=number] _RefillAmount Minimale Nachfüllmenge (> 0)
-- @within Anwenderfunktionen
--
-- @usage
-- API.SetResourceAmount("mine1", 250, 150);
--
function API.SetResourceAmount(_Entity, _StartAmount, _RefillAmount)
    if GUI or not IsExisting(_Entity) then
        return;
    end
    return BundleEntityHelperFunctions.Global:SetResourceAmount(_Entity, _StartAmount, _RefillAmount);
end
SetResourceAmount = API.SetResourceAmount;

---
-- Errechnet eine Position relativ im angegebenen Winkel und Position zur
-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.
--
-- <p><b>Alias:</b> GetRelativePos</p>
--
-- @param               _target          Basisposition (Skriptname, ID oder Position)
-- @param[type=number]  _distance        Entfernung
-- @param[type=number]  _angle           Winkel
-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang
-- @return[type=table] Position
-- @within Anwenderfunktionen
--
-- @usage
-- local RelativePostion = API.GetRelativePosition("pos1", 1000, 32);
--
function API.GetRelativePosition(_target, _distance, _angle, _buildingRealPos)
    if not API.ValidatePosition(_target) and not IsExisting(_target) then
        error("API.EntityGetName: _target does not exist or is invalid position!");
        return;
    end
    return BundleEntityHelperFunctions.Shared:GetRelativePos(_target, _distance, _angle, _buildingRealPos);
end
GetRelativePos = API.GetRelativePosition;

---
-- Gibt den Skriptnamen des Entity zurück.
--
-- <p><b>Alias:</b> GetEntityName</p>
--
-- @param[type=number] _entity Gesuchtes Entity
-- @return[type=string] Skriptname
-- @within Anwenderfunktionen
--
-- @usage
-- local Name = API.EntityGetName(SomeEntityID);
--
function API.EntityGetName(_entity)
    if not IsExisting(_entity) then
        error("API.EntityGetName: _entity (" ..tostring(_entity).. ") does not exist!");
        return nil;
    end
    return Logic.GetEntityName(GetID(_entity));
end
GetEntityName = API.EntityGetName;

---
-- Setzt den Skriptnamen des Entity.
--
-- <p><b>Alias:</b> SetEntityName</p>
--
-- @param[type=number] _entity Entity
-- @param[type=string] _name   Skriptname
-- @return[type=string] Skriptname
-- @within Anwenderfunktionen
--
-- @usage
-- API.EntitySetName(SomeEntityID, "myEntity");
--
function API.EntitySetName(_entity, _name)
    if GUI then
        return;
    end
    if not IsExisting(_entity) then
        error("API.EntitySetName: _entity (" ..tostring(_entity).. ") does not exist!");
        return;
    end
    return Logic.SetEntityName(GetID(_entity), _name);
end
SetEntityName = API.EntitySetName;

---
-- Ermittelt den Helden eines Spielers, ders dem Basis-Entity am nächsten ist.
--
-- Im Fehlerfall wird 0 zurückgegeben.
--
-- <p><b>Alias:</b> GetClosestKnight</p>
--
-- @param[type=number] _eID      Basis-Entity
-- @param[type=number] _playerID Besitzer der Helden
-- @return[type=number] Nächstes Entity
-- @within Anwenderfunktionen
--
-- @usage
-- local Knight = API.GetKnightNearby(GetID("IO1"), 1);
--
function API.GetKnightNearby(_eID, _playerID)
    local Knights = {};
    Logic.GetKnights(_playerID, Knights);
    return API.GetEntityNearby(_eID, Knights);
end
GetClosestKnight = API.GetKnightNearby;

---
-- Ermittelt aus einer liste von Entity-IDs das Entity, dass dem Basis-Entity
-- am nächsten ist.
--
-- Im Fehlerfall wird 0 zurückgegeben.
--
-- <p><b>Alias:</b> GetClosestEntity</p>
--
-- @param[type=number] _eID      Basis-Entity
-- @param[type=table]  _entities Liste von Entities
-- @return[type=number] Nächstes Entity
-- @within Anwenderfunktionen
--
-- @usage
-- local EntityList = API.GetEntitiesOfCategoriesInTerritories({1, 2, 3}, EntityCategories.Hero, {5, 12, 23, 24});
-- local Knight = API.GetEntityNearby(GetID("IO1"), EntityList);
--
function API.GetEntityNearby(_eID, _entities)
    if not IsExisting(_eID) or #_entities == 0 then
        return 0;
    end
    return BundleEntityHelperFunctions.Shared:GetNearestEntity(_eID,_entities);
end
GetClosestEntity = API.GetEntityNearby;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleEntityHelperFunctions = {
    Global = {
        Data = {
            RefillAmounts = {},
        }
    },
    Shared = {
        Data = {}
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Global:Install()
    BundleEntityHelperFunctions.Global:OverwriteGeologistRefill();
end

---
-- Überschreibt das Auffüll-Callback, wenn es vorhanden ist, um Auffüllmengen
-- auch während des Spiels setzen zu können.
--
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Global:OverwriteGeologistRefill()
    if Framework.GetGameExtraNo() >= 1 then
        GameCallback_OnGeologistRefill_Orig_QSBPlusComforts1 = GameCallback_OnGeologistRefill
        GameCallback_OnGeologistRefill = function( _PlayerID, _TargetID, _GeologistID )
            GameCallback_OnGeologistRefill_Orig_QSBPlusComforts1( _PlayerID, _TargetID, _GeologistID )
            if BundleEntityHelperFunctions.Global.Data.RefillAmounts[_TargetID] then
                local RefillAmount = BundleEntityHelperFunctions.Global.Data.RefillAmounts[_TargetID];
                local RefillRandom = RefillAmount + math.random(1, math.floor((RefillAmount * 0.2) + 0.5));
                Logic.SetResourceDoodadGoodAmount(_TargetID, RefillRandom);
                if RefillRandom > 0 then
                    if Logic.GetResourceDoodadGoodType(_TargetID) == Goods.G_Iron then
                        Logic.SetModel(_TargetID, Models.Doodads_D_SE_ResourceIron);
                    else
                        Logic.SetModel(_TargetID, Models.R_ResorceStone_Scaffold);
                    end
                end
            end
        end
    end
end

-- Setzt die Menge an Rohstoffen und die durchschnittliche Auffüllmenge
-- in einer Mine.
--
-- @param              _Entity       Rohstoffvorkommen (Skriptname oder ID)
-- @param[type=number] _StartAmount  Menge an Rohstoffen
-- @param[type=number] _RefillAmount Minimale Nachfüllmenge (> 0)
-- @return[type=boolean] Operation erfolgreich
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Global:SetResourceAmount(_Entity, _StartAmount, _RefillAmount)
    assert(type(_StartAmount) == "number");
    assert(type(_RefillAmount) == "number");

    local EntityID = GetID(_Entity);
    if not IsExisting(EntityID) or Logic.GetResourceDoodadGoodType(EntityID) == 0 then
        error("SetResourceAmount: Resource entity is invalid!");
        return false;
    end
    if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then
        EntityID = ReplaceEntity(EntityID, Logic.GetEntityType(EntityID));
    end
    Logic.SetResourceDoodadGoodAmount(EntityID, _StartAmount);
    if _RefillAmount then
        self.Data.RefillAmounts[EntityID] = _RefillAmount;
    end
    return true;
end

-- Shared ----------------------------------------------------------------------

---
-- Errechnet eine Position relativ im angegebenen Winkel und Position zur
-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.
--
-- @param               _target          Basisposition (Skriptname, ID oder Position)
-- @param[type=number]  _distance        Entfernung
-- @param[type=number]  _angle           Winkel
-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang
-- @return[type=table] Position
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Shared:GetRelativePos(_target,_distance,_angle,_buildingRealPos)
    if not type(_target) == "table" and not IsExisting(_target) then
        return;
    end
    if _angle == nil then
        _angle = 0;
    end

    local pos1;
    if type(_target) == "table" then
        local pos = _target;
        local ori = 0+_angle;
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};

        info("BundleEntityHelperFunctions: relative position for position {X= " ..pos.X.. ", Y= " ..pos.Y.."} is {X= " ..pos1.X..", Y= " ..pos1.Y.. "}");
    else
        local eID = GetID(_target);
        local pos = GetPosition(eID);
        local ori = Logic.GetEntityOrientation(eID)+_angle;
        if Logic.IsBuilding(eID) == 1 and not _buildingRealPos then
            x, y = Logic.GetBuildingApproachPosition(eID);
            pos = {X= x, Y= y};
            ori = ori -90;
        end
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};

        info("BundleEntityHelperFunctions: relative position of entity " ..eID.." is {X= " ..pos1.X..", Y= " ..pos1.Y.. "}");
    end
    return pos1;
end

---
-- Ermittelt aus einer liste von Entity-IDs das Entity, dass dem Basis-Entity
-- am nächsten ist.
--
-- @param[type=number] _eID      Basis-Entity
-- @param[type=table]  _entities Liste von Entities
-- @return[type=number] Nächstes Entity
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Shared:GetNearestEntity(_eID,_entities)
    local bestDistance = Logic.WorldGetSize();
    local best = 0;
    for i=1,#_entities do
        if IsExisting(_entities[i]) then
            local distanceBetween = Logic.GetDistanceBetweenEntities(_entities[i], _eID);
            if distanceBetween < bestDistance and _entities[i] ~= _eID then
                bestDistance = distanceBetween;
                best = _entities[i];
            end
        end
    end
    return best;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleEntityHelperFunctions");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleEntityProperties                                       # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- In diesem Bundle werden grundlegende Funktionen zur Abfrage und Manipulation
-- von Entities bereitgestellt.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleEntityProperties = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Gibt den Größenfaktor des Entity zurück.
--
-- Der Faktor gibt an, um wie viel die Größe des Entity verändert wurde, im
-- Vergleich zur normalen Größe. Faktor 1 entspricht der normalen Größe.
--
-- <b>Alias</b>: GetScale
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=number] Größenfaktor des Entity
-- @within Anwenderfunktionen
--
function API.GetEntityScale(_Entity)
    if not IsExisting(_Entity) then
        error("API.EntityGetScale: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return 0;
    end
    return BundleEntityProperties.Shared:GetValueAsFloat(_Entity, QSB.ScriptingValues[QSB.ScriptingValues.Game].Size);
end
GetScale = API.GetEntityScale;

---
-- Setzt die Größe des Entity. Wenn es sich um einen Siedler handelt, wird
-- versucht einen neuen Speed Factor zu setzen.
--
-- <b>Alias</b>: SetScale
--
-- @param              _Entity Entity (Scriptname oder ID)
-- @param[type=number] _Scale Neuer Größenfaktor
-- @within Anwenderfunktionen
--
function API.SetEntityScale(_Entity, _Scale)
    if GUI then
        return;
    end
    if not IsExisting(_Entity) then
        error("API.SetEntityScale: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if type(_Scale) ~= "number" or _Scale <= 0 then
        error("API.SetEntityScale: _Scale (" ..tostring(_Scale).. ") must be a number above zero!");
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        Logic.SetEntityScriptingValue(EntityID, QSB.ScriptingValues[QSB.ScriptingValues.Game].Size, Core:ScriptingValueFloatToInteger(_Scale));
        if Logic.IsSettler(EntityID) == 1 then
            Logic.SetSpeedFactor(EntityID, _Scale);
        end
    end
end
SetScale = API.SetEntityScale;

---
-- Gibt den Besitzer des Entity zurück.
--
-- <b>Alias</b>: GetPlayer
--
-- @param[type=string] _Entity Scriptname des Entity
-- @return[type=number] Besitzer des Entity
-- @within Anwenderfunktionen
--
function API.GetEntityPlayer(_Entity)
    if not IsExisting(_Entity) then
        error("API.GetEntityPlayer: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return 0;
    end
    return BundleEntityProperties.Shared:GetValueAsInteger(_Entity, QSB.ScriptingValues[QSB.ScriptingValues.Game].Player);
end
GetPlayer = API.GetEntityPlayer;

---
-- Setzt den Besitzer des Entity.
--
-- <b>Alias</b>: SetPlayer
--
-- @param               _Entity  Entity (Scriptname oder ID)
-- @param[type=number] _PlayerID ID des Besitzers
-- @within Anwenderfunktionen
--
function API.SetEntityPlayer(_Entity, _PlayerID)
    if GUI then
        return;
    end
    if not IsExisting(_Entity) then
        error("API.SetEntityPlayer: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 0 or _PlayerID > 8 then
        error("API.SetEntityPlayer: _PlayerID (" ..tostring(_PlayerID).. ") must be a number between 0 and 8!");
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        if API.IsEntityInAtLeastOneCategory (
            EntityID,
            EntityCategories.Leader,
            EntityCategories.CattlePasture,
            EntityCategories.SheepPasture
        ) then
            Logic.ChangeSettlerPlayerID(EntityID, _PlayerID);
        else
            Logic.SetEntityScriptingValue(EntityID, QSB.ScriptingValues[QSB.ScriptingValues.Game].Player, _PlayerID);
        end
    end
end
SetPlayer = API.SetEntityPlayer;

---
-- Gibt die Ausrichtung des Entity zurück.
--
-- <b>Alias</b>: GetOrientation
--
-- @param               _Entity  Entity (Scriptname oder ID)
-- @return[type=number] Ausrichtung in Grad
-- @within Anwenderfunktionen
--
function API.GetEntityOrientation(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        return API.Round(Logic.GetEntityOrientation(EntityID));
    end
    error("API.GetEntityOrientation: _Entity (" ..tostring(_Entity).. ") does not exist!");
    return 0;
end
GetOrientation = API.GetEntityOrientation;

---
-- Setzt die Ausrichtung des Entity.
--
-- <b>Alias</b>: SetOrientation
--
-- @param               _Entity  Entity (Scriptname oder ID)
-- @param[type=number] _Orientation Neue Ausrichtung
-- @within Anwenderfunktionen
--
function API.SetEntityOrientation(_Entity, _Orientation)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        if type(_Orientation) ~= "number" then
            error("API.SetEntityOrientation: _Orientation is wrong!");
            return
        end
        Logic.SetOrientation(EntityID, API.Round(_Orientation));
    else
        error("API.SetEntityOrientation: _Entity (" ..tostring(_Entity).. ") does not exist!");
    end
end
SetOrientation = API.SetEntityOrientation;

---
-- Gibt die Menge an Rohstoffen des Entity zurück. Optional kann
-- eine neue Menge gesetzt werden.
--
-- <b>Alias</b>: GetResource
--
-- @param _Entity  Entity (Scriptname oder ID)
-- @return[type=number] Menge an Rohstoffen
-- @within Anwenderfunktionen
--
function API.GetResourceAmount(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        return Logic.GetResourceDoodadGoodAmount(EntityID);
    end
    error("API.GetResourceAmount: _Entity (" ..tostring(_Entity).. ") does not exist!");
    return 0;
end
GetResource = API.GetResourceAmount

---
-- Setzt die Menge an Rohstoffen des Entity.
--
-- <b>Alias</b>: SetResource
--
-- @param              _Entity  Entity (Scriptname oder ID)
-- @param[type=number] _Amount Menge an Rohstoffen
-- @within Anwenderfunktionen
--
function API.SetResourceAmount(_Entity, _Amount)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID > 0 or Logic.GetResourceDoodadGoodType(EntityID) > 0 then
        if type(_Amount) ~= "number" or _Amount < 0 then
            error("API.SetResourceAmount: _Amount must be 0 or greater!");
            return
        end
        if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then
            EntityID = ReplaceEntity(EntityID, Logic.GetEntityType(EntityID));
        end
        Logic.SetResourceDoodadGoodAmount(EntityID, _Amount);
    else
        error("API.SetResourceAmount: _Entity (" ..tostring(_Entity).. ") does not exist or is not a resource entity!");
    end
end
SetResource = API.SetResourceAmount;

---
-- Gibt die Gesundheit des Entity zurück.
--
-- <b>Alias</b>: GetHealth
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=number] Aktuelle Gesundheit
-- @within Anwenderfunktionen
--
function API.GetEntityHealth(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        return BundleEntityProperties.Shared:GetValueAsInteger(_Entity, QSB.ScriptingValues[QSB.ScriptingValues.Game].Health);
    end
    error("API.GetEntityHealth: _Entity (" ..tostring(_Entity).. ") does not exist!");
    return 0;
end
GetHealth = API.GetEntityHealth;

---
-- Setzt die Gesundheit des Entity. Optional kann die Gesundheit relativ zur
-- maximalen Gesundheit geändert werden.
--
-- <b>Alias</b>: SetHealth
--
-- @param               _Entity   Entity (Scriptname oder ID)
-- @param[type=number]  _Health   Neue aktuelle Gesundheit
-- @param[type=boolean] _Relative (Optional) Relativ zur maximalen Gesundheit
-- @within Anwenderfunktionen
--
function API.ChangeEntityHealth(_Entity, _Health, _Relative)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        if type(_Health) ~= "number" or _Health < 0 then
            error("API.ChangeEntityHealth: _Health " ..tostring(_Health).. "must be 0 or greater!");
            return
        end
        _Health = (_Health > MaxHealth and MaxHealth) or _Health;
        if Logic.IsLeader(EntityID) == 1 then
            for k, v in pairs(API.GetGroupSoldiers(EntityToHurt)) do
                API.ChangeEntityHealth(v, _Health, _Relative)
            end
        else
            local NewHealth = _Health;
            if _Relative then
                _Health = (_Health < 0 and 0) or _Health;
                _Health = (_Health > 100 and 100) or _Health;
                NewHealth = math.ceil((MaxHealth) * (_Health/100));
            end
            Logic.SetEntityScriptingValue(EntityID, QSB.ScriptingValues[QSB.ScriptingValues.Game].Health, NewHealth);
        end
        return;
    end
    error("API.ChangeEntityHealth: _Entity (" ..tostring(_Entity).. ") does not exist!");
end
SetHealth = API.ChangeEntityHealth;

---
-- Heilt das Entity um die angegebene Menge an Gesundheit.
--
-- <b>Alias</b>: HealEntity
--
-- @param               _Entity   Entity (Scriptname oder ID)
-- @param[type=number]  _Amount   Geheilte Gesundheit
-- @within Anwenderfunktionen
--
function API.GroupHeal(_Entity, _Amount)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 or Logic.IsLeader(EntityID) == 1 then
        error("API.GroupHeal: _Entity (" ..tostring(_Entity).. ") must be an existing leader!");
        return;
    end
    if type(_Amount) ~= "number" or _Amount < 0 then
        error("API.GroupHeal: _Amount (" ..tostring(_Amount).. ") must greatier than 0!");
        return;
    end
    API.ChangeEntityHealth(EntityID, API.GetEntityHealth(EntityID) + _Amount);
end
HealEntity = API.GroupHeal;

---
-- Verwundet ein Entity oder ein Battallion um die angegebene
-- Menge an Schaden. Bei einem Battalion wird der Schaden solange
-- auf Soldaten aufgeteilt, bis er komplett verrechnet wurde.
--
-- <b>Alias</b>: HurtEntity
--
-- @param               _Entity   Entity (Scriptname oder ID)
-- @param[type=number] _Damage   Schaden
-- @param[type=string] _Attacker Angreifer
-- @within Anwenderfunktionen
--
function API.GroupHurt(_Entity, _Damage, _Attacker)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.GroupHurt: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if API.IsEntityInAtLeastOneCategory(EntityID, EntityCategories.Soldier) then
        API.GroupHurt(API.GetGroupLeader(EntityID), _Damage);
        return;
    end

    local EntityToHurt = EntityID;
    local IsLeader = Logic.IsLeader(EntityToHurt) == 1;
    if IsLeader then
        EntityToHurt = API.GetGroupSoldiers(EntityToHurt)[1];
    end
    if type(_Damage) ~= "number" or _Damage < 0 then
        error("API.GroupHurt: _Damage (" ..tostring(_Damage).. ") must be greater than 0!");
        return;
    end

    local EntityKilled = false;
    local Health = Logic.GetEntityHealth(EntityToHurt);
    if EntityToHurt then
        if Health <= _Damage then
            _Damage = _Damage - Health;
            EntityKilled = true;
            Logic.HurtEntity(EntityToHurt, Health);
            BundleEntityProperties.Global:TriggerEntityKilledCallbacks(EntityToHurt, Health, _Attacker);
            if IsLeader and _Damage > 0 then
                API.GroupHurt(EntityToHurt, _Damage);
            end
        else
            Logic.HurtEntity(EntityToHurt, _Damage);
            BundleEntityProperties.Global:TriggerEntityKilledCallbacks(EntityToHurt, _Damage, _Attacker);
        end
    end
end
HurtEntity = API.GroupHurt;

---
-- Gibt zurück, ob das Gebäude brennt.
--
-- <b>Alias</b>: IsBurning
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=boolean] Gebäude steht in Flammen
-- @within Anwenderfunktionen
--
function API.IsBuildingBurning(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.IsBuildingBurning: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return 0;
    end
    return Logic.IsBurning(EntityID);
end
IsBurning = API.IsBuildingBurning;

---
-- Steckt ein Gebäude in Brand.
--
-- <b>Alias</b>: SetBurning
--
-- @param               _Entity   Entity (Scriptname oder ID)
-- @param[type=number]  _FireSize (Optional) Stärke des Brand
-- @within Anwenderfunktionen
--
function API.SetEntityBuildingBurning(_Entity, _FireSize)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.SetEntityBuildingBurning: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    -- TODO: Gebäude per Skript löschen!
    if _FireSize and _FireSize > 0 then
        Logic.DEBUG_SetBuildingOnFire(EntityID, _FireSize);
    end
end
SetBurning = API.SetEntityBuilding;

---
-- Gibt zurück, ob das Entity sichtbar ist.
--
-- <b>Alias</b>: IsVisible
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=boolean] Ist sichtbar
-- @within Anwenderfunktionen
--
function API.IsEntityVisible(_Entity)
    if not IsExisting(_Entity) then
        error("API.IsEntityVisible: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return false;
    end
    return BundleEntityProperties.Shared:GetValueAsInteger(_Entity, QSB.ScriptingValues[QSB.ScriptingValues.Game].Visible) == 801280;
end
IsVisible = API.IsEntityVisible;

---
-- Ändert die Sichtbarkeit des Entity.
--
-- <b>Alias</b>: SetVisible
--
-- @param               _Entity   Entity (Scriptname oder ID)
-- @param[type=boolean] _Visible (Optional) Sichtbarkeit ändern
-- @within Anwenderfunktionen
--
function API.SetEntityVisible(_Entity, _Visble)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.SetEntityVisible: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    Logic.SetVisible(EntityID, _Visble == true);
end
SetVisible = API.SetEntityVisible;

---
-- Prüft, ob das Entity krank ist.
--
-- <b>Alias</b>: IsIll
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=boolean] Entity ist krank
-- @within Anwenderfunktionen
--
function API.IsEntityIll(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.IsEntityIll: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return false;
    end
    if API.IsEntityInAtLeastOneCategory(
        EntityID,
        EntityCategories.CattlePasture,
        EntityCategories.SheepPasture
    ) then
        return Logic.IsFarmAnimalIll(EntityID);
    else
        return Logic.IsIll(EntityID);
    end
end
IsIll = API.IsEntityIll;

---
-- Macht das Entity krank.
--
-- <b>Alias</b>: MakeIll
--
-- @param _Entity Entity (Scriptname oder ID)
-- @within Anwenderfunktionen
--
function API.MakeEntityIll(_Entity)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.MakeEntityIll: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if API.IsEntityInAtLeastOneCategory(
        EntityID,
        EntityCategories.CattlePasture,
        EntityCategories.SheepPasture
    ) then
        Logic.MakeFarmAnimalIll(EntityID);
    else
        Logic.MakeSettlerIll(EntityID);
    end
end
MakeIll = API.MakeEntityIll;

---
-- Gibt zurück, ob eine NPC-Interaktion mit dem Siedler möglich ist.
--
-- <b>Alias</b>: IsNpc
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=boolean] Ist NPC
-- @within Anwenderfunktionen
--
function API.IsEntityActiveNpc(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        return BundleEntityProperties.Shared:GetValueAsInteger(EntityID, 6) > 0;
    end
    error("API.IsEntityActiveNpc: _Entity (" ..tostring(_Entity).. ") does not exist!");
    return false;
end
IsNpc = API.IsEntityActiveNpc;

---
-- Gibt das Bewegungsziel des Entity zurück.
--
-- <b>Alias</b>: GetDestination
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=table] Positionstabelle
-- @within Anwenderfunktionen
--
function API.GetEntityMovementTarget(_Entity)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        local SVX = QSB.ScriptingValues[QSB.ScriptingValues.Game].Destination.X
        local SVY = QSB.ScriptingValues[QSB.ScriptingValues.Game].Destination.Y;
        return {
            X= BundleEntityProperties.Shared:GetValueAsFloat(SVX),
            Y= BundleEntityProperties.Shared:GetValueAsFloat(SVY),
            Z= 0
        };
    end
    error("API.GetEntityMovementTarget: _Entity (" ..tostring(_Entity).. ") does not exist!");
    return {X= 0, Y= 0, Z= 0};
end
GetDestination = API.GetEntityMovementTarget;

---
-- Setzt das Entity oder das Battalion verwundbar oder unverwundbar.
--
-- <b>Alias</b>: SetVulnerable
-- 
-- @param               _Entity Entity (Scriptname oder ID)
-- @param[type=boolean] _Flag Verwundbar
-- @within Anwenderfunktionen
--
function API.SetEntityVulnerableFlag(_Entity, _Flag)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    local VulnerabilityFlag = (_Flag and 1) or 0;
    if EntityID > 0 then
        if API.CountSoldiersOfGroup(EntityID) > 0 then
            for k, v in pairs(API.GetGroupSoldiers(EntityID)) do
                Logic.SetEntityInvulnerabilityFlag(v, VulnerabilityFlag);
            end
        end
        Logic.SetEntityInvulnerabilityFlag(EntityID, VulnerabilityFlag);
    end
end
SetVulnerable = API.SetEntityVulnerableFlag;

MakeVulnerable = function(_Entity)
    API.SetEntityVulnerableFlag(_Entity, false);
end
MakeInvulnerable = function(_Entity)
    API.SetEntityVulnerableFlag(_Entity, true);
end

---
-- Gibt den Typen des Entity zurück.
--
-- <b>Alias</b>: GetType
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=number] Typ des Entity
-- @within Anwenderfunktionen
--
function API.GetEntityType(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        return Logic.GetEntityType(EntityID);
    end
    error("API.EntityGetType: _Entity (" ..tostring(_Entity).. ") must be a leader with soldiers!");
    return 0;
end
GetType = API.GetEntityType

---
-- Gibt den Typnamen des Entity zurück.
--
-- <b>Alias</b>: GetTypeName
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=string] Typname des Entity
-- @within Anwenderfunktionen
--
function API.GetEntityTypeName(_Entity)
    if not IsExisting(_Entity) then
        error("API.GetEntityTypeName: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    return Logic.GetEntityTypeName(API.GetEntityType(_Entity));
end
GetTypeName = API.GetEntityTypeName;

---
-- Setzt den Typen des Entity.
--
-- <b>Alias</b>: SetType
--
-- @param              _Entity  Entity (Scriptname oder ID)
-- @param[type=number] _NewType Typ neues Entity
-- @within Anwenderfunktionen
--
function API.SetEntityType(_Entity, _NewType)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.SetEntityType: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    ReplaceEntity(EntityID, _NewType);
end
SetType = API.SetEntityType;

---
-- Gibt die aktuelle Tasklist des Entity zurück.
--
-- <b>Alias</b>: GetTask
--
-- @param _Entity Entity (Scriptname oder ID)
-- @return[type=number] Tasklist
-- @within Anwenderfunktionen
--
function API.GetEntityTaskList(_Entity, _NewTask)
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.GetEntityTaskList: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return 0;
    end
    local CurrentTask = Logic.GetCurrentTaskList(EntityID);
    return TaskLists[CurrentTask];
end
GetTask = API.GetEntityTaskList;

---
-- Setzt die aktuelle Tasklist des Entity.
--
-- <b>Alias</b>: SetTask
--
-- @param              _Entity  Entity (Scriptname oder ID)
-- @param[type=number] _NewTask Neuer Task
-- @within Anwenderfunktionen
--
function API.SetEntityTaskList(_Entity, _NewTask)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.SetEntityTaskList: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if type(_NewTask) ~= "number" or _NewTask < 1 then
        error("API.SetEntityTaskList: _NewTask (" ..tostring(_NewTask).. ") is wrong!");
        return;
    end
    Logic.SetTaskList(EntityID, _NewTask);
end
SetTask = API.SetEntityTaskList;

---
-- Weist dem Entity ein Neues Model zu.
--
-- <b>Alias</b>: SetModel
--
-- @param              _Entity  Entity (Scriptname oder ID)
-- @param[type=number] _NewModel Neues Model
-- @param[type=number] _AnimSet  (optional) Animation Set
-- @within Anwenderfunktionen
--
function API.SetEntityModel(_Entity, _NewModel, _AnimSet)
    if GUI then
        return;
    end
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.SetEntityModel: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return;
    end
    if type(_NewModel) ~= "number" or _NewModel < 1 then
        error("API.SetEntityModel: _NewModel (" ..tostring(_NewModel).. ") is wrong!");
        return;
    end
    if _AnimSet and (type(_AnimSet) ~= "number" or _AnimSet < 1) then
        error("API.SetEntityModel: _AnimSet (" ..tostring(_AnimSet).. ") is wrong!");
        return;
    end
    if not _AnimSet then
        Logic.SetModel(EntityID, _NewModel);
    else
        Logic.SetModelAndAnimSet(EntityID, _NewModel, _AnimSet);
    end
end
SetModel = API.SetEntityModel;

---
-- Gibt die Mänge an Soldaten zurück, die dem Entity unterstehen
--
-- <b>Alias</b>: CoundSoldiers
--
-- @param _Entity Entity (Skriptname oder ID)
-- @return[type=number] Menge an Soldaten
-- @within Anwenderfunktionen
--
function API.CountSoldiersOfGroup(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.CountSoldiersOfGroup: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return 0;
    end
    if Logic.IsLeader(EntityID) == 0 then
        return 0;
    end
    local SoldierTable = {Logic.GetSoldiersAttachedToLeader(EntityID)};
    return SoldierTable[1];
end
CoundSoldiers = API.CountSoldiersOfGroup;

---
-- Gibt die IDs aller Soldaten zurück, die zum Battalion gehören.
--
-- <b>Alias</b>: GetSoldiers
--
-- @param _Entity Entity (Skriptname oder ID)
-- @return[type=table] Liste aller Soldaten
-- @within Anwenderfunktionen
--
function API.GetGroupSoldiers(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.GetGroupSoldiers: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return {};
    end
    if Logic.IsLeader(EntityID) == 0 then
        return {};
    end
    local SoldierTable = {Logic.GetSoldiersAttachedToLeader(EntityID)};
    table.remove(SoldierTable, 1);
    return SoldierTable;
end
GetSoldiers = API.GetGroupSoldiers;

---
-- Gibt den Leader des Soldaten zurück.
--
-- <b>Alias</b>: GetLeader
--
-- @param _Entity Entity (Skriptname oder ID)
-- @return[type=number] Menge an Soldaten
-- @within Anwenderfunktionen
--
function API.GetGroupLeader(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.GetGroupLeader: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return 0;
    end
    if Logic.IsEntityInCategory(EntityID, EntityCategories.Soldier) == 0 then 
        return 0;
    end
    return Logic.SoldierGetLeaderEntityID(EntityID);
end
GetLeader = API.GetGroupLeader;

---
-- Gibt alle Kategorien zurück, zu denen das Entity gehört.
--
-- <b>Alias</b>: GetCategories
--
-- @param              _Entity Entity (Skriptname oder ID)
-- @return[type=table] Kategorien des Entity
-- @within Internal
-- @local
--
function API.GetEntityCategoyList(_Entity)
    local EntityID = GetID(_Entity);
    if EntityID == 0 then
        error("API.GetEntityCategoyList: _Entity (" ..tostring(_Entity).. ") does not exist!");
        return {};
    end
    local Categories = {};
    for k, v in pairs(EntityCategories) do
        if Logic.IsEntityInCategory(EntityID, v) == 1 then 
            Categories[#Categories+1] = v;
        end
    end
    return Categories;
end
GetCategories = API.GetEntityCategoyList;

---
-- Prüft, ob das Entity mindestens eine der Kategorien hat.
--
-- <b>Alias</b>: IsInCategory
--
-- @param              _Entity Entity (Skriptname oder ID)
-- @param[type=number] ...     Liste mit Kategorien
-- @return[type=boolean] Entity hat Kategorie
-- @within Internal
-- @local
--
function API.IsEntityInAtLeastOneCategory(_Entity, ...)
    local EntityID = GetID(_Entity);
    if EntityID > 0 then
        for k, v in pairs(arg) do
            if Inside(v, API.GetEntityCategoyList(_Entity)) then
                return true;
            end
        end
        return;
    end
    error("API.IsEntityInAtLeastOneCategory: _Entity (" ..tostring(_Entity).. ") does not exist!");
    return false;
end
IsInCategory = API.IsEntityInAtLeastOneCategory;

-- -------------------------------------------------------------------------- --
-- Internal                                                                   --
-- -------------------------------------------------------------------------- --

BundleEntityProperties = {
    Global = {
        Data = {};
    },
    Shared = {
        Data = {};
    },
}

---
-- Installiert das Bundle.
--
function BundleEntityProperties.Global:Install()
end

---
-- Löst die entsprechenden Callbacks aus, sollte das Entity durch den Schaden
-- durch :Hurt sterben. Callbacks werden nur ausgelöst, wenn der Angreifer
-- angegeben wurde.
--
-- @param[type=number] _Damage   Schaden
-- @param[type=string] _Attacker Angreifer
-- @within Internal
-- @local
--
function BundleEntityProperties.Global:TriggerEntityKilledCallbacks(_Entity, _Damage, _Attacker)
    local DefenderID = GetID(_Entity);
    local AttackerID = GetID(_Attacker or 0);
    if AttackerID == 0 or DefenderID == 0 or Logic.GetEntityHealth(DefenderID) > 0 then
        return;
    end
    local x, y, z     = Logic.EntityGetPos(DefenderID);
    local DefPlayerID = Logic.EntityGetPlayer(DefenderID);
    local DefType     = Logic.GetEntityType(DefenderID);
    local AttPlayerID = Logic.EntityGetPlayer(AttackerID);
    local AttType     = Logic.GetEntityType(AttackerID);

    GameCallback_EntityKilled(DefenderID, DefPlayerID, AttackerID, AttPlayerID, DefType, AttType);
    Logic.ExecuteInLuaLocalState(string.format(
        "GameCallback_Feedback_EntityKilled(%d, %d, %d, %d,%d, %d, %f, %f)",
        DefenderID, DefPlayerID, AttackerID, AttPlayerID, DefType, AttType, x, y
    ));
end

---
-- Gibt die Scripting Value des Entity als Ganzzahl zurück.
--
-- @param              _Entity Entity (Skriptname oder ID)
-- @param[type=number] _Index  Index im RAM
-- @return[type=number] Ganzzahl
-- @within Internal
-- @local
--
function BundleEntityProperties.Shared:GetValueAsInteger(_Entity, _Index)
    return math.floor(Logic.GetEntityScriptingValue(GetID(_Entity), _Index) + 0.5);
end

---
-- Gibt die Scripting Value des Entity als Dezimalzahl zurück.
--
-- @param              _Entity Entity (Skriptname oder ID)
-- @param[type=number] _index  Index im RAM
-- @return[type=number] Dezimalzahl
-- @within Internal
-- @local
--
function BundleEntityProperties.Shared:GetValueAsFloat(_Entity, _Index)
    return Core:ScriptingValueIntegerToFloat(Logic.GetEntityScriptingValue(GetID(_Entity), _Index));
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleEntityProperties");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleEntitySelection                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle kann die Selektion von Entities gesteuert werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleEntitySelection = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Deaktiviert oder aktiviert das Entlassen von Dieben.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableReleaseThieves(false);
--
function API.DisableReleaseThieves(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.DisableReleaseThieves(" ..tostring(_Flag).. ")");
        return;
    end
    BundleEntitySelection.Local.Data.ThiefRelease = not _Flag;
end

---
-- Deaktiviert oder aktiviert das Entlassen von Kriegsmaschinen.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableReleaseSiegeEngines(true);
--
function API.DisableReleaseSiegeEngines(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.DisableReleaseSiegeEngines(" ..tostring(_Flag).. ")");
        return;
    end
    BundleEntitySelection.Local.Data.SiegeEngineRelease = not _Flag;
end

---
-- Deaktiviert oder aktiviert das Entlassen von Soldaten.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableReleaseSoldiers(false);
--
function API.DisableReleaseSoldiers(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.DisableReleaseSoldiers(" ..tostring(_Flag).. ")");
        return;
    end
    BundleEntitySelection.Local.Data.MilitaryRelease = not _Flag;
end

---
-- Prüpft ob das Entity selektiert ist.
--
-- @param _Entity Entity das selektiert sein soll (Skriptname oder ID)
-- @return[type=boolean] Entity ist selektiert
-- @within Anwenderfunktionen
--
-- @usage
-- if API.IsEntityInSelection("hakim") then
--     -- Do something
-- end
--
function API.IsEntityInSelection(_Entity)
    if IsExisting(_Entity) then
        local EntityID = GetID(_Entity);
        local SelectedEntities;
        if not GUI then
            SelectedEntities = BundleEntitySelection.Global.Data.SelectedEntities;
        else
            SelectedEntities = {GUI.GetSelectedEntities()};
        end
        for i= 1, #SelectedEntities, 1 do
            if SelectedEntities[i] == EntityID then
                return true;
            end
        end
    end
    return false;
end
IsEntitySelected = API.IsEntityInSelection;

---
-- Gibt die ID des selektierten Entity zurück.
--
-- Wenn mehr als ein Entity selektiert sind, wird das erste Entity
-- zurückgegeben. Sind keine Entities selektiert, wird 0 zurückgegeben.
--
-- @return[type=number] ID des selektierten Entities
-- @within Anwenderfunktionen
--
-- @usage
-- local SelectedEntity = API.GetSelectedEntity();
--
function API.GetSelectedEntity()
    local SelectedEntity;
    if not GUI then
        SelectedEntity = BundleEntitySelection.Global.Data.SelectedEntities[1];
    else
        SelectedEntity = GUI.GetSelectedEntity();
    end
    return SelectedEntity or 0;
end
GetSelectedEntity = API.GetSelectedEntity;

---
-- Gibt alle selektierten Entities zurück.
--
-- @return[type=table] ID des selektierten Entities
-- @within Anwenderfunktionen
--
-- @usage
-- local Selection = API.GetSelectedEntities();
--
function API.GetSelectedEntities()
    local SelectedEntities;
    if not GUI then
        SelectedEntities = BundleEntitySelection.Global.Data.SelectedEntities;
    else
        SelectedEntities = {GUI.GetSelectedEntities()};
    end
    return SelectedEntities;
end
GetSelectedEntities = API.GetSelectedEntities;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleEntitySelection = {
    Global = {
        Data = {
            TrebuchetIDToCart = {},
            SelectedEntities = {};
        },
    },
    Local = {
        Data = {
            ThiefRelease = false,
            SiegeEngineRelease = true,
            MilitaryRelease = true,

            Tooltips = {
                KnightButton = {
                    Title = {
                        de = "Ritter selektieren",
                        en = "Select Knight",
                    },
                    Text = {
                        de = "- Klick selektiert den Ritter {cr}- Doppelklick springt zum Ritter{cr}- STRG halten selektiert alle Ritter",
                        en = "- Click selects the knight {cr}- Double click jumps to knight{cr}- Press CTRL to select all knights",
                    },
                },

                BattalionButton = {
                    Title = {
                        de = "Militär selektieren",
                        en = "Select Units",
                    },
                    Text = {
                        de = "- Selektiert alle Militäreinheiten {cr}- SHIFT halten um auch Munitionswagen und Trebuchets auszuwählen",
                        en = "- Selects all military units {cr}- Press SHIFT to additionally select ammunition carts and trebuchets",
                    },
                },

                ReleaseSoldiers = {
                    Title = {
                        de = "Militär entlassen",
                        en = "Release military unit",
                    },
                    Text = {
                        de = "- Eine Militäreinheit entlassen {cr}- Soldaten werden nacheinander entlassen",
                        en = "- Dismiss a military unit {cr}- Soldiers will be dismissed each after another",
                    },
                    Disabled = {
                        de = "Kann nicht entlassen werden!",
                        en = "Releasing is impossible!",
                    },
                },

                TrebuchetCart = {
                    Title = {
                        de = "Trebuchetwagen",
                        en = "Trebuchet cart",
                    },
                    Text = {
                        de = "- Kann einmalig zum Trebuchet ausgebaut werden",
                        en = "- Can uniquely be transmuted into a trebuchet",
                    },
                },

                Trebuchet = {
                    Title = {
                        de = "Trebuchet",
                        en = "Trebuchet",
                    },
                    Text = {
                        de = "- Kann über weite Strecken Gebäude angreifen {cr}- Kann Gebäude in Brand stecken {cr}- Trebuchet kann manuell zurückgeschickt werden",
                        en = "- Can perform long range attacks on buildings {cr}- Can set buildings on fire {cr}- The trebuchet can be manually send back to the city",
                    },
                },
            },
        },
    },

};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleEntitySelection.Global:Install()
end

---
-- Baut ein Trebuchet zu einem Trebuchet-Wagen ab.
-- @param[type=number] _EntityID EntityID of Trebuchet
-- @within Internal
-- @local
--
function BundleEntitySelection.Global:MilitaryDisambleTrebuchet(_EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local PlayerID = Logic.EntityGetPlayer(_EntityID);

    -- Externes Callback für das Kartenskript
    -- Bricht die Ausführung dieser Funktion ab!
    if GameCallback_QSB_OnDisambleTrebuchet then
        GameCallback_QSB_OnDisambleTrebuchet(_EntityID, PlayerID, x, y, z);
        return;
    end

    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);
    Logic.SetEntitySelectableFlag(_EntityID, 0);
    Logic.SetVisible(_EntityID, false);

    local TrebuchetCart = self.Data.TrebuchetIDToCart[_EntityID];
    if TrebuchetCart ~= nil then
        Logic.SetEntityInvulnerabilityFlag(TrebuchetCart, 0);
        Logic.SetEntitySelectableFlag(TrebuchetCart, 1);
        Logic.SetVisible(TrebuchetCart, true);
    else
        TrebuchetCart = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, PlayerID);
        self.Data.TrebuchetIDToCart[_EntityID] = TrebuchetCart;
    end

    Logic.DEBUG_SetSettlerPosition(TrebuchetCart, x, y);
    Logic.SetTaskList(TrebuchetCart, TaskLists.TL_NPC_IDLE);
    Logic.ExecuteInLuaLocalState([[
        GUI.SelectEntity(]]..TrebuchetCart..[[)
    ]]);
end

---
-- Baut einen Trebuchet-Wagen zu einem Trebuchet aus.
-- @param[type=number] _EntityID EntityID of Trebuchet
-- @within Internal
-- @local
--
function BundleEntitySelection.Global:MilitaryErectTrebuchet(_EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local PlayerID = Logic.EntityGetPlayer(_EntityID);

    -- Externes Callback für das Kartenskript
    -- Bricht die Ausführung dieser Funktion ab!
    if GameCallback_QSB_OnErectTrebuchet then
        GameCallback_QSB_OnErectTrebuchet(_EntityID, PlayerID, x, y, z);
        return;
    end

    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);
    Logic.SetEntitySelectableFlag(_EntityID, 0);
    Logic.SetVisible(_EntityID, false);

    local Trebuchet;
    for k, v in pairs(self.Data.TrebuchetIDToCart) do
        if v == _EntityID then
            Trebuchet = tonumber(k);
        end
    end
    if Trebuchet == nil then
        Trebuchet = Logic.CreateEntity(Entities.U_Trebuchet, x, y, 0, PlayerID);
        self.Data.TrebuchetIDToCart[Trebuchet] = _EntityID;
    end

    Logic.SetEntityInvulnerabilityFlag(Trebuchet, 0);
    Logic.SetEntitySelectableFlag(Trebuchet, 1);
    Logic.SetVisible(Trebuchet, true);
    Logic.DEBUG_SetSettlerPosition(Trebuchet, x, y);
    Logic.ExecuteInLuaLocalState([[
        GUI.SelectEntity(]]..Trebuchet..[[)
    ]]);
end

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:Install()
    self:OverwriteSelectAllUnits();
    self:OverwriteSelectKnight();
    self:OverwriteNamesAndDescription();
    self:OverwriteThiefDeliver();
    self:OverwriteMilitaryDismount();
    self:OverwriteMultiselectIcon();
    self:OverwriteMilitaryDisamble();
    self:OverwriteMilitaryErect();
    self:OverwriteMilitaryCommands();

    Core:AppendFunction(
        "GameCallback_GUI_SelectionChanged",
        self.OnSelectionCanged
    );
end

---
-- Callback-Funktion, die aufgerufen wird, wenn sich die Selektion ändert.
--
-- @param[type=number] _Source Selection Source
-- @within Internal
-- @local
--
function BundleEntitySelection.Local.OnSelectionCanged(_Source)
    local SelectedEntities = {GUI.GetSelectedEntities()}
    local PlayerID = GUI.GetPlayerID();
    local EntityID = GUI.GetSelectedEntity();
    local EntityType = Logic.GetEntityType(EntityID);

    -- Schreibe die selektierten Entities ins globale Skript
    local SelectedEntitiesString = API.ConvertTableToString(SelectedEntities);
    GUI.SendScriptCommand("BundleEntitySelection.Global.Data.SelectedEntities = " ..SelectedEntitiesString);

    if EntityID ~= nil then
        if EntityType == Entities.U_SiegeEngineCart then
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngineCart", 1);
        elseif EntityType == Entities.U_Trebuchet then
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack", 0);
            GUI_Military.StrengthUpdate();
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngine", 1);
        end
    end
end

---
-- Überschreibt die Millitärkommandos "Stop" und "Angreifen".
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMilitaryCommands()
    GUI_Military.StandGroundClicked = function()
        Sound.FXPlay2DSound( "ui\\menu_click");
        local SelectedEntities = {GUI.GetSelectedEntities()};

        for i=1,#SelectedEntities do
            local LeaderID = SelectedEntities[i];
            local eType = Logic.GetEntityType(LeaderID);
            GUI.SendCommandStationaryDefend(LeaderID);
            if eType == Entities.U_Trebuchet then
                GUI.SendScriptCommand([[
                    Logic.SetTaskList(]]..LeaderID..[[, TaskLists.TL_NPC_IDLE)
                ]]);
            end
        end

    end

    GUI_Military.StandGroundUpdate = function()
        local WidgetAttack = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack";
        local SelectedEntities = {GUI.GetSelectedEntities()};

        SetIcon(WidgetAttack, {12, 4});

        if #SelectedEntities == 1 then
            local eID = SelectedEntities[1];
            local eType = Logic.GetEntityType(eID);
            if eType == Entities.U_Trebuchet then
                if Logic.GetAmmunitionAmount(eID) > 0 then
                    XGUIEng.ShowWidget(WidgetAttack, 0);
                else
                    XGUIEng.ShowWidget(WidgetAttack, 1);
                end
                SetIcon(WidgetAttack, {1, 10});
            else
                XGUIEng.ShowWidget(WidgetAttack, 1);
            end
        end
    end
end

---
-- Überschreibt das Aufbauen von Kriegsmaschinen, sodass auch Trebuchets
-- auf- und abgebaut werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMilitaryErect()
    GUI_Military.ErectClicked_Orig_BundleEntitySelection = GUI_Military.ErectClicked;
    GUI_Military.ErectClicked = function()
        GUI_Military.ErectClicked_Orig_BundleEntitySelection();

        local PlayerID = GUI.GetPlayerID();
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1, #SelectedEntities, 1 do
            local EntityType = Logic.GetEntityType(SelectedEntities[i]);
            if EntityType == Entities.U_SiegeEngineCart then
                GUI.SendScriptCommand([[
                    BundleEntitySelection.Global:MilitaryErectTrebuchet(]]..SelectedEntities[i]..[[)
                ]]);
            end
        end
    end

    GUI_Military.ErectUpdate_Orig_BundleEntitySelection = GUI_Military.ErectUpdate;
    GUI_Military.ErectUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local SiegeCartID = GUI.GetSelectedEntity();
        local PlayerID = GUI.GetPlayerID();
        local EntityType = Logic.GetEntityType(SiegeCartID);

        if EntityType == Entities.U_SiegeEngineCart then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            SetIcon(CurrentWidgetID, {12, 6});
        else
            GUI_Military.ErectUpdate_Orig_BundleEntitySelection();
        end
    end

    GUI_Military.ErectMouseOver_Orig_BundleEntitySelection = GUI_Military.ErectMouseOver;
    GUI_Military.ErectMouseOver = function()
        local SiegeCartID = GUI.GetSelectedEntity();
        local TooltipTextKey;
        if Logic.GetEntityType(SiegeCartID) == Entities.U_SiegeEngineCart then
            TooltipTextKey = "ErectCatapult";
        else
            GUI_Military.ErectMouseOver_Orig_BundleEntitySelection();
            return;
        end
        GUI_Tooltip.TooltipNormal(TooltipTextKey, "Erect");
    end
end

---
-- Überschreibt das Abbauen von Kriegsmaschinen, sodass auch Trebuchets
-- abgebaut werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMilitaryDisamble()
    GUI_Military.DisassembleClicked_Orig_BundleEntitySelection = GUI_Military.DisassembleClicked;
    GUI_Military.DisassembleClicked = function()
        GUI_Military.DisassembleClicked_Orig_BundleEntitySelection();

        local PlayerID = GUI.GetPlayerID();
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1, #SelectedEntities, 1 do
            local EntityType = Logic.GetEntityType(SelectedEntities[i]);
            if EntityType == Entities.U_Trebuchet then
                GUI.SendScriptCommand([[
                    BundleEntitySelection.Global:MilitaryDisambleTrebuchet(]]..SelectedEntities[i]..[[)
                ]]);
            end
        end
    end

    GUI_Military.DisassembleUpdate_Orig_BundleEntitySelection = GUI_Military.DisassembleUpdate;
    GUI_Military.DisassembleUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local PlayerID = GUI.GetPlayerID();
        local SiegeEngineID = GUI.GetSelectedEntity();
        local EntityType = Logic.GetEntityType(SiegeEngineID);

        if EntityType == Entities.U_Trebuchet then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            SetIcon(CurrentWidgetID, {12, 9});
        else
            GUI_Military.DisassembleUpdate_Orig_BundleEntitySelection();
        end
    end
end

---
-- Überschreibt die Multiselektion, damit Trebuchets ein Icon bekommen.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMultiselectIcon()
    GUI_MultiSelection.IconUpdate_Orig_BundleEntitySelection = GUI_MultiSelection.IconUpdate;
    GUI_MultiSelection.IconUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);
        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);
        local Index = CurrentMotherName + 0;
        local CurrentMotherPath = XGUIEng.GetWidgetPathByID(CurrentMotherID);
        local HealthWidgetPath = CurrentMotherPath .. "/Health";
        local EntityID = g_MultiSelection.EntityList[Index];
        local EntityType = Logic.GetEntityType(EntityID);
        local HealthState = Logic.GetEntityHealth(EntityID);
        local EntityMaxHealth = Logic.GetEntityMaxHealth(EntityID);

        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then
            GUI_MultiSelection.IconUpdate_Orig_BundleEntitySelection();
            return;
        end
        if Logic.IsEntityAlive(EntityID) == false then
            XGUIEng.ShowWidget(CurrentMotherID, 0);
            GUI_MultiSelection.CreateEX();
            return;
        end

        SetIcon(CurrentWidgetID, g_TexturePositions.Entities[EntityType]);

        HealthState = math.floor(HealthState / EntityMaxHealth * 100);
        if HealthState < 50 then
            local green = math.floor(2*255* (HealthState/100));
            XGUIEng.SetMaterialColor(HealthWidgetPath,0,255,green, 20,255);
        else
            local red = 2*255 - math.floor(2*255* (HealthState/100));
            XGUIEng.SetMaterialColor(HealthWidgetPath,0,red, 255, 20,255);
        end
        XGUIEng.SetProgressBarValues(HealthWidgetPath,HealthState, 100);
    end

    GUI_MultiSelection.IconMouseOver_Orig_BundleEntitySelection = GUI_MultiSelection.IconMouseOver;
    GUI_MultiSelection.IconMouseOver = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);
        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);
        local Index = tonumber(CurrentMotherName);
        local EntityID = g_MultiSelection.EntityList[Index];
        local EntityType = Logic.GetEntityType(EntityID);

        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then
            GUI_MultiSelection.IconMouseOver_Orig_BundleEntitySelection();
            return;
        end

        if EntityType == Entities.U_SiegeEngineCart then
            local TooltipData = BundleEntitySelection.Local.Data.Tooltips.TrebuchetCart;
            BundleEntitySelection.Local:SetTooltip(API.Localize(TooltipData.Title), API.Localize(TooltipData.Text));
        elseif EntityType == Entities.U_Trebuchet then
            local TooltipData = BundleEntitySelection.Local.Data.Tooltips.Trebuchet;
            BundleEntitySelection.Local:SetTooltip(API.Localize(TooltipData.Title), API.Localize(TooltipData.Text));
        end
    end
end

---
-- Überschreibt die Funktion zur Beendigung der Eskorte, damit Einheiten auch
-- entlassen werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMilitaryDismount()
    GUI_Military.DismountClicked_Orig_BundleEntitySelection = GUI_Military.DismountClicked;
    GUI_Military.DismountClicked = function()
        local Selected = GUI.GetSelectedEntity();
        local Type = Logic.GetEntityType(Selected);
        local Guarded = Logic.GetGuardedEntityID(Selected);
        local Guardian = Logic.GetGuardianEntityID(Selected);
        
        if Guarded ~= 0 and Logic.EntityGetPlayer(Guarded) ~= GUI.GetPlayerID() then
            GUI_Military.DismountClicked_Orig_BundleEntitySelection();
            return;
        end
        if Logic.IsKnight(Selected) or Logic.IsEntityInCategory(Selected, EntityCategories.AttackableMerchant) == 1 then
            GUI_Military.DismountClicked_Orig_BundleEntitySelection();
            return;
        end

        if Logic.IsLeader(Selected) == 1 and Guarded == 0 then
            if BundleEntitySelection.Local.Data.MilitaryRelease then
                Sound.FXPlay2DSound( "ui\\menu_click");
                local Soldiers = {Logic.GetSoldiersAttachedToLeader(Selected)};
                GUI.SendScriptCommand([[DestroyEntity(]]..Soldiers[#Soldiers]..[[)]]);
                return;
            end
        end

        if Type == Entities.U_AmmunitionCart or Type == Entities.U_BatteringRamCart
        or Type == Entities.U_CatapultCart or Type == Entities.U_SiegeTowerCart
        or Type == Entities.U_MilitaryBatteringRam or Entities.U_MilitaryCatapult
        or Type == Entities.U_MilitarySiegeTower then
            if BundleEntitySelection.Local.Data.SiegeEngineRelease and Guardian == 0 then
                Sound.FXPlay2DSound( "ui\\menu_click");
                GUI.SendScriptCommand([[DestroyEntity(]]..Selected..[[)]]);
            else
                GUI_Military.DismountClicked_Orig_BundleEntitySelection();
            end
        end
    end

    GUI_Military.DismountUpdate_Orig_BundleEntitySelection = GUI_Military.DismountUpdate;
    GUI_Military.DismountUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local Selected = GUI.GetSelectedEntity();
        local Type = Logic.GetEntityType(Selected);
        local Guarded = Logic.GetGuardedEntityID(Selected);
        local Guardian = Logic.GetGuardianEntityID(Selected);
        
        SetIcon(CurrentWidgetID, {12, 1});
        if Guarded ~= 0 and Logic.EntityGetPlayer(Guarded) ~= GUI.GetPlayerID() then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            GUI_Military.DismountUpdate_Orig_BundleEntitySelection();
            return;
        end
        if Logic.IsKnight(Selected) or Logic.IsEntityInCategory(Selected, EntityCategories.AttackableMerchant) == 1 then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            GUI_Military.DismountUpdate_Orig_BundleEntitySelection();
            return;
        end
        SetIcon(CurrentWidgetID, {14, 12});

        if Type == Entities.U_MilitaryLeader then
            if not BundleEntitySelection.Local.Data.MilitaryRelease then
                XGUIEng.DisableButton(CurrentWidgetID, 1);
            else
                XGUIEng.DisableButton(CurrentWidgetID, 0);
            end
            return;
        end

        if Type == Entities.U_AmmunitionCart or Type == Entities.U_BatteringRamCart
        or Type == Entities.U_CatapultCart or Type == Entities.U_SiegeTowerCart
        or Type == Entities.U_MilitaryBatteringRam or Entities.U_MilitaryCatapult
        or Type == Entities.U_MilitarySiegeTower then
            if Guardian ~= 0 then
                SetIcon(CurrentWidgetID, {12, 1});
                XGUIEng.DisableButton(CurrentWidgetID, 0);
            else
                if not BundleEntitySelection.Local.Data.SiegeEngineRelease then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                else
                    XGUIEng.DisableButton(CurrentWidgetID, 0);
                end
            end
        end
    end
end

---
-- Überschreibt "Beute abließern", sodass Diebe entlassen werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteThiefDeliver()
    GUI_Thief.ThiefDeliverClicked_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverClicked;
    GUI_Thief.ThiefDeliverClicked = function()
        if not BundleEntitySelection.Local.Data.ThiefRelease then
            GUI_Thief.ThiefDeliverClicked_Orig_BundleEntitySelection();
            return;
        end

        Sound.FXPlay2DSound( "ui\\menu_click");
        local PlayerID = GUI.GetPlayerID();
        local ThiefID = GUI.GetSelectedEntity()
        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then
            return;
        end
        GUI.SendScriptCommand([[DestroyEntity(]]..ThiefID..[[)]]);
    end

    GUI_Thief.ThiefDeliverMouseOver_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverMouseOver;
    GUI_Thief.ThiefDeliverMouseOver = function()
        if not BundleEntitySelection.Local.Data.ThiefRelease then
            GUI_Thief.ThiefDeliverMouseOver_Orig_BundleEntitySelection();
            return;
        end

        BundleEntitySelection.Local:SetTooltip(
            API.Localize(BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Title),
            API.Localize(BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Text),
            API.Localize(BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Disabled)
        );
    end

    GUI_Thief.ThiefDeliverUpdate_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverUpdate;
    GUI_Thief.ThiefDeliverUpdate = function()
        if not BundleEntitySelection.Local.Data.ThiefRelease then
            GUI_Thief.ThiefDeliverUpdate_Orig_BundleEntitySelection();
            return;
        end

        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local ThiefID = GUI.GetSelectedEntity();
        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then
            XGUIEng.DisableButton(CurrentWidgetID, 1);
        else
            XGUIEng.DisableButton(CurrentWidgetID, 0);
        end
        SetIcon(CurrentWidgetID, {14, 12});
    end
end

---
-- Hängt eine Funktion an die GUI_Tooltip.SetNameAndDescription an, sodass
-- Tooltips überschrieben werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteNamesAndDescription()
    GUI_Tooltip.SetNameAndDescription_Orig_QSB_EntitySelection = GUI_Tooltip.SetNameAndDescription;
    GUI_Tooltip.SetNameAndDescription = function(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean)
        local MotherWidget = "/InGame/Root/Normal/AlignBottomRight";
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();

        if XGUIEng.GetWidgetID(MotherWidget.. "/MapFrame/KnightButton") == CurrentWidgetID then
            BundleEntitySelection.Local:SetTooltip(
                API.Localize(BundleEntitySelection.Local.Data.Tooltips.KnightButton.Title),
                API.Localize(BundleEntitySelection.Local.Data.Tooltips.KnightButton.Text)
            );
            return;
        end

        if XGUIEng.GetWidgetID(MotherWidget.. "/MapFrame/BattalionButton") == CurrentWidgetID then
            BundleEntitySelection.Local:SetTooltip(
                API.Localize(BundleEntitySelection.Local.Data.Tooltips.BattalionButton.Title),
                API.Localize(BundleEntitySelection.Local.Data.Tooltips.BattalionButton.Text)
            );
            return;
        end

        if XGUIEng.GetWidgetID(MotherWidget.. "/DialogButtons/SiegeEngineCart/Dismount") == CurrentWidgetID 
        or XGUIEng.GetWidgetID(MotherWidget.. "/DialogButtons/AmmunitionCart/Dismount") == CurrentWidgetID 
        or XGUIEng.GetWidgetID(MotherWidget.. "/DialogButtons/Military/Dismount") == CurrentWidgetID 
        then
            local SelectedEntity = GUI.GetSelectedEntity();
            if SelectedEntity ~= 0 then
                if Logic.IsEntityInCategory(SelectedEntity, EntityCategories.Military) == 1 then
                    local GuardianEntity = Logic.GetGuardianEntityID(SelectedEntity);
                    local GuardedEntity = Logic.GetGuardedEntityID(SelectedEntity);
                    if GuardianEntity == 0 and GuardedEntity == 0 then
                        BundleEntitySelection.Local:SetTooltip(
                            API.Localize(BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Title),
                            API.Localize(BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Text),
                            API.Localize(BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Disabled)
                        );
                        return;
                    end
                end
            end
        end

        GUI_Tooltip.SetNameAndDescription_Orig_QSB_EntitySelection(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean);
    end
end

---
-- Schreibt einen anderen Text in einen normalen Tooltip.
--
-- @param[type=string] _TitleText    Titel des Tooltip
-- @param[type=string] _DescText     Text des Tooltip
-- @param[type=string] _DisabledText Disabled Text des Tooltip
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:SetTooltip(_TitleText, _DescText, _DisabledText)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();

    _DisabledText = _DisabledText or "";
    local DisabledText = "";
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _DescText ~= "" then
        DisabledText = DisabledText .. "{cr}{@color:255,32,32,255}" .. _DisabledText;
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _TitleText);
    XGUIEng.SetText(TooltipDescriptionWidget, _DescText .. DisabledText);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);
end

---
-- Überschreibt den SelectKnight-Button. Durch drücken von CTLR können alle
-- Helden selektiert werden, die der Spieler kontrolliert.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteSelectKnight()
    GUI_Knight.JumpToButtonClicked = function()
        local PlayerID = GUI.GetPlayerID();
        local KnightID = Logic.GetKnightID(PlayerID);
        if KnightID > 0 then
            g_MultiSelection.EntityList = {};
            g_MultiSelection.Highlighted = {};
            GUI.ClearSelection();

            if XGUIEng.IsModifierPressed(Keys.ModifierControl) then
                local knights = {}
                Logic.GetKnights(PlayerID, knights);
                for i=1,#knights do
                    GUI.SelectEntity(knights[i]);
                end
            else
                GUI.SelectEntity(Logic.GetKnightID(PlayerID));

                if ((Framework.GetTimeMs() - g_Selection.LastClickTime ) < g_Selection.MaxDoubleClickTime) then
                    local pos = GetPosition(KnightID);
                    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);
                else
                    Sound.FXPlay2DSound("ui\\mini_knight");
                end

                g_Selection.LastClickTime = Framework.GetTimeMs();
            end
            GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);
        else
            GUI.AddNote("Debug: You do not have a knight");
        end
    end
end

---
-- Überschreibt die Militärselektion, sodass der Spieler mit SHIFT zusätzlich
-- die Munitionswagen und Trebuchets selektieren kann.
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteSelectAllUnits()
    GUI_MultiSelection.SelectAllPlayerUnitsClicked = function()
        if XGUIEng.IsModifierPressed(Keys.ModifierShift) then
            BundleEntitySelection.Local:ExtendedLeaderSortOrder();
        else
            BundleEntitySelection.Local:NormalLeaderSortOrder();
        end

        Sound.FXPlay2DSound("ui\\menu_click");
        GUI.ClearSelection();

        local PlayerID = GUI.GetPlayerID()
        for i = 1, #LeaderSortOrder do
            local EntitiesOfThisType = GetPlayerEntities(PlayerID, LeaderSortOrder[i])
            for j = 1, #EntitiesOfThisType do
                GUI.SelectEntity(EntitiesOfThisType[j])
            end
        end

        local Knights = {}
        Logic.GetKnights(PlayerID, Knights)
        for k = 1, #Knights do
            GUI.SelectEntity(Knights[k])
        end
        GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);
    end
end

---
-- Erzeugt die normale Sortierung ohne Munitionswagen und Trebuchets.
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:NormalLeaderSortOrder()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1]  = Entities.U_MilitarySword;
    LeaderSortOrder[2]  = Entities.U_MilitaryBow;
    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;
    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;
    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;
    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;
    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;
    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;
    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;
    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;
    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;
    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;
    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;
    LeaderSortOrder[14] = Entities.U_MilitarySiegeTower;
    LeaderSortOrder[15] = Entities.U_MilitaryBatteringRam;
    LeaderSortOrder[16] = Entities.U_CatapultCart;
    LeaderSortOrder[17] = Entities.U_SiegeTowerCart;
    LeaderSortOrder[18] = Entities.U_BatteringRamCart;
    LeaderSortOrder[19] = Entities.U_Thief;

    -- Asien wird nur in der Erweiterung gebraucht.
    if g_GameExtraNo >= 1 then
        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);
        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);
        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);
        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);
    end
end

---
-- Erzeugt die erweiterte Selektion mit Munitionswagen und Trebuchets.
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:ExtendedLeaderSortOrder()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1]  = Entities.U_MilitarySword;
    LeaderSortOrder[2]  = Entities.U_MilitaryBow;
    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;
    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;
    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;
    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;
    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;
    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;
    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;
    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;
    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;
    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;
    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;
    LeaderSortOrder[14] = Entities.U_Trebuchet;
    LeaderSortOrder[15] = Entities.U_MilitarySiegeTower;
    LeaderSortOrder[16] = Entities.U_MilitaryBatteringRam;
    LeaderSortOrder[17] = Entities.U_CatapultCart;
    LeaderSortOrder[18] = Entities.U_SiegeTowerCart;
    LeaderSortOrder[19] = Entities.U_BatteringRamCart;
    LeaderSortOrder[20] = Entities.U_AmmunitionCart;
    LeaderSortOrder[21] = Entities.U_Thief;

    -- Asien wird nur in der Erweiterung gebraucht.
    if g_GameExtraNo >= 1 then
        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);
        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);
        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);
        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleEntitySelection");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleFollowKnight                                           # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet Funktionalität um Entities dauerhaft einem Helden
-- (bzw Ritter) folgen zu lassen.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleFollowKnight = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Lässt einen Siedler einem Helden folgen. Gibt die ID des Jobs
-- zurück, der die Verfolgung steuert.
--
-- <p><b>Hinweis:</b> Wenn eines der Entities zerstört wird, oder ins
-- Koma fällt, wird der Job beendet!</p>
--
-- <p><b>Alias:</b> AddFollowKnightSave</p>
--
-- @param              _Entity Entity das folgt (skriptname oder ID)
-- @param              _Knight Held (Skriptname oder ID)
-- @param[type=number] _Distance Entfernung, die uberschritten sein muss
-- @param[type=number] _Angle Ausrichtung
-- @return[type=number] Job-ID
-- @within Anwenderfunktionen
--
function API.FollowKnightSaveStart(_Entity, _Knight, _Distance, _Angle)
    if GUI then
        return;
    end
    return BundleFollowKnight.Global:AddFollowKnightSave(_Entity, _Knight, _Distance, _Angle);
end
AddFollowKnightSave = API.FollowKnightSaveStart;

---
-- Beendet einen Verfolgungsjob.
--
-- <p><b>Alias:</b> StopFollowKnightSave</p>
--
-- @param[type=number] _JobID Job-ID
-- @within Anwenderfunktionen
--
function API.FollowKnightSaveStop(_JobID)
    if GUI then
        return;
    end
    return BundleFollowKnight.Global:StopFollowKnightSave(_JobID)
end

StopFollowKnightSave = API.FollowKnightSaveStop;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleFollowKnight = {
    Global = {
        Data = {
            FollowKnightSave = {},
        }
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleFollowKnight.Global:Install()
end

-- -------------------------------------------------------------------------- --

---
-- Lässt einen Siedler einem Helden folgen. Gibt die ID des Jobs
-- zurück, der die Verfolgung steuert.
--
-- @param              _Entity Entity das folgt (skriptname oder ID)
-- @param              _Knight Held (Skriptname oder ID)
-- @param[type=number] _Distance Entfernung, die uberschritten sein muss
-- @param[type=number] _Angle Ausrichtung
-- @return[type=number] Job-ID
-- @within Internal
-- @local
--
function BundleFollowKnight.Global:AddFollowKnightSave(_Entity, _Knight, _Distance, _Angle)
    local EntityID = GetID(_Entity);
    local KnightID = GetID(_Knight);
    _Angle = _Angle or 0;

    info("BundleFollowKnight: Creating follow job for " ..EntityID.. " following " ..KnightID..".");
    local JobID = StartSimpleHiResJobEx(
        BundleFollowKnight.Global.ControlFollowKnightSave, EntityID, KnightID, _Distance, _Angle
    );
    table.insert(self.Data.FollowKnightSave, JobID);
    return JobID;
end

---
-- Beendet einen Verfolgungsjob.
--
-- @param[type=number] _JobID Job-ID
-- @within Internal
-- @local
--
function BundleFollowKnight.Global:StopFollowKnightSave(_JobID)
    for k,v in pairs(self.Data.FollowKnightSave) do
        if _JobID == v then
            info("BundleFollowKnight: Job " .._JobID.. " was stopped.");
            self.Data.FollowKnightSave[k] = nil;
            EndJob(_JobID);
        end
    end
end

---
-- Kontrolliert die Verfolgung eines Helden durch einen Siedler.
--
-- @param              _Entity Entity das folgt (skriptname oder ID)
-- @param              _Knight Held (Skriptname oder ID)
-- @param[type=number] _Distance Entfernung, die uberschritten sein muss
-- @param[type=number] _Angle Ausrichtung
-- @within Internal
-- @local
--
function BundleFollowKnight.Global.ControlFollowKnightSave(_EntityID, _KnightID, _Distance, _Angle)
    -- Entity oder Held sind hinüber bzw. haben ihre ID verändert
    if not IsExisting(_KnightID) or not IsExisting(_EntityID) then
        warn("BundleFollowKnight: Job finishes because hero or follower does not exist!");
        return true;
    end

    -- Wenn Entity ein Held ist, dann nur, wenn Entity nicht komatös ist
    if Logic.IsKnight(_EntityID) and Logic.KnightGetResurrectionProgress(_EntityID) ~= 1 then
        info("BundleFollowKnight: Job finishes because follower is comatose!");
        return false;
    end
    -- Wenn Knight ein Held ist, dann nur, wenn Knight nicht komatös ist
    if Logic.IsKnight(_KnightID) and Logic.KnightGetResurrectionProgress(_KnightID) ~= 1 then
        info("BundleFollowKnight: Job finishes because hero is comatose!");
        return false;
    end

    if  Logic.IsEntityMoving(_EntityID) == false and Logic.IsFighting(_EntityID) == false
    and IsNear(_EntityID, _KnightID, _Distance+300) == false then
        -- Relative Position hinter Held bestimmen
        local x, y, z = Logic.EntityGetPos(_KnightID);
        local orientation = Logic.GetEntityOrientation(_KnightID)-(180+_Angle);
        local xBehind = x + _Distance * math.cos(math.rad(orientation));
        local yBehind = y + _Distance * math.sin(math.rad(orientation));

        -- Relative Position blockingsicher machen
        local NoBlocking = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, xBehind, yBehind, 0, 0);
        local x, y, z = Logic.EntityGetPos(NoBlocking);
        DestroyEntity(NoBlocking);

        -- Zur neuen unblockierten Position bewegen
        Logic.MoveSettler(_EntityID, x, y);
    end
end
ControlFollowKnightSave = BundleFollowKnight.Global.ControlFollowKnightSave;

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleFollowKnight");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleInteractiveObjects                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Interaktive Objekte sind Gegenstände auf der Karte, mit denen interagiert
-- werden kann. Diese Interaktion geschieht über einen Button. Ziel dieses
-- Bundels ist es, die funktionalität von interaktiven Objekten zu erweitern.
-- Es ist möglich, beliebige Objekte zu interaktiven Objekten zu machen.
--
-- Die Einsatzmöglichkeiten sind vielfältig. Wenn ein Gegenstand oder ein
-- Objekt mit einer Funktion versehen ist, kann dies in verschiedenem Kontext
-- an die Geschichte angepasst werden: z.B. Helbel öffnen eine Geheimtür,
-- ein Gegenstand wird vom Helden aufgehoben, eine Tür wird geöffnet, ...
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleInteractiveObjects = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erzeugt ein interaktives Objekt.
--
-- Die Parameter des interaktiven Objektes werden durch seine Beschreibung
-- festgelegt. Die Beschreibung ist eine Table, die bestimmte Werte für das
-- Objekt beinhaltet. Dabei müssen nicht immer alle Werte angegeben werden.
--
-- Mögliche Angaben:
-- <table border="1">
-- <tr>
-- <td><b>Feldname</b></td>
-- <td><b>Beschreibung</b></td>
-- <td><b>Optional</b></td>
-- </tr>
-- <tr>
-- <td>Name</td>
-- <td>Der Skriptname des Entity, das zum interaktiven Objekt wird.</td>
-- <td>nein</td>
-- </tr>
-- <tr>
-- <td>Title</td>
-- <td>Der angezeigter Name im Beschreibungsfeld.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Text</td>
-- <td>Der Beschreibungstext, der im Tooltip angezeigt wird.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Texture</td>
-- <td>Bestimmt die Icongrafik, die angezeigt wird. Dabei kann es sich um
-- eine Ingame-Grafik oder eine eigene Grafik halten.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Distance</td>
-- <td>Die minimale Entfernung zum Objekt, die ein Held benötigt um das
-- objekt zu aktivieren.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Waittime</td>
-- <td>Die Zeit, die ein Held benötigt, um das Objekt zu aktivieren. Die
-- Wartezeit ist nur für I_X_ Entities verfügbar.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Costs</td>
-- <td>Eine Table mit dem Typ und der Menge der Kosten.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Reward</td>
-- <td>Der Warentyp und die Menge der gefundenen Waren im Objekt.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Callback</td>
-- <td>Eine Funktion, die ausgeführt wird, sobald das Objekt aktiviert wird.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>Condition</td>
-- <td>Eine Funktion, die vor der Aktivierung eine Beringung prüft.</td>
-- <td>ja</td>
-- </tr>
-- <tr>
-- <td>State</td>
-- <td>Bestimmt, wie sich der Button des interaktiven Objektes verhält.</td>
-- <td>ja</td>
-- </tr>
-- </table>
--
-- Zusätzlich können beliebige weitere Felder an das Objekt angehangen
-- werden. Sie sind ausnahmslos im Callback und in der Condition des Objektes
-- abrufbar.
--
-- <p><b>Alias:</b> CreateObject</p>
--
-- @param[type=table] _Description Beschreibung
-- @within Anwenderfunktionen
--
-- @usage
-- -- Ein einfaches Objekt erstellen:
-- CreateObject {
--     Name     = "hut",
--     Distance = 1500,
--     Callback = function(_Data)
--         API.Note("Do something...");
--     end,
-- }
--
function API.CreateObject(_Description)
    if GUI then
        return;
    end
    return BundleInteractiveObjects.Global:CreateObject(_Description);
end
CreateObject = API.CreateObject;

---
-- Aktiviert ein Interaktives Objekt, sodass es vom Spieler
-- aktiviert werden kann.
--
-- Der State bestimmt, ob es immer aktiviert werden kann, oder ob der Spieler
-- einen Helden benutzen muss. Wird der Parameter weggelassen, muss immer ein
-- Held das Objekt aktivieren.
--
-- <p><b>Alias</b>: InteractiveObjectActivate</p>
--
-- @param[type=string] _EntityName Skriptname des Objektes
-- @param[type=number] _State      State des Objektes
-- @within Anwenderfunktionen
--
function API.InteractiveObjectActivate(_ScriptName, _State)
    if not IO[_ScriptName] then
        API.ActivateIO(_ScriptName, _State);
        return;
    end
    local ScriptName = (IO[_ScriptName].m_Slave or _ScriptName);
    if IO[_ScriptName].m_Slave then
        IO_SlaveState[ScriptName] = 1;
    end
    API.ActivateIO(ScriptName, _State);
    IO[_ScriptName]:SetActive(true);
end
InteractiveObjectActivate = API.InteractiveObjectActivate;

---
-- Deaktiviert ein interaktives Objekt, sodass es nicht mehr vom Spieler
-- benutzt werden kann.
--
-- <p><b>Alias</b>: InteractiveObjectDeactivate</p>
--
-- @param[type=string] _EntityName Scriptname des Objektes
-- @within Anwenderfunktionen
--
function API.InteractiveObjectDeactivate(_ScriptName)
    if not IO[_ScriptName] then
        API.DeactivateIO(_ScriptName);
        return;
    end
    local ScriptName = (IO[_ScriptName].m_Slave or _ScriptName);
    if IO[_ScriptName].m_Slave then
        IO_SlaveState[ScriptName] = 0;
    end
    API.DeactivateIO(ScriptName);
    IO[_ScriptName]:SetActive(false);
end
InteractiveObjectDeactivate = API.InteractiveObjectDeactivate;

---
-- Erzeugt eine Beschriftung für Custom Objects.
--
-- Im Questfenster werden die Namen von Custom Objects als ungesetzt angezeigt.
-- Mit dieser Funktion kann ein Name angelegt werden.
--
-- <p><b>Alias:</b> AddCustomIOName</p>
--
-- @param[type=string] _Key  Typname des Entity
-- @param              _Text Text der Beschriftung
-- @within Anwenderfunktionen
--
-- @usage
-- API.InteractiveObjectSetName("D_X_ChestClosed", {de = "Schatztruhe", en = "Treasure");
-- API.InteractiveObjectSetName("D_X_ChestOpenEmpty", "Leere Schatztruhe");
--
function API.InteractiveObjectSetName(_Key, _Text)
    _Text = API.ConvertPlaceholders(API.Localize(_Text));
    if GUI then
        return;
    end
    IO_UserDefindedNames[_Key] = _Text;
end
AddCustomIOName = API.InteractiveObjectSetName;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleInteractiveObjects = {
    Global = {
        Data = {
            SlaveSequence = 0,
        }
    },
    Local = {
        Data = {},
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:Install()
    IO = {};
    IO_UserDefindedNames = {};
    IO_SlaveToMaster = {};
    IO_SlaveState = {};

    self:OverrideVanillaBehavior();
    self:HackOnInteractionEvent();
    self:StartObjectConditionController();

    API.StartEventJob(Events.LOGIC_EVENT_ENTITY_DESTROYED, function()
        BundleInteractiveObjects.Global:OnEntityDestroyed();
    end);
end

---
-- Erzeugt ein interaktives Objekt. Dabei können sowohl interaktive
-- Objekte (alle mit I_X_), eine Auswahl von normalen Entities und
-- sogar (sichtbare) XD_ScriptEntities verwendet werden.
--
-- @param[type=table] _Description Beschreibung
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:CreateObject(_Description)
    -- Objekt erstellen
    local ID = GetID(_Description.Name);
    if ID == 0 then
        return;
    end
    local Object = InteractiveObject:New(_Description.Name)
        :SetDistance(_Description.Distance)
        :SetWaittime(_Description.Waittime)
        :SetCaption(_Description.Title)
        :SetDescription(_Description.Text)
        :SetAction(_Description.Callback)
        :SetCondition(_Description.Condition)
        :SetState(_Description.State)
        :SetIcon(_Description.Texture)
        :SetData(_Description);
    
    -- Belohnung setzen
    if _Description.Reward then
        Object:SetReward(unpack(_Description.Reward))
    end
    -- Kosten setzen
    if _Description.Costs then
        Object:SetCosts(unpack(_Description.Costs))
    end
    
    -- Slave Objekt erstellen
    local TypeName = Logic.GetEntityTypeName(Logic.GetEntityType(ID));
    if not TypeName:find("I_X_") then
        self:CreateSlaveObject(Object);
    end
    -- Aktivieren
    IO[_Description.Name] = Object;
    self:SetupObject(IO[_Description.Name]);
    Logic.ExecuteInLuaLocalState("BundleInteractiveObjects.Local:UpdateReferenceTables()");
    return Object;
end

---
-- Erstellt einen Slave für das angegebene Objekt.
-- @param[type=table] _Object Model des IO
-- @return[type=number] ID des Slave
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:CreateSlaveObject(_Object)
    -- Generate new name
    self.Data.SlaveSequence = self.Data.SlaveSequence +1;
    local Name = "QSB_SlaveObject_" ..self.Data.SlaveSequence;
    -- Overwrite with existing slave
    for k, v in pairs(IO_SlaveToMaster) do
        if v == _Object.m_Name and IsExisting(k) then
            Name = k;
        end
    end
    -- Create slave object if not already existing
    local SlaveID = GetID(Name);
    if not IsExisting(Name) then
        local x,y,z = Logic.EntityGetPos(GetID(_Object.m_Name));
        SlaveID = Logic.CreateEntity(Entities.I_X_DragonBoatWreckage, x, y, 0, 0);
        Logic.SetModel(SlaveID, Models.Effects_E_Mosquitos);
        Logic.SetEntityName(SlaveID, Name);
        IO_SlaveToMaster[Name] = _Object.m_Name;
    end
    _Object:SetWaittime(0);
    _Object:SetSlave(Name);
    IO_SlaveState[Name] = 1;
    return SlaveID;
end

---
-- Initialisiert das interaktive Objekt. Es wird automatisch auf den Slave
-- zugegriffen, sofern vorhanden.
-- @param[type=table] _Object Model des IO
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:SetupObject(_Object)
    local ID = GetID((_Object.m_Slave and _Object.m_Slave) or _Object.m_Name);
    Logic.InteractiveObjectClearCosts(ID);
    Logic.InteractiveObjectClearRewards(ID);
    Logic.InteractiveObjectSetInteractionDistance(ID,_Object.m_Distance);
    Logic.InteractiveObjectSetTimeToOpen(ID,_Object.m_Waittime);
    Logic.InteractiveObjectSetRewardResourceCartType(ID, Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetRewardGoldCartType(ID, Entities.U_GoldCart);
    Logic.InteractiveObjectSetCostResourceCartType(ID, Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetCostGoldCartType(ID, Entities.U_GoldCart);
    if _Object.m_Reward then
        Logic.InteractiveObjectAddRewards(ID, _Object.m_Reward[1], _Object.m_Reward[2]);
    end
    if _Object.m_Costs and _Object.m_Costs[1] then
        Logic.InteractiveObjectAddCosts(ID, _Object.m_Costs[1], _Object.m_Costs[2]);
    end
    if _Object.m_Costs and _Object.m_Costs[3] then
        Logic.InteractiveObjectAddCosts(ID, _Object.m_Costs[3], _Object.m_Costs[4]);
    end
    table.insert(HiddenTreasures, ID);
    API.InteractiveObjectActivate(Logic.GetEntityName(ID), _Object.m_State or 0);
end

---
-- Überprüft die Bedingung aller nicht benutzten interaktiven Objekte.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:StartObjectConditionController()
    StartSimpleHiResJobEx(function()
        for k, v in pairs(IO) do
            if v and not v:IsUsed() and v:IsActive() then
                IO[k].m_Fullfilled = true;
                if IO[k].m_Condition then
                    IO[k].m_Fullfilled = v.m_Condition(v, QSB.HumanPlayerID, v.m_Data);
                end
            end
        end
    end);
end

---
-- Überschreibt Reward_ObjectInit, damit IO korrekt funktionieren.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:OverrideVanillaBehavior()
    if b_Reward_ObjectInit then
        b_Reward_ObjectInit.CustomFunction = function(_Behavior, _Quest)
            local eID = GetID(_Behavior.ScriptName);
            if eID == 0 then
                return;
            end
            QSB.InitalizedObjekts[eID] = _Quest.Identifier;
            
            local RewardTable = nil;
            if _Behavior.RewardType and _Behavior.RewardType ~= "-" then
                RewardTable = {Goods[_Behavior.RewardType], _Behavior.RewardAmount};
            end

            local CostsTable = nil;
            if _Behavior.FirstCostType and _Behavior.FirstCostType ~= "-" then
                CostsTable = {Goods[_Behavior.FirstCostType], _Behavior.FirstCostAmount};
                if _Behavior.SecondCostType and _Behavior.SecondCostType ~= "-" then
                    table.insert(CostsTable, Goods[_Behavior.SecondCostType]);
                    table.insert(CostsTable, _Behavior.SecondCostAmount);
                end
            end

            API.CreateObject{
                Name        = _Behavior.ScriptName,
                State       = _Behavior.UsingState or 0,
                Distance    = _Behavior.Distance,
                Waittime    = _Behavior.Waittime,
                Reward      = RewardTable,
                Costs       = CostsTable,
            };
        end
    end
end

---
-- Überschreibt die Events, die ausgelöst werden, wenn interaktive Objekte
-- benutzt werden.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:HackOnInteractionEvent()
    GameCallback_OnObjectInteraction = function(_EntityID, _PlayerID)
        OnInteractiveObjectOpened(_EntityID, _PlayerID);
        OnTreasureFound(_EntityID, _PlayerID);
        local ScriptName = Logic.GetEntityName(_EntityID);
        
        for k,v in pairs(IO)do
            if k == ScriptName or v.m_Slave == ScriptName then
                if not v.m_Used then
                    IO[k].m_Used = true;
                    if v.m_Action then
                        v.m_Action(v, _PlayerID, v.m_Data);
                    end
                end
            end
        end
    end

    QuestTemplate.AreObjectsActivated = function(self, _ObjectList)
        for i=1, _ObjectList[0] do
            if not _ObjectList[-i] then
                _ObjectList[-i] = GetEntityId(_ObjectList[i]);
            end
            local EntityName = Logic.GetEntityName(_ObjectList[-i]);
            if IO_SlaveToMaster[EntityName] then
                EntityName = IO_SlaveToMaster[EntityName];
            end

            if IO[EntityName] then
                if IO[EntityName].m_Used ~= true then
                    return false;
                end
            elseif Logic.IsInteractiveObject(_ObjectList[-i]) then
                if not IsInteractiveObjectOpen(_ObjectList[-i]) then
                    return false;
                end
            end
        end
        return true;
    end
end

---
-- Wenn der Slave eines Objektes zerstört wird, erstellt dieser Trigger sofort
-- einen neuen Slave und konfiguriert ihn.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:OnEntityDestroyed()
    local DestryoedEntityID = Event.GetEntityID();
    local SlaveName  = Logic.GetEntityName(DestryoedEntityID);
    local MasterName = IO_SlaveToMaster[SlaveName];
    if SlaveName and MasterName then
        local Object = IO[MasterName];
        if not Object then
            return;
        end
        info("slave " ..SlaveName.. " of master " ..MasterName.. " has been deleted!");
        info("try to create new slave...");
        IO_SlaveToMaster[SlaveName] = nil;
        local SlaveID = self:CreateSlaveObject(Object);
        if not IsExisting(SlaveID) then
            error("failed to create slave!");
            return;
        end
        BundleInteractiveObjects.Global:SetupObject(Object);
        if Object.m_Used == true or (IO_SlaveState[SlaveName] and IO_SlaveState[SlaveName] == 0) then
            API.InteractiveObjectDeactivate(Object.m_Slave);
        end
        info("new slave created for master " ..MasterName.. ".");
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:Install()
    self:UpdateReferenceTables();
    self:ActivateInteractiveObjectControl();
end

---
-- Aktualisiert die Referenztabellen zum globalen Skript.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:UpdateReferenceTables()
    IO = Logic.CreateReferenceToTableInGlobaLuaState("IO");
    IO_UserDefindedNames = Logic.CreateReferenceToTableInGlobaLuaState("IO_UserDefindedNames");
    IO_SlaveToMaster = Logic.CreateReferenceToTableInGlobaLuaState("IO_SlaveToMaster");
end

---
-- Überschreibt die Spielfunktione, die interaktive Objekte steuern.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:ActivateInteractiveObjectControl()
    GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects = GUI_Interaction.InteractiveObjectClicked
    GUI_Interaction.InteractiveObjectClicked = function()
        local i = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local EntityID = g_Interaction.ActiveObjectsOnScreen[i];
        if not EntityID then
            return;
        end
        local ScriptName = Logic.GetEntityName(EntityID);
        if IO_SlaveToMaster[ScriptName] then
            ScriptName = IO_SlaveToMaster[ScriptName];
        end
        if not IO[ScriptName] then
            GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects();
            return;
        end
        if not IO[ScriptName].m_Fullfilled then
            Message(XGUIEng.GetStringTableText("UI_ButtonDisabled/PromoteKnight"));
            return;
        end

        if type(IO[ScriptName].m_Costs) == "table" and #IO[ScriptName].m_Costs ~= 0 then
            local PlayerID    = GUI.GetPlayerID();
            local CathedralID = Logic.GetCathedral(PlayerID);
            local CastleID    = Logic.GetHeadquarters(PlayerID);
            if CathedralID == nil or CathedralID == 0 or CastleID == nil or CastleID == 0 then
                API.Note("DEBUG: Player does not have special buildings!");
                return;
            end
        end

        GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects();
    end

    GUI_Interaction.InteractiveObjectUpdate = function()
        if g_Interaction.ActiveObjects == nil then
            return;
        end
        local PlayerID = GUI.GetPlayerID();
        for i = 1, #g_Interaction.ActiveObjects do
            local ObjectID = g_Interaction.ActiveObjects[i];
            local MasterObjectID = ObjectID;
            local ScriptName     = Logic.GetEntityName(ObjectID);
            if IO_SlaveToMaster[ScriptName] then
                MasterObjectID = GetID(IO_SlaveToMaster[ScriptName]);
            end
            local X, Y = GUI.GetEntityInfoScreenPosition(MasterObjectID);
            local ScreenSizeX, ScreenSizeY = GUI.GetScreenSize();

            if X ~= 0 and Y ~= 0 and X > -50 and Y > -50 and X < (ScreenSizeX + 50) and Y < (ScreenSizeY + 50) then
                local IsInTable = false;
                for i = 1, #g_Interaction.ActiveObjectsOnScreen do
                    if g_Interaction.ActiveObjectsOnScreen[i] == ObjectID then
                        IsInTable = true;
                    end
                end
                if IsInTable == false then
                    table.insert(g_Interaction.ActiveObjectsOnScreen, ObjectID);
                end
            else
                for i = 1, #g_Interaction.ActiveObjectsOnScreen do
                    if g_Interaction.ActiveObjectsOnScreen[i] == ObjectID then
                        table.remove(g_Interaction.ActiveObjectsOnScreen, i);
                    end
                end
            end
        end
        for i = 1, #g_Interaction.ActiveObjectsOnScreen do
            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i
            if XGUIEng.IsWidgetExisting(Widget) == 1 then
                local ObjectID = g_Interaction.ActiveObjectsOnScreen[i];
                local MasterObjectID = ObjectID;
                local ScriptName     = Logic.GetEntityName(ObjectID);
                if IO_SlaveToMaster[ScriptName] then
                    MasterObjectID = GetID(IO_SlaveToMaster[ScriptName]);
                end
                local EntityType = Logic.GetEntityType(ObjectID);
                local X, Y = GUI.GetEntityInfoScreenPosition(MasterObjectID);
                local WidgetSize = {XGUIEng.GetWidgetScreenSize(Widget)};
                XGUIEng.SetWidgetScreenPosition(Widget, X - (WidgetSize[1]/2), Y - (WidgetSize[2]/2));
                local BaseCosts = {Logic.InteractiveObjectGetCosts(ObjectID)};
                local EffectiveCosts = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};
                local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);
                local Disable = false;
                if BaseCosts[1] ~= nil and EffectiveCosts[1] == nil and IsAvailable == true then
                    Disable = true;
                end
                local HasSpace = Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID);
                if HasSpace == false then
                    Disable = true;
                end
                if Disable == true then
                    XGUIEng.DisableButton(Widget, 1);
                else
                    XGUIEng.DisableButton(Widget, 0);
                end
                if GUI_Interaction.InteractiveObjectUpdateEx1 ~= nil then
                    GUI_Interaction.InteractiveObjectUpdateEx1(Widget, EntityType);
                end
                XGUIEng.ShowWidget(Widget, 1);
            end
        end
        for i = #g_Interaction.ActiveObjectsOnScreen + 1, 2 do
            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i;
            XGUIEng.ShowWidget(Widget, 0);
        end
        for i = 1, #g_Interaction.ActiveObjectsOnScreen do
            local Widget = "/InGame/Root/Normal/InteractiveObjects/" ..i;
            if XGUIEng.IsWidgetExisting(Widget) == 1 then
                local ObjectID       = g_Interaction.ActiveObjectsOnScreen[i];
                local ScriptName     = Logic.GetEntityName(ObjectID);
                if IO_SlaveToMaster[ScriptName] then
                    ScriptName = IO_SlaveToMaster[ScriptName];
                end
                local X, Y = GUI.GetEntityInfoScreenPosition(ObjectID);
                local WidgetSize = {XGUIEng.GetWidgetScreenSize(Widget)};
                XGUIEng.SetWidgetScreenPosition(Widget, X - (WidgetSize[1]/2), Y - (WidgetSize[2]/2));
                if IO[ScriptName] then
                    BundleInteractiveObjects.Local:SetIcon(Widget, IO[ScriptName].m_Icon);
                end
            end
        end
    end

    GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects = GUI_Interaction.InteractiveObjectMouseOver;
    GUI_Interaction.InteractiveObjectMouseOver = function()
        local PlayerID = GUI.GetPlayerID();
        local ButtonNumber = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local ObjectID = g_Interaction.ActiveObjectsOnScreen[ButtonNumber];
        if ObjectID == nil then
            return;
        end
        local EntityType = Logic.GetEntityType(ObjectID);

        if g_GameExtraNo > 0 then
            local EntityTypeName = Logic.GetEntityTypeName(EntityType);
            if Inside (EntityTypeName, {"R_StoneMine", "R_IronMine", "B_Cistern", "B_Well", "I_X_TradePostConstructionSite"}) then
                GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects();
                return;
            end
        end
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        if string.find(EntityTypeName, "^I_X_") and tonumber(Logic.GetEntityName(ObjectID)) ~= nil then
            GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects();
            return;
        end

        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local Costs = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};
        local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);

        local ScriptName = Logic.GetEntityName(ObjectID);
        if IO_SlaveToMaster[ScriptName] then
            ScriptName = IO_SlaveToMaster[ScriptName];
        end

        local CheckSettlement;
        if IO[ScriptName] and IO[ScriptName].m_Used ~= true then
            local Title = IO[ScriptName].m_Caption or XGUIEng.GetStringTableText("UI_ObjectNames/InteractiveObjectAvailable");
            local Text  = IO[ScriptName].m_Description or XGUIEng.GetStringTableText("UI_ObjectDescription/InteractiveObjectAvailable");
            Costs = IO[ScriptName].m_Costs;
            if Costs and Costs[1] and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then
                CheckSettlement = true;
            end
            BundleInteractiveObjects.Local:TextCosts(Title, Text, nil, {Costs[1], Costs[2], Costs[3], Costs[4]}, CheckSettlement);
            return;
        end
    end

    GUI_Interaction.DisplayQuestObjective_Orig_BundleInteractiveObjects = GUI_Interaction.DisplayQuestObjective;
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local QuestIndexTemp = tonumber(_QuestIndex);
        if QuestIndexTemp then
            _QuestIndex = QuestIndexTemp;
        end

        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
        local QuestObjectiveContainer;
        local QuestTypeCaption;

        local ParentQuest = Quests[_QuestIndex];
        local ParentQuestIdentifier;
        if ParentQuest ~= nil
        and type(ParentQuest) == "table" then
            ParentQuestIdentifier = ParentQuest.Identifier;
        end
        local HookTable = {};

        g_CurrentDisplayedQuestID = _QuestIndex;

        if QuestType == Objective.Object then
            QuestObjectiveContainer = QuestObjectivesPath .. "/List";
            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction");
            local ObjectList = {};

            for i = 1, Quest.Objectives[1].Data[0] do
                local ObjectType;
                if Logic.IsEntityDestroyed(Quest.Objectives[1].Data[i]) then
                    ObjectType = g_Interaction.SavedQuestEntityTypes[_QuestIndex][i];
                else
                    ObjectType = Logic.GetEntityType(GetEntityId(Quest.Objectives[1].Data[i]));
                end
                local ObjectEntityName = Logic.GetEntityName(Quest.Objectives[1].Data[i]);
                local ObjectName = "";
                if ObjectType ~= nil and ObjectType ~= 0 then
                    local ObjectTypeName = Logic.GetEntityTypeName(ObjectType)
                    ObjectName = Wrapped_GetStringTableText(_QuestIndex, "Names/" .. ObjectTypeName);
                    if ObjectName == "" then
                        ObjectName = Wrapped_GetStringTableText(_QuestIndex, "UI_ObjectNames/" .. ObjectTypeName);
                    end
                    if ObjectName == "" then
                        ObjectName = IO_UserDefindedNames[ObjectTypeName];
                    end
                    if ObjectName == nil then
                        ObjectName = IO_UserDefindedNames[ObjectEntityName];
                    end
                    if ObjectName == nil then
                        ObjectName = "Debug: ObjectName missing for " .. ObjectTypeName;
                    end
                end
                table.insert(ObjectList, ObjectName);
            end
            for i = 1, 4 do
                local String = ObjectList[i];
                if String == nil then
                    String = "";
                end
                XGUIEng.SetText(QuestObjectiveContainer .. "/Entry" .. i, "{center}" .. String);
            end

            SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{14, 10});
            XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);
            XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
        else
            GUI_Interaction.DisplayQuestObjective_Orig_BundleInteractiveObjects(_QuestIndex, _MessageKey);
        end
    end
end

---
-- Setzt den Kostentooltip des aktuellen Widgets.
--
-- @param[type=string]  _Title Titel des Tooltip
-- @param[type=string]  _Text Text des Tooltip
-- @param[type=string]  _DisabledText (optional) Textzusatz wenn inaktiv
-- @param[type=table]   _Costs Kostentabelle
-- @param[type=boolean] _InSettlement Kosten in Siedlung suchen
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:TextCosts(_Title, _Text, _DisabledText, _Costs, _InSettlement)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")
    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")
    local PositionWidget = XGUIEng.GetCurrentWidgetID()
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)
    GUI_Tooltip.SetCosts(TooltipCostsContainer, _Costs, _InSettlement)
    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)
    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)

    _DisabledText = _DisabledText or "";
    local disabled = ""
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title)
    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled)
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)
end

---
-- Ändert die Textur eines Icons des aktuellen Widget.
-- TODO: Eigene Matrizen funktionieren nicht - Grund unbekannt.
--
-- @param[type=string] _Widget Icon Widget
-- @param              _Icon Icon Textur (Dateiname oder Positionsmatrix)
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:SetIcon(_Widget, _Icon)
    if type(_Icon) == "table" then
        if type(_Icon[3]) == "string" then
            local ButtonState = 1;
            if XGUIEng.IsButton(_Widget) == 1 then
                ButtonState = 7;
            end

            local u0, u1, v0, v1;
            u0 = (_Icon[1] - 1) * 64;
            v0 = (_Icon[2] - 1) * 64;
            u1 = (_Icon[1]) * 64;
            v1 = (_Icon[2]) * 64;
            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);
            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");
            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);
        else
            SetIcon(_Widget, _Icon);
        end
    else
        local screenSize = {GUI.GetScreenSize()};
        local Scale = 330;
        if screenSize[2] >= 800 then
            Scale = 260;
        end
        if screenSize[2] >= 1000 then
            Scale = 210;
        end
        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);
        XGUIEng.SetMaterialTexture(_Widget, 1, _Icon);
        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);
    end
end

-- -------------------------------------------------------------------------- --

InteractiveObject = {
    m_Name        = nil,
    m_State       = 0,
    m_Distance    = 1000,
    m_Waittime    = 5,
    m_Used        = false,
    m_Fullfilled  = false,
    m_Active      = true,
    m_Slave       = nil,
    m_Caption     = nil,
    m_Description = nil,
    m_Condition   = nil,
    m_Action      = nil,
    m_Icon        = {14, 10},
    m_Costs       = {},
    m_Reward      = {},
};

function InteractiveObject:New(_Name)
    local Object = API.InstanceTable(self);
    Object.m_Name = _Name;
    return Object;
end

function InteractiveObject:SetDistance(_Distance)
    self.m_Distance = _Distance or 1000;
    return self;
end

function InteractiveObject:SetWaittime(_Time)
    self.m_Waittime = _Time or 5;
    return self;
end

function InteractiveObject:SetState(_State)
    self.m_State = _State or 0;
    return self;
end

function InteractiveObject:SetCaption(_Text)
    if _Text then
        self.m_Caption = API.ConvertPlaceholders(API.Localize(_Text));
    end
    return self;
end

function InteractiveObject:SetDescription(_Text)
    if _Text then
        self.m_Description = API.ConvertPlaceholders(API.Localize(_Text));
    end
    return self;
end

function InteractiveObject:SetCosts(...)
    self.m_Costs = {unpack(arg)};
    return self;
end

function InteractiveObject:SetReward(...)
    self.m_Reward = {unpack(arg)};
    return self;
end

function InteractiveObject:SetCondition(_Function)
    self.m_Condition = _Function;
    return self;
end

function InteractiveObject:SetAction(_Function)
    self.m_Action = _Function;
    return self;
end

function InteractiveObject:SetIcon(_Icon)
    self.m_Icon = _Icon;
    return self;
end

function InteractiveObject:SetData(_Data)
    self.m_Data = _Data;
    return self;
end

function InteractiveObject:SetSlave(_ScriptName)
    self.m_Slave = _ScriptName;
    return self;
end

function InteractiveObject:SetActive(_Flag)
    self.m_Active = _Flag == true;
    return self;
end

function InteractiveObject:IsActive()
    return self.m_Active == true;
end

function InteractiveObject:SetUsed(_Flag)
    self.m_Used = _Flag == true;
    return self;
end

function InteractiveObject:IsUsed()
    return self.m_Used == true;
end

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss bis zu 4 interaktive Objekte benutzen.
--
-- @param[type=string] _ScriptName1 Erstes Objekt
-- @param[type=string] _ScriptName2 (optional) Zweites Objekt
-- @param[type=string] _ScriptName3 (optional) Drittes Objekt
-- @param[type=string] _ScriptName4 (optional) Viertes Objekt
--
-- @within Goal
--
function Goal_ActivateSeveralObjects(...)
    return b_Goal_ActivateSeveralObjects:new(...);
end

b_Goal_ActivateSeveralObjects = {
    Name = "Goal_ActivateSeveralObjects",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
    },
    Parameter = {
        { ParameterType.Default, en = "Object name 1", de = "Skriptname 1" },
        { ParameterType.Default, en = "Object name 2", de = "Skriptname 2" },
        { ParameterType.Default, en = "Object name 3", de = "Skriptname 3" },
        { ParameterType.Default, en = "Object name 4", de = "Skriptname 4" },
    },
    ScriptNames = {};
}

function b_Goal_ActivateSeveralObjects:GetGoalTable()
    return {Objective.Object, { unpack(self.ScriptNames) } }
end

function b_Goal_ActivateSeveralObjects:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        assert(_Parameter ~= nil and _Parameter ~= "", "Goal_ActivateSeveralObjects: At least one IO needed!");
    end
    if _Parameter ~= nil and _Parameter ~= "" then
        table.insert(self.ScriptNames, _Parameter);
    end
end

function b_Goal_ActivateSeveralObjects:GetMsgKey()
    return "Quest_Object_Activate"
end

Core:RegisterBehavior(b_Goal_ActivateSeveralObjects);

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleInteractiveObjects");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleInterfaceApperance                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet dem Nutzer Funktionen zur Manipulation der Oberfläche
-- des Spiels. Der Mapper hat die Möglichkeit, eigene Texte und Grafiken im
-- Interface anzuzeigen.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleInterfaceApperance = {};

API = API or {};
QSB = QSB or {};

QSB.PlayerNames = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Setzt einen Icon aus einer benutzerdefinierten Icon Matrix.
--
-- Es wird also die Grafik eines Button oder Icon mit einer neuen Grafik
-- ausgetauscht.
--
-- Dabei müssen die Quellen nach gui_768, gui_920 und gui_1080 in der
-- entsprechenden Größe gepackt werden. Die Ordner liegen in graphics/textures.
-- Jede Map muss einen eigenen eindeutigen Namen für jede Grafik verwenden.
--
-- <u>Größen:</u>
-- Die Gesamtgröße ergibt sich aus der Anzahl der Buttons und der Pixelbreite
-- für die jeweilige Grö0e. z.B. 64 Buttons -> Größe * 8 x Größe * 8
-- <ul>
-- <li>768: 41x41</li>
-- <li>960: 52x52</li>
-- <li>1200: 64x64</li>
-- </ul>
--
-- <u>Namenskonvention:</u>
-- Die Namenskonvention wird durch das Spiel vorgegeben. Je nach Größe sind
-- die Namen der Matrizen erweitert mit .png, big.png und verybig.png. Du
-- gibst also niemals die Dateiendung mit an!
-- <ul>
-- <li>Für normale Icons: _Name .. .png</li>
-- <li>Für große Icons: _Name .. big.png</li>
-- <li>Für riesige Icons: _Name .. verybig.png</li>
-- </ul>
--
-- @param[type=string] _WidgetID Widgetpfad oder ID
-- @param[type=table]  _Coordinates Koordinaten
-- @param[type=number] _Size Größe des Icon
-- @param[type=string] _Name Name der Icon Matrix
-- @within Anwenderfunktionen
--
function API.InterfaceSetIcon(_WidgetID, _Coordinates, _Size, _Name)
    if not GUI then
        return;
    end
    BundleInterfaceApperance.Local:SetIcon(_WidgetID, _Coordinates, _Size, _Name)
end
UserSetIcon = API.InterfaceSetIcon;

---
-- Ändert den Beschreibungstext eines Button oder eines Icon.
--
-- Wichtig ist zu beachten, dass diese Funktion in der Update-Funktion des
-- Button oder Icon ausgeführt werden muss.
--
-- Die Funktion kann auch mit deutsch/english lokalisierten Tabellen als
-- Text gefüttert werden. In diesem Fall wird der deutsche Text genommen,
-- wenn es sich um eine deutsche Spielversion handelt. Andernfalls wird
-- immer der englische Text verwendet.
--
-- <p><b>Alias:</b> UserSetTextNormal</p>
--
-- @param[type=string] _title        Titel des Tooltip
-- @param[type=string] _text         Text des Tooltip
-- @param[type=string] _disabledText Textzusatz wenn inaktiv
-- @within Anwenderfunktionen
--
function API.InterfaceSetTooltipNormal(_title, _text, _disabledText)
    if not GUI then
        return;
    end
    BundleInterfaceApperance.Local:TextNormal(_title, _text, _disabledText);
end
UserSetTextNormal = API.InterfaceSetTooltipNormal;

---
-- Ändert den Beschreibungstext und die Kosten eines Button.
--
-- Wichtig ist zu beachten, dass diese Funktion in der Update-Funktion des
-- Button oder Icon ausgeführt werden muss.
--
-- <p><b>Alias:</b> UserSetTextBuy</p>
--
-- @see API.InterfaceSetTooltipNormal
--
-- @param[type=string]  _title        Titel des Tooltip
-- @param[type=string]  _text         Text des Tooltip
-- @param[type=string]  _disabledText Textzusatz wenn inaktiv
-- @param[type=table]   _costs        Kostentabelle
-- @param[type=boolean] _inSettlement Kosten in Siedlung suchen
-- @within Anwenderfunktionen
--
function API.InterfaceSetTooltipCosts(_title,_text,_disabledText,_costs,_inSettlement)
    if not GUI then
        return;
    end
    BundleInterfaceApperance.Local:TextCosts(_title,_text,_disabledText,_costs,_inSettlement);
end
UserSetTextBuy = API.InterfaceSetTooltipCosts;

---
-- Gibt den Namen des Territoriums zurück.
--
-- <p><b>Alias:</b> GetTerritoryName</p>
--
-- @param[type=number] _TerritoryID ID des Territoriums
-- @return[type=string]  Name des Territorium
-- @within Anwenderfunktionen
--
function API.InterfaceGetTerritoryName(_TerritoryID)
    local Name = Logic.GetTerritoryName(_TerritoryID);
    local MapType = Framework.GetCurrentMapTypeAndCampaignName();
    if MapType == 1 or MapType == 3 then
        return Name;
    end

    local MapName = Framework.GetCurrentMapName();
    local StringTable = "Map_" .. MapName;
    local TerritoryName = string.gsub(Name, " ","");
    TerritoryName = XGUIEng.GetStringTableText(StringTable .. "/Territory_" .. TerritoryName);
    if TerritoryName == "" then
        TerritoryName = Name .. "(key?)";
    end
    return TerritoryName;
end
GetTerritoryName = API.InterfaceGetTerritoryName;

---
-- Gibt den Namen des Spielers zurück.
--
-- <p><b>Alias:</b> GetPlayerName</p>
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=string]  Name des Spielers
-- @within Anwenderfunktionen
--
function API.InterfaceGetPlayerName(_PlayerID)
    local PlayerName = Logic.GetPlayerName(_PlayerID);
    local name = QSB.PlayerNames[_PlayerID];
    if name ~= nil and name ~= "" then
        PlayerName = name;
    end

    local MapType = Framework.GetCurrentMapTypeAndCampaignName();
    local MutliplayerMode = Framework.GetMultiplayerMapMode(Framework.GetCurrentMapName(), MapType);

    if MutliplayerMode > 0 then
        return PlayerName;
    end
    if MapType == 1 or MapType == 3 then
        local PlayerNameTmp, PlayerHeadTmp, PlayerAITmp = Framework.GetPlayerInfo(_PlayerID);
        if PlayerName ~= "" then
            return PlayerName;
        end
        return PlayerNameTmp;
    end
end
GetPlayerName_OrigName = GetPlayerName;
GetPlayerName = API.InterfaceGetPlayerName;

---
-- Gibt dem Spieler einen neuen Namen.
--
-- <p><b>Alias:</b> SetPlayerName</p>
--
-- @param[type=number] _playerID ID des Spielers
-- @param[type=string] _name Name des Spielers
-- @within Anwenderfunktionen
--
function API.InterfaceSetPlayerName(_playerID,_name)
    assert(type(_playerID) == "number");
    assert(type(_name) == "string");
    if not GUI then
        Logic.ExecuteInLuaLocalState("SetPlayerName(".._playerID..",'".._name.."')");
    else
        GUI_MissionStatistic.PlayerNames[_playerID] = _name;
        GUI.SendScriptCommand("QSB.PlayerNames[".._playerID.."] = '".._name.."'");
    end
    QSB.PlayerNames[_playerID] = _name;
end
SetPlayerName = API.InterfaceSetPlayerName;

---
-- Setzt eine andere Spielerfarbe.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Color Spielerfarbe
-- @param[type=number] _Logo Logo (optional)
-- @param[type=number] _Pattern Pattern (optional)
-- @within Anwenderfunktionen
--
function API.InterfaceSetPlayerColor(_PlayerID, _Color, _Logo, _Pattern)
    if GUI then
        return;
    end
    g_ColorIndex["ExtraColor1"] = 16;
    g_ColorIndex["ExtraColor2"] = 17;

    local Type    = type(_Color);
    local Col     = (type(_Color) == "string" and g_ColorIndex[_Color]) or _Color;
    local Logo    = _Logo or -1;
    local Pattern = _Pattern or -1;

    Logic.PlayerSetPlayerColor(_PlayerID, Col, _Logo, _Pattern);
    Logic.ExecuteInLuaLocalState([[
        Display.UpdatePlayerColors()
        GUI.RebuildMinimapTerrain()
        GUI.RebuildMinimapTerritory()
    ]]);
end

---
-- Setzt das Portrait eines Spielers.
--
-- Dabei gibt es 3 verschiedene Varianten:
-- <ul>
-- <li>Wenn _Portrait nicht gesetzt wird, wird das Portrait des Primary
-- Knight genommen.</li>
-- <li>Wenn _Portrait ein existierendes Entity ist, wird anhand des Typs
-- das Portrait bestimmt.</li>
-- <li>Wenn _Portrait der Modellname eines Portrait ist, wird der Wert
-- als Portrait gesetzt.</li>
-- </ul>
--
-- Wenn kein Portrait bestimmt werden kann, wird H_NPC_Generic_Trader verwendet.
--
-- <b>Trivia</b>: Diese Funktionalität wird Umgangssprachlich als "Köpfe
-- tauschen" oder "Köpfe wechseln" bezeichnet.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=string] _Portrait Name des Models
-- @within Anwenderfunktionen
--
-- @usage -- Kopf des Primary Knight
-- API.InterfaceSetPlayerPortrait(2);
-- -- Kopf durch Entity bestimmen
-- API.InterfaceSetPlayerPortrait(2, "amma");
-- -- Kopf durch Modelname setzen
-- API.InterfaceSetPlayerPortrait(2, "H_NPC_Monk_AS");
--
function API.InterfaceSetPlayerPortrait(_PlayerID, _Portrait)
    if not _PlayerID or type(_PlayerID) ~= "number" or (_PlayerID < 1 or _PlayerID > 8) then
        error("API.InterfaceSetPlayerPortrait: Invalid player ID!");
        return;
    end
    if not GUI then
        local Portrait = (_Portrait ~= nil and "'" .._Portrait.. "'") or "nil";
        Logic.ExecuteInLuaLocalState("API.InterfaceSetPlayerPortrait(" .._PlayerID.. ", " ..Portrait.. ")")
        return;
    end
    
    if _Portrait == nil then
        BundleInterfaceApperance.Local:SetPlayerPortraitByPrimaryKnight(_PlayerID);
        return;
    end
    if _Portrait ~= nil and IsExisting(_Portrait) then
        BundleInterfaceApperance.Local:SetPlayerPortraitBySettler(_PlayerID, _Portrait);
        return;
    end
    BundleInterfaceApperance.Local:SetPlayerPortraitByModelName(_PlayerID, _Portrait);
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleInterfaceApperance = {
    Global = {},
    Local = {}
};

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:Install()
    StartMissionGoodOrEntityCounter = function(_Icon, _AmountToReach)
        if type(_Icon[3]) == "string" then
            BundleInterfaceApperance.Local:SetIcon("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon, 64, _Icon[3]);
        else
            SetIcon("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon);
        end

        g_MissionGoodOrEntityCounterAmountToReach = _AmountToReach;
        g_MissionGoodOrEntityCounterIcon = _Icon;

        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 1);
    end
end

---
-- Setzt das Portrait des Spielers anhand des Primary Knight.
-- @param[type=number] _PlayerID ID des Spielers
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:SetPlayerPortraitByPrimaryKnight(_PlayerID)
    local KnightID = Logic.GetKnightID(_PlayerID);
    if KnightID == 0 then
        return;
    end
    local KnightType = Logic.GetEntityType(KnightID);
    local KnightTypeName = Logic.GetEntityTypeName(KnightType);
    local HeadModelName = "H" .. string.sub(KnightTypeName, 2, 8) .. "_" .. string.sub(KnightTypeName, 9);

    if not Models["Heads_" .. HeadModelName] then
        HeadModelName = "H_NPC_Generic_Trader";
    end
    g_PlayerPortrait[_PlayerID] = HeadModelName;
end

---
-- Setzt das Portrait des Spielers anhand der übergebenen Script Entity.
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=string] _Portrait Skriptname des Entity
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:SetPlayerPortraitBySettler(_PlayerID, _Portrait)
    local PortraitMap = {
        ["U_KnightChivalry"]           = "H_Knight_Chivalry",
        ["U_KnightHealing"]            = "H_Knight_Healing",
        ["U_KnightPlunder"]            = "H_Knight_Plunder",
        ["U_KnightRedPrince"]          = "H_Knight_RedPrince",
        ["U_KnightSabatta"]            = "H_Knight_Sabatt",
        ["U_KnightSong"]               = "H_Knight_Song",
        ["U_KnightTrading"]            = "H_Knight_Trading",
        ["U_KnightWisdom"]             = "H_Knight_Wisdom",
        ["U_NPC_Amma_NE"]              = "H_NPC_Amma",
        ["U_NPC_Castellan_ME"]         = "H_NPC_Castellan_ME",
        ["U_NPC_Castellan_NA"]         = "H_NPC_Castellan_NA",
        ["U_NPC_Castellan_NE"]         = "H_NPC_Castellan_NE",
        ["U_NPC_Castellan_SE"]         = "H_NPC_Castellan_SE",
        ["U_MilitaryBandit_Ranged_ME"] = "H_NPC_Mercenary_ME",
        ["U_MilitaryBandit_Melee_NA"]  = "H_NPC_Mercenary_NA",
        ["U_MilitaryBandit_Melee_NE"]  = "H_NPC_Mercenary_NE",
        ["U_MilitaryBandit_Melee_SE"]  = "H_NPC_Mercenary_SE",
        ["U_NPC_Monk_ME"]              = "H_NPC_Monk_ME",
        ["U_NPC_Monk_NA"]              = "H_NPC_Monk_NA",
        ["U_NPC_Monk_NE"]              = "H_NPC_Monk_NE",
        ["U_NPC_Monk_SE"]              = "H_NPC_Monk_SE",
        ["U_NPC_Villager01_ME"]        = "H_NPC_Villager01_ME",
        ["U_NPC_Villager01_NA"]        = "H_NPC_Villager01_NA",
        ["U_NPC_Villager01_NE"]        = "H_NPC_Villager01_NE",
        ["U_NPC_Villager01_SE"]        = "H_NPC_Villager01_SE",
    }

    if g_GameExtraNo > 0 then
        PortraitMap["U_KnightPraphat"]           = "H_Knight_Praphat";
        PortraitMap["U_KnightSaraya"]            = "H_Knight_Saraya";
        PortraitMap["U_KnightKhana"]             = "H_Knight_Khana";
        PortraitMap["U_MilitaryBandit_Melee_AS"] = "H_NPC_Mercenary_AS";
        PortraitMap["U_NPC_Castellan_AS"]        = "H_NPC_Castellan_AS";
        PortraitMap["U_NPC_Villager_AS"]         = "H_NPC_Villager_AS";
        PortraitMap["U_NPC_Monk_AS"]             = "H_NPC_Monk_AS";
        PortraitMap["U_NPC_Monk_Khana"]          = "H_NPC_Monk_Khana";
    end

    local HeadModelName = "H_NPC_Generic_Trader";
    local EntityID = GetID(_Portrait);
    if EntityID ~= 0 then
        local EntityType = Logic.GetEntityType(EntityID);
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        HeadModelName = PortraitMap[EntityTypeName] or "H_NPC_Generic_Trader";
        if not HeadModelName then
            HeadModelName = "H_NPC_Generic_Trader";
        end
    end
    g_PlayerPortrait[_PlayerID] = HeadModelName;
end

---
-- Setzt das Portrait des Spielers anhand des angegebenen Models.
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=string] _Portrait Name des Models
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:SetPlayerPortraitByModelName(_PlayerID, _Portrait)
    if not Models["Heads_" .. tostring(_Portrait)] then
        _Portrait = "H_NPC_Generic_Trader";
    end
    g_PlayerPortrait[_PlayerID] = _Portrait;
end

---
-- Setzt einen Icon aus einer benutzerdefinierten Matrix.
--
-- @param[type=string] _WidgetID Widgetpfad oder ID
-- @param[type=table]  _Coordinates Koordinaten
-- @param[type=number] _Size Größe des Icon
-- @param[type=string] _Name Name der Icon Matrix
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:SetIcon(_WidgetID, _Coordinates, _Size, _Name)
    if _Name == nil then
        _Name = "usericons";
    end
    if _Size == nil then
        _Size = 64;
    end

    if _Size == 44 then
        _Name = _Name .. ".png"
    end
    if _Size == 64 then
        _Name = _Name .. "big.png"
    end
    if _Size == 128 then
        _Name = _Name .. "verybig.png"
    end

    local u0, u1, v0, v1;
    u0 = (_Coordinates[1] - 1) * _Size;
    v0 = (_Coordinates[2] - 1) * _Size;
    u1 = (_Coordinates[1]) * _Size;
    v1 = (_Coordinates[2]) * _Size;

    State = 1;
    if XGUIEng.IsButton(_WidgetID) == 1 then
        State = 7;
    end
    XGUIEng.SetMaterialAlpha(_WidgetID, State, 255);
    XGUIEng.SetMaterialTexture(_WidgetID, State, _Name);
    XGUIEng.SetMaterialUV(_WidgetID, State, u0, v0, u1, v1);
end

---
-- Setzt einen Beschreibungstooltip.
--
-- @param[type=string] _title        Titel des Tooltip
-- @param[type=string] _text         Text des Tooltip
-- @param[type=string] _disabledText Textzusatz wenn inaktiv
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:TextNormal(_title, _text, _disabledText)
    _title = API.Localize(_title or "");
    _text = API.Localize(_text or "");
    _disabledText = API.Localize(_disabledText or "");

    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal"
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")
    local PositionWidget = XGUIEng.GetCurrentWidgetID()
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)
    local TooltipContainerSizeWidgets = {TooltipBGWidget}
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget)
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)

    local disabled = "";
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _title)
    XGUIEng.SetText(TooltipDescriptionWidget, _text .. disabled)
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)
end

---
-- Setzt den Kostentooltip.
--
-- @param[type=string]  _title        Titel des Tooltip
-- @param[type=string]  _text         Text des Tooltip
-- @param[type=string]  _disabledText Textzusatz wenn inaktiv
-- @param[type=table]   _costs        Kostentabelle
-- @param[type=boolean] _inSettlement Kosten in Siedlung suchen
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:TextCosts(_title,_text,_disabledText,_costs,_inSettlement)
    _costs = _costs or {};
    _title = API.Localize(_title or "");
    _text = API.Localize(_text or "");
    _disabledText = API.Localize(_disabledText or "");

    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")
    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")
    local PositionWidget = XGUIEng.GetCurrentWidgetID()
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)
    GUI_Tooltip.SetCosts(TooltipCostsContainer, _costs, _inSettlement)
    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)
    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)

    _disabledText = _disabledText or "";
    local disabled = ""
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _title)
    XGUIEng.SetText(TooltipDescriptionWidget, _text .. disabled)
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleInterfaceApperance");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleInterfaceFeatureVisibility                             # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet dem Nutzer Funktionen um ausgewählte Buttons und
-- Widgets auszublenden oder einzublenden. Auf diese Weise können dem Spieler
-- Funktionalitäten vorenthalten werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleInterfaceFeatureVisibility = {};

API = API or {};
QSB = QSB or {};

QSB.PlayerNames = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Graut die Minimap aus oder macht sie wieder verwendbar.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideMinimap(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideMinimap(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapOverlay",
        _Flag
    );
    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapTerrain",
        _Flag
    );
end

---
-- Versteckt den Umschaltknopf der Minimap oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideToggleMinimap(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideToggleMinimap(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/MinimapButton",
        _Flag
    );
end

---
-- Versteckt den Button des Diplomatiemenü oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideDiplomacyMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideDiplomacyMenu(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/DiplomacyMenuButton",
        _Flag
    );
end

---
-- Versteckt den Button des Produktionsmenü oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideProductionMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideProductionMenu(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/ProductionMenuButton",
        _Flag
    );
end

---
-- Versteckt den Button des Wettermenüs oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideWeatherMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideWeatherMenu(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/WeatherMenuButton",
        _Flag
    );
end

---
-- Versteckt den Button zum Territorienkauf oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideBuyTerritory(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideBuyTerritory(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory",
        _Flag
    );
end

---
-- Versteckt den Button der Heldenfähigkeit oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideKnightAbility(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideKnightAbility(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbilityProgress",
        _Flag
    );
    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbility",
        _Flag
    );
end

---
-- Versteckt den Button zur Heldenselektion oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideKnightButton(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideKnightButton(" ..tostring(_Flag).. ")");
        return;
    end

    local KnightID = Logic.GetKnightID(GUI.GetPlayerID());
    if _Flag == true then
        GUI.SendScriptCommand("Logic.SetEntitySelectableFlag("..KnightID..", 0)");
        GUI.DeselectEntity(KnightID);
    else
        GUI.SendScriptCommand("Logic.SetEntitySelectableFlag("..KnightID..", 1)");
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButtonProgress",
        _Flag
    );
    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButton",
        _Flag
    );
end

---
-- Versteckt den Button zur Selektion des Militärs oder blendet ihn ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideSelectionButton(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideSelectionButton(" ..tostring(_Flag).. ")");
        return;
    end
    API.InterfaceHideKnightButton(_Flag);
    GUI.ClearSelection();

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/BattalionButton",
        _Flag
    );
end

---
-- Versteckt das Baumenü oder blendet es ein.
--
-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!</p>
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideBuildMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideBuildMenu(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/BuildMenu",
        _Flag
    );
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleInterfaceFeatureVisibility = {
    Global = {},
    Local = {
        Data = {
            HiddenWidgets = {},
        },
    }
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Global:Install()
    API.AddSaveGameAction(BundleInterfaceFeatureVisibility.Global.RestoreAfterLoad);
end

---
-- Stellt alle versteckten Buttons nach dem Laden eines Spielstandes wieder her.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Global.RestoreAfterLoad()
    Logic.ExecuteInLuaLocalState([[
        BundleInterfaceFeatureVisibility.Local:RestoreAfterLoad();
    ]]);
end

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Local:Install()
    Core:StackFunction("GUI_Knight.ClaimTerritoryUpdate", self.UpdateClaimTerritory);
end

---
-- Versteht ein Widget oder blendet es ein.
--
-- @param _Widget [string|number] Widgetpfad oder ID
-- @param _Hide [boolean] Hidden Flag
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(_Widget, _Hide)
    self.Data.HiddenWidgets[_Widget] = _Hide == true;
    XGUIEng.ShowWidget(_Widget, (_Hide == true and 0) or 1);
end

---
-- Stellt alle versteckten Buttons nach dem Laden eines Spielstandes wieder her.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Local:RestoreAfterLoad()
    for k, v in pairs(self.Data.HiddenWidgets) do
        if v then
            XGUIEng.ShowWidget(k, 0);
        end
    end
end

---
-- Versteckt den Claim-Territory-Button.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Local.UpdateClaimTerritory()
    local Key = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory";
    if BundleInterfaceFeatureVisibility.Local.Data.HiddenWidgets[Key] == true then
        XGUIEng.ShowWidget(Key, 0);
        return true;
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleInterfaceFeatureVisibility");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleKnightTitleRequirements                                # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Erlaubt es dem Mapper die vorgegebenen Aufstiegsbedingungen idividuell
-- an die eigenen Vorstellungen anzupassen.
--
-- Die Aufstiegsbedingungen werden in der Funktion InitKnightTitleTables
-- angegeben und bearbeitet.
--
-- <p>Mögliche Aufstiegsbedingungen:
-- <ul>
-- <li><b>Entitytyp besitzen</b><br/>
-- Der Spieler muss eine bestimmte Anzahl von Entities eines Typs besitzen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Entities = {
--     {Entities.B_Bakery, 2},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Entitykategorie besitzen</b><br/>
-- Der Spieler muss eine bestimmte Anzahl von Entities einer Kategorie besitzen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Category = {
--     {EntitiyCategories.CattlePasture, 10},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Gütertyp besitzen</b><br/>
-- Der Spieler muss Rohstoffe oder Güter eines Typs besitzen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Goods = {
--     {Goods.G_RawFish, 35},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Produkte erzeugen</b><br/>
-- Der Spieler muss Gebrauchsgegenstände für ein Bedürfnis bereitstellen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Products = {
--     {GoodCategories.GC_Clothes, 6},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Güter konsumieren</b><br/>
-- Die Siedler müssen eine Menge einer bestimmten Waren konsumieren.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Consume = {
--     {Goods.G_Bread, 30},
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Vielfältigkeit bereitstellen</b><br/>
-- Der Spieler muss einen Vielfältigkeits-Buff aktivieren.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Buff = {
--     Buffs.Buff_FoodDiversity,
--     ...
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Stadtruf erreichen</b><br/>
-- Der Ruf der Stadt muss einen bestimmten Wert erreichen oder überschreiten.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Reputation = 20
-- </code></pre>
--
-- <li><b>Anzahl an Dekorationen</b><br/>
-- Der Spieler muss mindestens die Anzahl der angegebenen Dekoration besitzen.
-- <code><pre>
-- KnightTitleRequirements[KnightTitles.Mayor].DecoratedBuildings = {
--     {Goods.G_Banner, 9 },
-- }
-- </code></pre>
-- </li>
--
-- <li><b>Anzahl voll dekorierter Gebäude</b><br/>
-- Anzahl an Gebäuden, an die alle vier Dekorationen angebracht sein müssen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].FullDecoratedBuildings = 12
-- </code></pre>
-- </li>
--
-- <li><b>Spezialgebäude ausbauen</b><br/>
-- Ein Spezielgebäude muss ausgebaut werden.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1
-- KnightTitleRequirements[KnightTitles.Mayor].Storehouse = 1
-- KnightTitleRequirements[KnightTitles.Mayor].Cathedrals = 1
-- </code></pre>
-- </li>
--
-- <li><b>Anzahl Siedler</b><br/>
-- Der Spieler benötigt eine Gesamtzahl an Siedlern.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Settlers = 40
-- </code></pre>
-- </li>
--
-- <li><b>Anzahl reiche Stadtgebäude</b><br/>
-- Eine Anzahl an Gebäuden muss durch Einnahmen Reichtum erlangen.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].RichBuildings = 30
-- </code></pre>
-- </li>
--
-- <li><b>Benutzerdefiniert</b><br/>
-- Eine benutzerdefinierte Funktion, die entweder als Schalter oder als Zähler
-- fungieren kann und true oder false zurückgeben muss.
-- <pre><code>
-- KnightTitleRequirements[KnightTitles.Mayor].Custom = {
--     {SomeFunction, {1, 1}, "Überschrift", "Beschreibung"}
-- }
-- </code></pre>
-- </li>
-- </ul></p>
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleKnightTitleRequirements = {};

API = API or {};
QSB = QSB or {};

QSB.RequirementTooltipTypes = {};
QSB.ConsumedGoodsCounter = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --



-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleKnightTitleRequirements = {
    Global = {},
    Local = {
        Data = {},
    }
};

-- Global Script ---------------------------------------------------------------

---
-- Installiert das Bundle im globalen Skript.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Global:Install()
    self:OverwriteConsumedGoods();
end

---
-- Zählt den Konsumzähler rauf, sobald eine Ware konsumiert wird.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Warentyp
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Global:RegisterConsumedGoods(_PlayerID, _Good)
    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;
end

---
-- Überschreibt GameCallback_ConsumeGood, sodass konsumierte Waren gezählt
-- werden können.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Global:OverwriteConsumedGoods()
    GameCallback_ConsumeGood_Orig_QSB_Requirements = GameCallback_ConsumeGood
    GameCallback_ConsumeGood = function(_Consumer, _Good, _Building)
        GameCallback_ConsumeGood_Orig_QSB_Requirements(_Consumer, _Good, _Building)

        local PlayerID = Logic.EntityGetPlayer(_Consumer);
        BundleKnightTitleRequirements.Global:RegisterConsumedGoods(PlayerID, _Good);
        Logic.ExecuteInLuaLocalState([[
            BundleKnightTitleRequirements.Local:RegisterConsumedGoods(
                ]] ..PlayerID.. [[, ]] .._Good.. [[
            );
        ]]);
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Installiert das Bundle im lokalen Skript.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:Install()
    self:OverwriteTooltips();
    self:InitTexturePositions();
    self:OverwriteUpdateRequirements();
    self:OverwritePromotionCelebration();
end

---
-- Zählt den Konsumzähler rauf, sobald eine Ware konsumiert wird.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Warentyp
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:RegisterConsumedGoods(_PlayerID, _Good)
    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;
end

---
-- Fügt einige weitere Einträge zu den Texturpositionen hinzu.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:InitTexturePositions()
    g_TexturePositions.EntityCategories[EntityCategories.GC_Food_Supplier]          = { 1, 1};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Clothes_Supplier]       = { 1, 2};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Hygiene_Supplier]       = {16, 1};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Entertainment_Supplier] = { 1, 4};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Luxury_Supplier]        = {16, 3};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Weapon_Supplier]        = { 1, 7};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Medicine_Supplier]      = { 2,10};
    g_TexturePositions.EntityCategories[EntityCategories.Outpost]                   = {12, 3};
    g_TexturePositions.EntityCategories[EntityCategories.Spouse]                    = { 5,15};
    g_TexturePositions.EntityCategories[EntityCategories.CattlePasture]             = { 3,16};
    g_TexturePositions.EntityCategories[EntityCategories.SheepPasture]              = { 4, 1};
    g_TexturePositions.EntityCategories[EntityCategories.Soldier]                   = { 7,12};
    g_TexturePositions.EntityCategories[EntityCategories.GrainField]                = {14, 2};
    g_TexturePositions.EntityCategories[EntityCategories.BeeHive]                   = { 2, 1};
    g_TexturePositions.EntityCategories[EntityCategories.OuterRimBuilding]          = { 3, 4};
    g_TexturePositions.EntityCategories[EntityCategories.CityBuilding]              = { 8, 1};
    g_TexturePositions.EntityCategories[EntityCategories.Leader]                    = { 7, 11};
    g_TexturePositions.EntityCategories[EntityCategories.Range]                     = { 9, 8};
    g_TexturePositions.EntityCategories[EntityCategories.Melee]                     = { 9, 7};
    g_TexturePositions.EntityCategories[EntityCategories.SiegeEngine]               = { 2,15};

    g_TexturePositions.Entities[Entities.B_Beehive]                                 = { 2, 1};
    g_TexturePositions.Entities[Entities.B_Cathedral_Big]                           = { 3,12};
    g_TexturePositions.Entities[Entities.B_CattlePasture]                           = { 3,16};
    g_TexturePositions.Entities[Entities.B_GrainField_ME]                           = { 1,13};
    g_TexturePositions.Entities[Entities.B_GrainField_NA]                           = { 1,13};
    g_TexturePositions.Entities[Entities.B_GrainField_NE]                           = { 1,13};
    g_TexturePositions.Entities[Entities.B_GrainField_SE]                           = { 1,13};
    g_TexturePositions.Entities[Entities.U_MilitaryBallista]                        = {10, 5};
    g_TexturePositions.Entities[Entities.B_Outpost]                                 = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_ME]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_NA]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_NE]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_SE]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_SheepPasture]                            = { 4, 1};
    g_TexturePositions.Entities[Entities.U_SiegeEngineCart]                         = { 9, 4};
    g_TexturePositions.Entities[Entities.U_Trebuchet]                               = { 9, 1};
    if Framework.GetGameExtraNo() ~= 0 then
        g_TexturePositions.Entities[Entities.B_GrainField_AS]                       = { 1,13};
        g_TexturePositions.Entities[Entities.B_Outpost_AS]                          = {12, 3};
    end

    g_TexturePositions.Needs[Needs.Medicine]                                        = { 2,10};

    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_1]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_2]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_3]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_1]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_2]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_3]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_1]            = { 4, 6};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_2]            = { 4, 6};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_3]            = { 4, 6};

    g_TexturePositions.Buffs = g_TexturePositions.Buffs or {};

    g_TexturePositions.Buffs[Buffs.Buff_ClothesDiversity]                           = { 1, 2};
    g_TexturePositions.Buffs[Buffs.Buff_EntertainmentDiversity]                     = { 1, 4};
    g_TexturePositions.Buffs[Buffs.Buff_FoodDiversity]                              = { 1, 1};
    g_TexturePositions.Buffs[Buffs.Buff_HygieneDiversity]                           = { 1, 3};
    g_TexturePositions.Buffs[Buffs.Buff_Colour]                                     = { 5,11};
    g_TexturePositions.Buffs[Buffs.Buff_Entertainers]                               = { 5,12};
    g_TexturePositions.Buffs[Buffs.Buff_ExtraPayment]                               = { 1, 8};
    g_TexturePositions.Buffs[Buffs.Buff_Sermon]                                     = { 4,14};
    g_TexturePositions.Buffs[Buffs.Buff_Spice]                                      = { 5,10};
    g_TexturePositions.Buffs[Buffs.Buff_NoTaxes]                                    = { 1, 6};
    if Framework.GetGameExtraNo() ~= 0 then
        g_TexturePositions.Buffs[Buffs.Buff_Gems]                                   = { 1, 1, 1};
        g_TexturePositions.Buffs[Buffs.Buff_MusicalInstrument]                      = { 1, 3, 1};
        g_TexturePositions.Buffs[Buffs.Buff_Olibanum]                               = { 1, 2, 1};
    end

    g_TexturePositions.GoodCategories = g_TexturePositions.GoodCategories or {};

    g_TexturePositions.GoodCategories[GoodCategories.GC_Ammunition]                 = {10, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Animal]                     = { 4,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Clothes]                    = { 1, 2};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Document]                   = { 5, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Entertainment]              = { 1, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Food]                       = { 1, 1};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Gold]                       = { 1, 8};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Hygiene]                    = {16, 1};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Luxury]                     = {16, 3};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Medicine]                   = { 2,10};
    g_TexturePositions.GoodCategories[GoodCategories.GC_None]                       = {15,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_RawFood]                    = { 3, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_RawMedicine]                = { 2, 2};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Research]                   = { 5, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Resource]                   = { 3, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Tools]                      = { 4,12};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Water]                      = { 1,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Weapon]                     = { 8, 5};
end

---
-- Überschreibt die Aktualisierungsfunktion der Aufstiegsbedingungen.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:OverwriteUpdateRequirements()
    GUI_Knight.UpdateRequirements = function()
        local WidgetPos = BundleKnightTitleRequirements.Local.Data.RequirementWidgets;
        local RequirementsIndex = 1;

        local PlayerID = GUI.GetPlayerID();
        local CurrentTitle = Logic.GetKnightTitle(PlayerID);
        local NextTitle = CurrentTitle + 1;

        --Headline
        local KnightID = Logic.GetKnightID(PlayerID);
        local KnightType = Logic.GetEntityType(KnightID);
        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitle", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));
        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitleWhite", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));

        -- show Settlers
        if KnightTitleRequirements[NextTitle].Settlers ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,16})
            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfSettlersForKnightTitleExist(PlayerID, NextTitle)
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount)
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1)
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0)
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1)

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Settlers";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- show rich buildings
        if KnightTitleRequirements[NextTitle].RichBuildings ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {8,4});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfRichBuildingsForKnightTitleExist(PlayerID, NextTitle);
            if NeededAmount == -1 then
                NeededAmount = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID, EntityCategories.CityBuilding);
            end
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "RichBuildings";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Castle
        if KnightTitleRequirements[NextTitle].Headquarters ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,7});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Headquarters);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Headquarters";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Storehouse
        if KnightTitleRequirements[NextTitle].Storehouse ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,6});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Storehouse);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Storehouse";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Cathedral
        if KnightTitleRequirements[NextTitle].Cathedrals ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,5});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Cathedrals);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Cathedrals";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Neue Bedingungen --------------------------------------------

        -- Volldekorierte Gebäude
        if KnightTitleRequirements[NextTitle].FullDecoratedBuildings ~= nil then
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle);
            local EntityCategory = KnightTitleRequirements[NextTitle].FullDecoratedBuildings;
            SetIcon(WidgetPos[RequirementsIndex].."/Icon"  , g_TexturePositions.Needs[Needs.Wealth]);

            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] , 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "FullDecoratedBuildings";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Stadtruf
        if KnightTitleRequirements[NextTitle].Reputation ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,14});
            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededCityReputationForKnightTitleExist(PlayerID, NextTitle);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Reputation";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Güter sammeln
        if KnightTitleRequirements[NextTitle].Goods ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Goods do
                local GoodType = KnightTitleRequirements[NextTitle].Goods[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfGoodTypesForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Goods" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Kategorien
        if KnightTitleRequirements[NextTitle].Category ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Category do
                local Category = KnightTitleRequirements[NextTitle].Category[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.EntityCategories[Category]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                local EntitiesInCategory = {Logic.GetEntityTypesInCategory(Category)};
                if Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.GC_Weapon_Supplier) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Weapons" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SiegeEngine) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "HeavyWeapons" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Spouse) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Spouse" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Worker) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Worker" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Soldier) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Soldiers" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Leader) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Leader" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Outpost) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Outposts" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CattlePasture) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Cattle" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SheepPasture) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Sheep" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CityBuilding) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "CityBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.OuterRimBuilding) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "OuterRimBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.GrainField) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "FarmerBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.BeeHive) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "FarmerBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.AttackableBuilding) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Buildings" .. i;
                else
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "EntityCategoryDefault" .. i;
                end
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Entities
        if KnightTitleRequirements[NextTitle].Entities ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Entities do
                local EntityType = KnightTitleRequirements[NextTitle].Entities[i][1];
                local EntityTypeName = Logic.GetEntityTypeName(EntityType);
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Entities[EntityType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                local TopltipType = "Entities" .. i;
                if EntityTypeName == "B_Beehive" or EntityTypeName:find("GrainField") or EntityTypeName:find("Pasture") then
                    TopltipType = "FarmerBuilding" .. i;
                end
                QSB.RequirementTooltipTypes[RequirementsIndex] = TopltipType;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Güter konsumieren
        if KnightTitleRequirements[NextTitle].Consume ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Consume do
                local GoodType = KnightTitleRequirements[NextTitle].Consume[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfConsumedGoodsForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Consume" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Güter aus Gruppe produzieren
        if KnightTitleRequirements[NextTitle].Products ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Products do
                local Product = KnightTitleRequirements[NextTitle].Products[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.GoodCategories[Product]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNumberOfProductsInCategoryExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Products" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Bonus aktivieren
        if KnightTitleRequirements[NextTitle].Buff ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Buff do
                local Buff = KnightTitleRequirements[NextTitle].Buff[i];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Buffs[Buff]);
                local IsFulfilled = DoNeededDiversityBuffForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Buff" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Selbstdefinierte Bedingung
        if KnightTitleRequirements[NextTitle].Custom ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Custom do
                local Icon = KnightTitleRequirements[NextTitle].Custom[i][2];
                BundleKnightTitleRequirements.Local:RequirementIcon(WidgetPos[RequirementsIndex] .. "/Icon", Icon);
                local IsFulfilled, CurrentAmount, NeededAmount = DoCustomFunctionForKnightTitleSucceed(PlayerID, NextTitle, i);
                if CurrentAmount and NeededAmount then
                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                else
                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");
                end
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Custom" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Dekorationselemente
        if KnightTitleRequirements[NextTitle].DecoratedBuildings ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].DecoratedBuildings do
                local GoodType = KnightTitleRequirements[NextTitle].DecoratedBuildings[i][1];
                SetIcon(WidgetPos[RequirementsIndex].."/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "DecoratedBuildings" ..i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Übrige ausblenden
        for i=RequirementsIndex, 6 do
            XGUIEng.ShowWidget(WidgetPos[i], 0);
        end
    end
end

---
-- Überschreibt die Beförderung des Primary Knight.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:OverwritePromotionCelebration()
    StartKnightsPromotionCelebration = function( _PlayerID , _OldTitle, _FirstTime)
        if _PlayerID ~= GUI.GetPlayerID() or Logic.GetTime() < 5 then
            return;
        end

        local MarketplaceID = Logic.GetMarketplace(_PlayerID);

        if _FirstTime == 1 then
            local KnightID = Logic.GetKnightID(_PlayerID);
            local Random

            repeat
                Random = 1 + XGUIEng.GetRandom(3)
            until Random ~= g_LastGotPromotionMessageRandom

            g_LastGotPromotionMessageRandom = Random;
            local TextKey = "Title_GotPromotion" .. Random;
            LocalScriptCallback_QueueVoiceMessage(_PlayerID, TextKey, false, _PlayerID);
            GUI.StartFestival(_PlayerID, 1);
        end

        -- reset local
        local Consume = QSB.ConsumedGoodsCounter[_PlayerID];
        QSB.ConsumedGoodsCounter[_PlayerID] = Consume or {};
        for k,v in pairs(QSB.ConsumedGoodsCounter[_PlayerID]) do
            QSB.ConsumedGoodsCounter[_PlayerID][k] = 0;
        end

        -- reset global
        GUI.SendScriptCommand([[
            local Consume = QSB.ConsumedGoodsCounter[]].._PlayerID..[[];
            QSB.ConsumedGoodsCounter[]].._PlayerID..[[] = Consume or {};
            for k,v in pairs(QSB.ConsumedGoodsCounter[]].._PlayerID..[[]) do
                QSB.ConsumedGoodsCounter[]].._PlayerID..[[][k] = 0;
            end
        ]]);

        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu", 0);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopCenter/KnightTitleMenuBig", 0);
        g_WantsPromotionMessageInterval = 30;
        g_TimeOfPromotionPossible = nil;
    end
end

---
-- Überschreibt die Tooltips im Aufstiegsmenü.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:OverwriteTooltips()
    GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements = GUI_Tooltip.SetNameAndDescription;
    GUI_Tooltip.SetNameAndDescription = function(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean)
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local Selected = GUI.GetSelectedEntity();
        local PlayerID = GUI.GetPlayerID();

        for k,v in pairs(BundleKnightTitleRequirements.Local.Data.RequirementWidgets) do
            if v .. "/Icon" == XGUIEng.GetWidgetPathByID(CurrentWidgetID) then
                local key = QSB.RequirementTooltipTypes[k];
                local num = tonumber(string.sub(key, string.len(key)));
                if num ~= nil then
                    key = string.sub(key, 1, string.len(key)-1);
                end
                BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);
                return;
            end
        end
        GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean);
    end

    GUI_Knight.RequiredGoodTooltip = function()
        local key = QSB.RequirementTooltipTypes[2];
        local num = tonumber(string.sub(key, string.len(key)));
        if num ~= nil then
            key = string.sub(key, 1, string.len(key)-1);
        end
        BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);
    end

    if Framework.GetGameExtraNo() ~= 0 then
        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_Gems] = {
            de = "Edelsteine beschaffen", en = "Obtain gems"
        }
        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_Olibanum] = {
            de = "Weihrauch beschaffen", en = "Obtain olibanum"
        }
        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_MusicalInstrument] = {
            de = "Muskinstrumente beschaffen", en = "Obtain instruments"
        }
    end
end

---
-- Ändert die Textur eines Icons in den Aufstiegsbedingungen.
--
-- Icons für Aufstiegsbedingungen können sein:
-- <ul>
-- <li>Koordinaten auf der Spielinternen Icon Matrix</li>
-- <li>Koordinaten auf einer externen Icon Matrix (Name .. "big.png")</li>
-- <li>Pfad zu einelnem Icon (200x200 Pixel)</li>
-- </ul>
--
-- @param[type=string] _Widget Icon Widget
-- @param              _Icon Icon Textur (Dateiname oder Matrix)
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:RequirementIcon(_Widget, _Icon)
    if type(_Icon) == "table" then
        if type(_Icon[3]) == "string" then
            local ButtonState = 1;
            if XGUIEng.IsButton(_Widget) == 1 then
                ButtonState = 7;
            end

            local u0, u1, v0, v1;
            u0 = (_Icon[1] - 1) * 64;
            v0 = (_Icon[2] - 1) * 64;
            u1 = (_Icon[1]) * 64;
            v1 = (_Icon[2]) * 64;
            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);
            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");
            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);
        else
            SetIcon(_Widget, _Icon);
        end
    else
        local screenSize = {GUI.GetScreenSize()};
        local Scale = 330;
        if screenSize[2] >= 800 then
            Scale = 260;
        end
        if screenSize[2] >= 1000 then
            Scale = 210;
        end
        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);
        XGUIEng.SetMaterialTexture(_Widget, 1, _Icon);
        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);
    end
end

---
-- Setzt einen für den Tooltip des aktuellen Widget einen neuen Text.
--
-- @param[type=string] _Title Titel des Tooltip
-- @param[type=string] _Text  Text des Tooltip
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:RequirementTooltip(_Title, _Text)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);
    local TooltipContainerSizeWidgets = {TooltipBGWidget};
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title);
    XGUIEng.SetText(TooltipDescriptionWidget, _Text);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);
end

---
-- Ermittelt die veränderten Texte für den Tooltip hinter dem angegebenen Key.
--
-- @param[type=string] _key Index in Description
-- @param[type=number] _i   Buttonindex
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(_key, _i)
    local PlayerID = GUI.GetPlayerID();
    local KnightTitle = Logic.GetKnightTitle(PlayerID);
    local Title = ""
    local Text = "";

    if _key == "Consume" or _key == "Goods" or _key == "DecoratedBuildings" then
        local GoodType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local GoodTypeName = Logic.GetGoodTypeName(GoodType);
        local GoodName     = XGUIEng.GetStringTableText("UI_ObjectNames/" .. GoodTypeName);

        if GoodName == nil then
            GoodName = "Goods." .. GoodTypeName;
        end
        Title = GoodName;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;

    elseif _key == "Products" then
        local GoodCategoryNames = BundleKnightTitleRequirements.Local.Data.GoodCategoryNames;
        local Category = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local CategoryName = API.Localize(GoodCategoryNames[Category]);

        if CategoryName == nil then
            CategoryName = "ERROR: Name missng!";
        end
        Title = CategoryName;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;

    elseif _key == "Entities" then
        local EntityType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        local EntityName = XGUIEng.GetStringTableText("Names/" .. EntityTypeName);

        if EntityName == nil then
            EntityName = "Entities." .. EntityTypeName;
        end

        Title = EntityName;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;

    elseif _key == "Custom" then
        local Custom = KnightTitleRequirements[KnightTitle+1].Custom[_i];
        Title = Custom[3];
        Text  = Custom[4];

    elseif _key == "Buff" then
        local BuffTypeNames = BundleKnightTitleRequirements.Local.Data.BuffTypeNames;
        local BuffType = KnightTitleRequirements[KnightTitle+1][_key][_i];
        local BuffTitle = API.Localize(BuffTypeNames[BuffType]);

        if BuffTitle == nil then
            BuffTitle = "ERROR: Name missng!";
        end
        Title = BuffTitle;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;

    else
        Title = BundleKnightTitleRequirements.Local.Data.Description[_key].Title;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;
    end
    self:RequirementTooltip(API.Localize(Title), API.Localize(Text));
end

BundleKnightTitleRequirements.Local.Data.RequirementWidgets = {
    [1] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Settlers",
    [2] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Goods",
    [3] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/RichBuildings",
    [4] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Castle",
    [5] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Storehouse",
    [6] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Cathedral",
};

BundleKnightTitleRequirements.Local.Data.GoodCategoryNames = {
    [GoodCategories.GC_Ammunition]      = {de = "Munition", en = "Ammunition"},
    [GoodCategories.GC_Animal]          = {de = "Nutztiere", en = "Livestock"},
    [GoodCategories.GC_Clothes]         = {de = "Kleidung", en = "Clothes"},
    [GoodCategories.GC_Document]        = {de = "Dokumente", en = "Documents"},
    [GoodCategories.GC_Entertainment]   = {de = "Unterhaltung", en = "Entertainment"},
    [GoodCategories.GC_Food]            = {de = "Nahrungsmittel", en = "Food"},
    [GoodCategories.GC_Gold]            = {de = "Gold", en = "Gold"},
    [GoodCategories.GC_Hygiene]         = {de = "Hygieneartikel", en = "Hygiene"},
    [GoodCategories.GC_Luxury]          = {de = "Dekoration", en = "Decoration"},
    [GoodCategories.GC_Medicine]        = {de = "Medizin", en = "Medicine"},
    [GoodCategories.GC_None]            = {de = "Nichts", en = "None"},
    [GoodCategories.GC_RawFood]         = {de = "Nahrungsmittel", en = "Food"},
    [GoodCategories.GC_RawMedicine]     = {de = "Medizin", en = "Medicine"},
    [GoodCategories.GC_Research]        = {de = "Forschung", en = "Research"},
    [GoodCategories.GC_Resource]        = {de = "Rohstoffe", en = "Resource"},
    [GoodCategories.GC_Tools]           = {de = "Werkzeug", en = "Tools"},
    [GoodCategories.GC_Water]           = {de = "Wasser", en = "Water"},
    [GoodCategories.GC_Weapon]          = {de = "Waffen", en = "Weapon"},
};

BundleKnightTitleRequirements.Local.Data.BuffTypeNames = {
    [Buffs.Buff_ClothesDiversity]        = {de = "Abwechslungsreiche Kleidung", en = "Clothes diversity"},
    [Buffs.Buff_Colour]                  = {de = "Farben beschaffen", en = "Obtain color"},
    -- Funktioniert nicht, belegt MP
    [Buffs.Buff_Entertainers]            = {de = "Gaukler anheuern", en = "Hire entertainer"},
    [Buffs.Buff_EntertainmentDiversity]  = {de = "Abwechslungsreiche Unterhaltung", en = "Entertainment diversity"},
    [Buffs.Buff_ExtraPayment]            = {de = "Sonderzahlung", en = "Extra payment"},
    -- Funktioniert nicht, belegt MP
    [Buffs.Buff_Festival]                = {de = "Fest veranstalten", en = "Hold Festival"},
    [Buffs.Buff_FoodDiversity]           = {de = "Abwechslungsreiche Nahrung", en = "Food diversity"},
    [Buffs.Buff_HygieneDiversity]        = {de = "Abwechslungsreiche Hygiene", en = "Hygiene diversity"},
    [Buffs.Buff_NoTaxes]                 = {de = "Steuerbefreiung", en = "No taxes"},
    [Buffs.Buff_Sermon]                  = {de = "Pregigt abhalten", en = "Hold sermon"},
    [Buffs.Buff_Spice]                   = {de = "Salz beschaffen", en = "Obtain salt"},
};

BundleKnightTitleRequirements.Local.Data.Description = {
    Settlers = {
        Title = {
            de = "Benötigte Siedler",
            en = "Needed settlers",
        },
        Text = {
            de = "- Benötigte Menge an Siedlern",
            en = "- Needed number of settlers",
        },
    },

    RichBuildings = {
        Title = {
            de = "Reiche Stadtgebäude",
            en = "Rich city buildings",
        },
        Text = {
            de = "- Menge an reichen Stadtgebäuden",
            en = "- Needed amount of rich city buildings",
        },
    },

    Goods = {
        Title = {
            de = "Waren lagern",
            en = "Store Goods",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed amount",
        },
    },

    FullDecoratedBuildings = {
        Title = {
            de = "Dekorierte Stadtgebäude",
            en = "Decorated City buildings",
        },
        Text = {
            de = "- Menge an voll dekorierten Gebäuden",
            en = "- Amount of full decoraded city buildings",
        },
    },

    DecoratedBuildings = {
        Title = {
            de = "Dekoration",
            en = "Decoration",
        },
        Text = {
            de = "- Menge an Dekorationsgütern in der Siedlung",
            en = "- Amount of decoration goods in settlement",
        },
    },

    Headquarters = {
        Title = {
            de = "Burgstufe",
            en = "Castle level",
        },
        Text = {
            de = "- Benötigte Ausbauten der Burg",
            en = "- Needed castle upgrades",
        },
    },

    Storehouse = {
        Title = {
            de = "Lagerhausstufe",
            en = "Storehouse level",
        },
        Text = {
            de = "- Benötigte Ausbauten des Lagerhauses",
            en = "- Needed storehouse upgrades",
        },
    },

    Cathedrals = {
        Title = {
            de = "Kirchenstufe",
            en = "Cathedral level",
        },
        Text = {
            de = "- Benötigte Ausbauten der Kirche",
            en = "- Needed cathedral upgrades",
        },
    },

    Reputation = {
        Title = {
            de = "Ruf der Stadt",
            en = "City reputation",
        },
        Text = {
            de = "- Benötigter Ruf der Stadt",
            en = "- Needed city reputation",
        },
    },

    EntityCategoryDefault = {
        Title = {
            de = "",
            en = "",
        },
        Text = {
            de = "- Benötigte Anzahl",
            en = "- Needed amount",
        },
    },

    Cattle = {
        Title = {
            de = "Kühe",
            en = "Cattle",
        },
        Text = {
            de = "- Benötigte Menge an Kühen",
            en = "- Needed amount of cattle",
        },
    },

    Sheep = {
        Title = {
            de = "Schafe",
            en = "Sheeps",
        },
        Text = {
            de = "- Benötigte Menge an Schafen",
            en = "- Needed amount of sheeps",
        },
    },

    Outposts = {
        Title = {
            de = "Territorien",
            en = "Territories",
        },
        Text = {
            de = "- Zu erobernde Territorien",
            en = "- Territories to claim",
        },
    },

    CityBuilding = {
        Title = {
            de = "Stadtgebäude",
            en = "City buildings",
        },
        Text = {
            de = "- Menge benötigter Stadtgebäude",
            en = "- Needed amount of city buildings",
        },
    },

    OuterRimBuilding = {
        Title = {
            de = "Rohstoffgebäude",
            en = "Gatherer",
        },
        Text = {
            de = "- Menge benötigter Rohstoffgebäude",
            en = "- Needed amount of gatherer",
        },
    },

    FarmerBuilding = {
        Title = {
            de = "Farmeinrichtungen",
            en = "Farming structure",
        },
        Text = {
            de = "- Menge benötigter Nutzfläche",
            en = "- Needed amount of farming structure",
        },
    },

    Consume = {
        Title = {
            de = "",
            en = "",
        },
        Text = {
            de = "- Durch Siedler zu konsumierende Menge",
            en = "- Amount to be consumed by the settlers",
        },
    },

    Products = {
        Title = {
            de = "",
            en = "",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed amount",
        },
    },

    Buff = {
        Title = {
            de = "Bonus aktivieren",
            en = "Activate Buff",
        },
        Text = {
            de = "- Aktiviere diesen Bonus auf den Ruf der Stadt",
            en = "- Raise the city reputatition with this buff",
        },
    },

    Leader = {
        Title = {
            de = "Batalione",
            en = "Battalions",
        },
        Text = {
            de = "- Menge an Batalionen unterhalten",
            en = "- Battalions you need under your command",
        },
    },

    Soldiers = {
        Title = {
            de = "Soldaten",
            en = "Soldiers",
        },
        Text = {
            de = "- Menge an Streitkräften unterhalten",
            en = "- Soldiers you need under your command",
        },
    },

    Worker = {
        Title = {
            de = "Arbeiter",
            en = "Workers",
        },
        Text = {
            de = "- Menge an arbeitender Bevölkerung",
            en = "- Workers you need under your reign",
        },
    },

    Entities = {
        Title = {
            de = "",
            en = "",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed Amount",
        },
    },

    Buildings = {
        Title = {
            de = "Gebäude",
            en = "Buildings",
        },
        Text = {
            de = "- Gesamtmenge an Gebäuden",
            en = "- Amount of buildings",
        },
    },

    Weapons = {
        Title = {
            de = "Waffen",
            en = "Weapons",
        },
        Text = {
            de = "- Benötigte Menge an Waffen",
            en = "- Needed amount of weapons",
        },
    },

    HeavyWeapons = {
        Title = {
            de = "Belagerungsgeräte",
            en = "Siege Engines",
        },
        Text = {
            de = "- Benötigte Menge an Belagerungsgeräten",
            en = "- Needed amount of siege engine",
        },
    },

    Spouse = {
        Title = {
            de = "Ehefrauen",
            en = "Spouses",
        },
        Text = {
            de = "- Benötigte Anzahl Ehefrauen in der Stadt",
            en = "- Needed amount of spouses in your city",
        },
    },
};

Core:RegisterBundle("BundleKnightTitleRequirements");

-- -------------------------------------------------------------------------- --
-- Spielfunktionen                                                            --
-- -------------------------------------------------------------------------- --

---
-- Prüft, ob genug Entities in einer bestimmten Kategorie existieren.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Category == nil then
        return;
    end
    if _i then
        local EntityCategory = KnightTitleRequirements[_KnightTitle].Category[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Category[_i][2];

        local ReachedAmount = 0;
        if EntityCategory == EntityCategories.Spouse then
            ReachedAmount = Logic.GetNumberOfSpouses(_PlayerID);
        else
            local Buildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategory)};
            for i=1, #Buildings do
                if Logic.IsBuilding(Buildings[i]) == 1 then
                    if Logic.IsConstructionComplete(Buildings[i]) == 1 then
                        ReachedAmount = ReachedAmount +1;
                    end
                else
                    ReachedAmount = ReachedAmount +1;
                end
            end
        end

        if ReachedAmount >= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Category do
            bool, reach, need = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob genug Entities eines bestimmten Typs existieren.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Entities == nil then
        return;
    end
    if _i then
        local EntityType = KnightTitleRequirements[_KnightTitle].Entities[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Entities[_i][2];
        local Buildings = GetPlayerEntities(_PlayerID, EntityType);

        local ReachedAmount = 0;
        for i=1, #Buildings do
            if Logic.IsBuilding(Buildings[i]) == 1 then
                if Logic.IsConstructionComplete(Buildings[i]) == 1 then
                    ReachedAmount = ReachedAmount +1;
                end
            else
                ReachedAmount = ReachedAmount +1;
            end
        end

        if ReachedAmount >= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Entities do
            bool, reach, need = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob es genug Einheiten eines Warentyps gibt.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoesNeededNumberOfGoodTypesForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Goods == nil then
        return;
    end
    if _i then
        local GoodType = KnightTitleRequirements[_KnightTitle].Goods[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Goods[_i][2];
        local ReachedAmount = GetPlayerGoodsInSettlement(GoodType, _PlayerID, true);

        if ReachedAmount >= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Goods do
            bool, reach, need = DoesNeededNumberOfGoodTypesForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob die Siedler genug Einheiten einer Ware konsumiert haben.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNeededNumberOfConsumedGoodsForKnightTitleExist = function( _PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Consume == nil then
        return;
    end
    if _i then
        QSB.ConsumedGoodsCounter[_PlayerID] = QSB.ConsumedGoodsCounter[_PlayerID] or {};

        local GoodType = KnightTitleRequirements[_KnightTitle].Consume[_i][1];
        local GoodAmount = QSB.ConsumedGoodsCounter[_PlayerID][GoodType] or 0;
        local NeededGoodAmount = KnightTitleRequirements[_KnightTitle].Consume[_i][2];
        if GoodAmount >= NeededGoodAmount then
            return true, GoodAmount, NeededGoodAmount;
        else
            return false, GoodAmount, NeededGoodAmount;
        end
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Consume do
            bool, reach, need = DoNeededNumberOfConsumedGoodsForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return false, reach, need
            end
        end
        return true, reach, need;
    end
end

---
-- Prüft, ob genug Waren der Kategorie hergestellt wurde.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNumberOfProductsInCategoryExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Products == nil then
        return;
    end
    if _i then
        local GoodAmount = 0;
        local NeedAmount = KnightTitleRequirements[_KnightTitle].Products[_i][2];
        local GoodCategory = KnightTitleRequirements[_KnightTitle].Products[_i][1];
        local GoodsInCategory = {Logic.GetGoodTypesInGoodCategory(GoodCategory)};

        for i=1, #GoodsInCategory do
            GoodAmount = GoodAmount + GetPlayerGoodsInSettlement(GoodsInCategory[i], _PlayerID, true);
        end
        return (GoodAmount >= NeedAmount), GoodAmount, NeedAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Products do
            bool, reach, need = DoNumberOfProductsInCategoryExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob ein bestimmter Buff für den Spieler aktiv ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNeededDiversityBuffForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Buff == nil then
        return;
    end
    if _i then
        local buff = KnightTitleRequirements[_KnightTitle].Buff[_i];
        if Logic.GetBuff(_PlayerID,buff) and Logic.GetBuff(_PlayerID,buff) ~= 0 then
            return true;
        end
        return false;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Buff do
            bool, reach, need = DoNeededDiversityBuffForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob die Custom Function true vermeldet.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoCustomFunctionForKnightTitleSucceed = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Custom == nil then
        return;
    end
    if _i then
        return KnightTitleRequirements[_KnightTitle].Custom[_i][1]();
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Custom do
            bool, reach, need = DoCustomFunctionForKnightTitleSucceed(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob genug Dekoration eines Typs angebracht wurde.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNeededNumberOfDecoratedBuildingsForKnightTitleExist = function( _PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].DecoratedBuildings == nil then
        return
    end

    if _i then
        local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}
        local DecorationGoodType = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][1]
        local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][2]
        local BuildingsWithDecoration = 0

        for i=1, #CityBuildings do
            local BuildingID = CityBuildings[i]
            local GoodState = Logic.GetBuildingWealthGoodState(BuildingID, DecorationGoodType)
            if GoodState > 0 then
                BuildingsWithDecoration = BuildingsWithDecoration + 1
            end
        end

        if BuildingsWithDecoration >= NeededBuildingsWithDecoration then
            return true, BuildingsWithDecoration, NeededBuildingsWithDecoration
        else
            return false, BuildingsWithDecoration, NeededBuildingsWithDecoration
        end
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].DecoratedBuildings do
            bool, reach, need = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob die Spezialgebäude weit genug ausgebaut sind.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _EntityCategory Entity Category
-- @within Originalfunktionen
-- @local
--
DoNeededSpecialBuildingUpgradeForKnightTitleExist = function( _PlayerID, _KnightTitle, _EntityCategory)
    local SpecialBuilding
    local SpecialBuildingName
    if _EntityCategory == EntityCategories.Headquarters then
        SpecialBuilding = Logic.GetHeadquarters(_PlayerID)
        SpecialBuildingName = "Headquarters"
    elseif _EntityCategory == EntityCategories.Storehouse then
        SpecialBuilding = Logic.GetStoreHouse(_PlayerID)
        SpecialBuildingName = "Storehouse"
    elseif _EntityCategory == EntityCategories.Cathedrals then
        SpecialBuilding = Logic.GetCathedral(_PlayerID)
        SpecialBuildingName = "Cathedrals"
    else
        return
    end
    if KnightTitleRequirements[_KnightTitle][SpecialBuildingName] == nil then
        return
    end
    local NeededUpgradeLevel = KnightTitleRequirements[_KnightTitle][SpecialBuildingName]
    if SpecialBuilding ~= nil then
        local SpecialBuildingUpgradeLevel = Logic.GetUpgradeLevel(SpecialBuilding)
        if SpecialBuildingUpgradeLevel >= NeededUpgradeLevel then
            return true, SpecialBuildingUpgradeLevel, NeededUpgradeLevel
        else
            return false, SpecialBuildingUpgradeLevel, NeededUpgradeLevel
        end
    else
        return false, 0, NeededUpgradeLevel
    end
end

---
-- Prüft, ob der Ruf der Stadt hoch genug ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @within Originalfunktionen
-- @local
--
DoesNeededCityReputationForKnightTitleExist = function(_PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].Reputation == nil then
        return;
    end
    local NeededAmount = KnightTitleRequirements[_KnightTitle].Reputation;
    if not NeededAmount then
        return;
    end
    local ReachedAmount = math.floor((Logic.GetCityReputation(_PlayerID) * 100) + 0.5);
    if ReachedAmount >= NeededAmount then
        return true, ReachedAmount, NeededAmount;
    end
    return false, ReachedAmount, NeededAmount;
end

---
-- Prüft, ob genug Gebäude vollständig dekoriert sind.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @within Originalfunktionen
-- @local
--
DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist = function( _PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings == nil then
        return
    end
    local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}
    local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings
    local BuildingsWithDecoration = 0

    for i=1, #CityBuildings do
        local BuildingID = CityBuildings[i]
        local AmountOfWealthGoodsAtBuilding = 0

        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Banner ) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Sign  ) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Candle) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Ornament  ) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if AmountOfWealthGoodsAtBuilding >= 4 then
            BuildingsWithDecoration = BuildingsWithDecoration + 1
        end
    end

    if BuildingsWithDecoration >= NeededBuildingsWithDecoration then
        return true, BuildingsWithDecoration, NeededBuildingsWithDecoration
    else
        return false, BuildingsWithDecoration, NeededBuildingsWithDecoration
    end
end

---
-- Prüft, ob der Spieler befördert werden kann.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @within Originalfunktionen
-- @local
--
CanKnightBePromoted = function(_PlayerID, _KnightTitle)
    if _KnightTitle == nil then
        _KnightTitle = Logic.GetKnightTitle(_PlayerID) + 1;
    end

    if Logic.CanStartFestival(_PlayerID, 1) == true then
        if  KnightTitleRequirements[_KnightTitle] ~= nil
        and DoesNeededNumberOfSettlersForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfGoodsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Headquarters) ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Storehouse) ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Cathedrals)  ~= false
        and DoNeededNumberOfRichBuildingsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false
        and DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededCityReputationForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfGoodTypesForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoNeededDiversityBuffForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoCustomFunctionForKnightTitleSucceed( _PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfConsumedGoodsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoNumberOfProductsInCategoryExist( _PlayerID, _KnightTitle) ~= false then
            return true;
        end
    end
    return false;
end

---
-- Der Spieler gewinnt das Spiel
-- @within Originalfunktionen
-- @local
--
VictroryBecauseOfTitle = function()
    QuestTemplate:TerminateEventsAndStuff();
    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);
end

-- -------------------------------------------------------------------------- --
-- Aufstiegsbedingungen                                                       --
-- -------------------------------------------------------------------------- --

---
-- Definiert andere Aufstiegsbedingungen für den Spieler. Muss stets nach dem
-- Laden der QSB im globalen und lokalen Skript aufgerufen werden!
--
-- Diese Funktion muss entweder in der QSB modifiziert oder sowohl im globalen
-- als auch im lokalen Skript überschrieben werden. Bei Modifikationen muss
-- das Schema für Aufstiegsbedingungen und Rechtevergabe immer beibehalten
-- werden.
--
-- @within Originalfunktionen
--
InitKnightTitleTables = function()
    KnightTitles = {}
    KnightTitles.Knight     = 0
    KnightTitles.Mayor      = 1
    KnightTitles.Baron      = 2
    KnightTitles.Earl       = 3
    KnightTitles.Marquees   = 4
    KnightTitles.Duke       = 5
    KnightTitles.Archduke   = 6

    -- ---------------------------------------------------------------------- --
    -- Rechte und Pflichten                                                   --
    -- ---------------------------------------------------------------------- --

    NeedsAndRightsByKnightTitle = {}

    -- Ritter ------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Knight] = {
        ActivateNeedForPlayer,
        {
            Needs.Nutrition,                                    -- Bedürfnis: Nahrung
            Needs.Medicine,                                     -- Bedürfnis: Medizin
        },
        ActivateRightForPlayer,
        {
            Technologies.R_Gathering,                           -- Recht: Rohstoffsammler
            Technologies.R_Woodcutter,                          -- Recht: Holzfäller
            Technologies.R_StoneQuarry,                         -- Recht: Steinbruch
            Technologies.R_HuntersHut,                          -- Recht: Jägerhütte
            Technologies.R_FishingHut,                          -- Recht: Fischerhütte
            Technologies.R_CattleFarm,                          -- Recht: Kuhfarm
            Technologies.R_GrainFarm,                           -- Recht: Getreidefarm
            Technologies.R_SheepFarm,                           -- Recht: Schaffarm
            Technologies.R_IronMine,                            -- Recht: Eisenmine
            Technologies.R_Beekeeper,                           -- Recht: Imkerei
            Technologies.R_HerbGatherer,                        -- Recht: Kräutersammler
            Technologies.R_Nutrition,                           -- Recht: Nahrung
            Technologies.R_Bakery,                              -- Recht: Bäckerei
            Technologies.R_Dairy,                               -- Recht: Käserei
            Technologies.R_Butcher,                             -- Recht: Metzger
            Technologies.R_SmokeHouse,                          -- Recht: Räucherhaus
            Technologies.R_Clothes,                             -- Recht: Kleidung
            Technologies.R_Tanner,                              -- Recht: Ledergerber
            Technologies.R_Weaver,                              -- Recht: Weber
            Technologies.R_Construction,                        -- Recht: Konstruktion
            Technologies.R_Wall,                                -- Recht: Mauer
            Technologies.R_Pallisade,                           -- Recht: Palisade
            Technologies.R_Trail,                               -- Recht: Pfad
            Technologies.R_KnockDown,                           -- Recht: Abriss
            Technologies.R_Sermon,                              -- Recht: Predigt
            Technologies.R_SpecialEdition,                      -- Recht: Special Edition
            Technologies.R_SpecialEdition_Pavilion,             -- Recht: Pavilion AeK SE
        }
    }

    -- Landvogt ----------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Mayor] = {
        ActivateNeedForPlayer,
        {
            Needs.Clothes,                                      -- Bedürfnis: KLeidung
        },
        ActivateRightForPlayer, {
            Technologies.R_Hygiene,                             -- Recht: Hygiene
            Technologies.R_Soapmaker,                           -- Recht: Seifenmacher
            Technologies.R_BroomMaker,                          -- Recht: Besenmacher
            Technologies.R_Military,                            -- Recht: Militär
            Technologies.R_SwordSmith,                          -- Recht: Schwertschmied
            Technologies.R_Barracks,                            -- Recht: Schwertkämpferkaserne
            Technologies.R_Thieves,                             -- Recht: Diebe
            Technologies.R_SpecialEdition_StatueFamily,         -- Recht: Familienstatue Aek SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Baron -------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Baron] = {
        ActivateNeedForPlayer,
        {
            Needs.Hygiene,                                      -- Bedürfnis: Hygiene
        },
        ActivateRightForPlayer, {
            Technologies.R_Medicine,                            -- Recht: Medizin
            Technologies.R_BowMaker,                            -- Recht: Bogenmacher
            Technologies.R_BarracksArchers,                     -- Recht: Bogenschützenkaserne
            Technologies.R_Entertainment,                       -- Recht: Unterhaltung
            Technologies.R_Tavern,                              -- Recht: Taverne
            Technologies.R_Festival,                            -- Recht: Fest
            Technologies.R_Street,                              -- Recht: Straße
            Technologies.R_SpecialEdition_Column,               -- Recht: Säule AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Graf --------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Earl] = {
        ActivateNeedForPlayer,
        {
            Needs.Entertainment,                                -- Bedürfnis: Unterhaltung
            Needs.Prosperity,                                   -- Bedürfnis: Reichtum
        },
        ActivateRightForPlayer, {
            Technologies.R_SiegeEngineWorkshop,                 -- Recht: Belagerungswaffenschmied
            Technologies.R_BatteringRam,                        -- Recht: Ramme
            Technologies.R_Baths,                               -- Recht: Badehaus
            Technologies.R_AmmunitionCart,                      -- Recht: Munitionswagen
            Technologies.R_Prosperity,                          -- Recht: Reichtum
            Technologies.R_Taxes,                               -- Recht: Steuern einstellen
            Technologies.R_Ballista,                            -- Recht: Mauerkatapult
            Technologies.R_SpecialEdition_StatueSettler,        -- Recht: Siedlerstatue AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Marquees ----------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Marquees] = {
        ActivateNeedForPlayer,
        {
            Needs.Wealth,                                       -- Bedürfnis: Verschönerung
        },
        ActivateRightForPlayer, {
            Technologies.R_Theater,                             -- Recht: Theater
            Technologies.R_Wealth,                              -- Recht: Schmuckgebäude
            Technologies.R_BannerMaker,                         -- Recht: Bannermacher
            Technologies.R_SiegeTower,                          -- Recht: Belagerungsturm
            Technologies.R_SpecialEdition_StatueProduction,     -- Recht: Produktionsstatue AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Herzog ------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Duke] = {
        ActivateNeedForPlayer, nil,
        ActivateRightForPlayer, {
            Technologies.R_Catapult,                            -- Recht: Katapult
            Technologies.R_Carpenter,                           -- Recht: Tischler
            Technologies.R_CandleMaker,                         -- Recht: Kerzenmacher
            Technologies.R_Blacksmith,                          -- Recht: Schmied
            Technologies.R_SpecialEdition_StatueDario,          -- Recht: Dariostatue AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Erzherzog ---------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Archduke] = {
        ActivateNeedForPlayer,nil,
        ActivateRightForPlayer, {
            Technologies.R_Victory                              -- Sieg
        },
        -- VictroryBecauseOfTitle,                              -- Sieg wegen Titel
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }



    -- Reich des Ostens --------------------------------------------------------

    if g_GameExtraNo >= 1 then
        local TechnologiesTableIndex = 4;
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Cistern);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Brazier);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Shrine);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Baron][TechnologiesTableIndex],Technologies.R_Beautification_Pillar);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_StoneBench);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_Vase);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Marquees][TechnologiesTableIndex],Technologies.R_Beautification_Sundial);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Archduke][TechnologiesTableIndex],Technologies.R_Beautification_TriumphalArch);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Duke][TechnologiesTableIndex],Technologies.R_Beautification_VictoryColumn);
    end



    -- ---------------------------------------------------------------------- --
    -- Bedingungen                                                            --
    -- ---------------------------------------------------------------------- --

    KnightTitleRequirements = {}

    -- Ritter ------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Mayor] = {}
    KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1
    KnightTitleRequirements[KnightTitles.Mayor].Settlers = 10
    KnightTitleRequirements[KnightTitles.Mayor].Products = {
        {GoodCategories.GC_Clothes, 6},
    }

    -- Baron -------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Baron] = {}
    KnightTitleRequirements[KnightTitles.Baron].Settlers = 30
    KnightTitleRequirements[KnightTitles.Baron].Headquarters = 1
    KnightTitleRequirements[KnightTitles.Baron].Storehouse = 1
    KnightTitleRequirements[KnightTitles.Baron].Cathedrals = 1
    KnightTitleRequirements[KnightTitles.Baron].Products = {
        {GoodCategories.GC_Hygiene, 12},
    }

    -- Graf --------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Earl] = {}
    KnightTitleRequirements[KnightTitles.Earl].Settlers = 50
    KnightTitleRequirements[KnightTitles.Earl].Headquarters = 2
    KnightTitleRequirements[KnightTitles.Earl].Products = {
        {GoodCategories.GC_Entertainment, 18},
    }

    -- Marquess ----------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Marquees] = {}
    KnightTitleRequirements[KnightTitles.Marquees].Settlers = 70
    KnightTitleRequirements[KnightTitles.Marquees].Headquarters = 2
    KnightTitleRequirements[KnightTitles.Marquees].Storehouse = 2
    KnightTitleRequirements[KnightTitles.Marquees].Cathedrals = 2
    KnightTitleRequirements[KnightTitles.Marquees].RichBuildings = 20

    -- Herzog ------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Duke] = {}
    KnightTitleRequirements[KnightTitles.Duke].Settlers = 90
    KnightTitleRequirements[KnightTitles.Duke].Storehouse = 2
    KnightTitleRequirements[KnightTitles.Duke].Cathedrals = 2
    KnightTitleRequirements[KnightTitles.Duke].Headquarters = 3
    KnightTitleRequirements[KnightTitles.Duke].DecoratedBuildings = {
        {Goods.G_Banner, 9 },
    }

    -- Erzherzog ---------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Archduke] = {}
    KnightTitleRequirements[KnightTitles.Archduke].Settlers = 150
    KnightTitleRequirements[KnightTitles.Archduke].Storehouse = 3
    KnightTitleRequirements[KnightTitles.Archduke].Cathedrals = 3
    KnightTitleRequirements[KnightTitles.Archduke].Headquarters = 3
    KnightTitleRequirements[KnightTitles.Archduke].RichBuildings = 30
    KnightTitleRequirements[KnightTitles.Archduke].FullDecoratedBuildings = 30

    -- Einstellungen Aktivieren
    CreateTechnologyKnightTitleTable()
end

-- -------------------------------------------------------------------------- --

-- ########################################################################## --

-- #  Symfonia BundleMinimapMarker                                          # --

-- ########################################################################## --

-- -------------------------------------------------------------------------- --



---

-- Ermöglocht das Anlegen von Markierungen auf der Minimap.

--

-- Mögliche Typen von Markierungen:

-- <ul>

-- <li>Signal: Eine flüchtige Markierung, die nach wenigen Sekunden wieder

-- verschwindet.</li>

-- <li>Marker: Eine statische Markierung, die dauerhaft verbleibt.</li>

-- <li>Pulse: Eine pulsierende Markierung, die dauerhaft verbleibt.</li>

-- </ul>

--

-- Die Farbe eines Markers kann auf 2 verschiedene Weisen bestimmt werden.

-- <ol>

-- <li>Durch die Spielerfarbe des "Besitzers" der Markierung.

-- <pre> API.CreateMinimapSignal(1, GetPosition("pos"));</pre>

-- </li>

-- <li>Durch Übergabe einer vordefinierten Farbe oder einer Farbtabelle

-- <pre>

-- API.CreateMinimapSignal(MarkerColor.Red, GetPosition("pos"));

-- API.CreateMinimapSignal({180, 180, 180}, GetPosition("pos"));</pre>

-- </li>

-- </ol>

--

-- Durchsichtige Marker sind nicht vorgesehen!

--

-- @within Modulbeschreibung

-- @set sort=true

--

BundleMinimapMarker = {};



API = API or {};

QSB = QSB or {};



---

-- Vordefinierte Farben für Minimap Marker.

-- @field Blue Königsblau

-- @field Red Blutrot

-- @field Yellow Sonnengelb

-- @field Green Blattgrün

--

-- @usage API.CreateMinimapSignal(MarkerColor.Red, GetPosition("pos"));

--

MarkerColor = {

    Blue    = { 17,   7, 216},

    Red     = {216,   7,   7},

    Yellow  = { 25, 185,   8},

    Green   = { 16, 194, 220},

}



-- -------------------------------------------------------------------------- --

-- User-Space                                                                 --

-- -------------------------------------------------------------------------- --



---

-- Erstellt eine flüchtige Markierung auf der Minimap.

--

-- <b>Hinweis</b>: Die Farbe richtet sich nach der Spielerfarbe!

--

-- <b>Alias</b>: CreateMinimapSignal

--

-- @param _PlayerID PlayerID oder Farbtabelle (Spielernummer oder Farbtabelle)

-- @param _Position Position des Markers (Skriptname, ID oder Position)

-- @return[type=number] ID des Markers

-- @within Anwenderfunktionen

--

-- @usage API.CreateMinimapSignal(1, GetPosition("pos"));

--

function API.CreateMinimapSignal(_PlayerID, _Position)

    if GUI then

        return;

    end



    local Position = _Position;

    if type(_Position) ~= "table" then

        Position = GetPosition(_Position);

    end



    if type(Position) ~= "table" or (not Position.X or not Position.X) then

        log("API.CreateMinimapSignal: Position is invalid!", LEVEL_ERROR);

        return;

    end

    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 7);

end

CreateMinimapSignal = API.CreateMinimapSignal;



---

-- Erstellt eine statische Markierung auf der Minimap.

--

-- <b>Hinweis</b>: Die Farbe richtet sich nach der Spielerfarbe!

--

-- <b>Alias</b>: CreateMinimapMarker

--

-- @param _PlayerID PlayerID oder Farbtabelle (Spielernummer oder Farbtabelle)

-- @param _Position Position des Markers (Skriptname, ID oder Position)

-- @return[type=number] ID des Markers

-- @within Anwenderfunktionen

--

-- @usage API.CreateMinimapMarker(1, GetPosition("pos"));

--

function API.CreateMinimapMarker(_PlayerID, _Position)

    if GUI then

        return;

    end



    local Position = _Position;

    if type(_Position) ~= "table" then

        Position = GetPosition(_Position);

    end



    if type(Position) ~= "table" or (not Position.X or not Position.X) then

        log("API.CreateMinimapMarker: Position is invalid!", LEVEL_ERROR);

        return;

    end

    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 6);

end

CreateMinimapMarker = API.CreateMinimapMarker;



---

-- Erstellt eine pulsierende Markierung auf der Minimap.

--

-- <b>Hinweis</b>: Die Farbe richtet sich nach der Spielerfarbe!

--

-- <b>Alias</b>: CreateMinimapPulse

--

-- @param _PlayerID PlayerID oder Farbtabelle (Spielernummer oder Farbtabelle)

-- @param _Position Position des Markers (Skriptname, ID oder Position)

-- @return[type=number] ID des Markers

-- @within Anwenderfunktionen

--

-- @usage API.CreateMinimapPulse(1, GetPosition("pos"));

--

function API.CreateMinimapPulse(_PlayerID, _Position)

    if GUI then

        return;

    end



    local Position = _Position;

    if type(_Position) ~= "table" then

        Position = GetPosition(_Position);

    end

    

    if type(Position) ~= "table" or (not Position.X or not Position.X) then

        log("API.CreateMinimapPulse: Position is invalid!", LEVEL_ERROR);

        return;

    end

    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 1);

end

CreateMinimapPulse = API.CreateMinimapPulse;



---

-- Zerstört eine Markierung auf der Minimap.

--

-- <b>Alias</b>: DestroyMinimapSignal

--

-- @param[type=number] _ID ID des Markers

-- @within Anwenderfunktionen

--

-- @usage API.DestroyMinimapSignal(SomeMarkerID);

--

function API.DestroyMinimapSignal(_ID)

    if GUI then

        return;

    end

    if type(_ID) ~= "number" then

        log("API.DestroyMinimapSignal: _ID must be a number!", LEVEL_ERROR);

        return;

    end

    BundleMinimapMarker.Global:DestroyMinimapMarker(_ID);

end

DestroyMinimapMarker = API.DestroyMinimapSignal;



-- -------------------------------------------------------------------------- --

-- Application-Space                                                          --

-- -------------------------------------------------------------------------- --



BundleMinimapMarker = {

    Global = {

        Data = {

            MarkerCounter = 1000000,

            CreatedMinimapMarkers = {},

        },

    },

    Local = {

        Data = {},

    }

};



-- Global Script ---------------------------------------------------------------



---

-- Initialisiert das Bundle im globalen Skript.

-- @within Internal

-- @local

--

function BundleMinimapMarker.Global:Install()

    API.AddSaveGameAction(self.OnSaveGameLoaded);

end



---

-- Erstellt eine neue Markierung auf der Minimap.

-- 

-- @param[type=number] _PlayerID ID des Besitzers

-- @param[type=number] _X X-Koordinate des Markers

-- @param[type=number] _Y Y-Koordinate des Makers

-- @param[type=number] _Type Typ des Markers

-- @return[type=number] ID des Markers

-- @within Internal

-- @local

--

function BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, _X, _Y, _Type)

    self.Data.MarkerCounter = self.Data.MarkerCounter +1;

    -- Flüchtige Markierungen werden nicht gespeichert!

    self.Data.CreatedMinimapMarkers[self.Data.MarkerCounter] = {

        _PlayerID, _X, _Y, _Type

    };

    info("BundleMinimapMarker: Create minimap marker (X= " .._X.. ", Y= " .._Y.. ", " .._Type.. ")");

    self:ShowMinimapMarker(self.Data.MarkerCounter);

    return self.Data.MarkerCounter;

end



---

-- Zerstort eine Markierung auf der Minimap.

-- 

-- @param[type=number] _ID ID des Markers

-- @within Internal

-- @local

--

function BundleMinimapMarker.Global:DestroyMinimapMarker(_ID)

    self.Data.CreatedMinimapMarkers[_ID] = nil;

    info("BundleMinimapMarker: Destroy minimap marker " .._ID);

    Logic.ExecuteInLuaLocalState([[GUI.DestroyMinimapSignal(]] .._ID.. [[)]]);

end



---

-- Zeigt eine erstellte Markierung auf der Minimap an.

-- 

-- @param[type=number] _ID ID des Markers

-- @within Internal

-- @local

--

function BundleMinimapMarker.Global:ShowMinimapMarker(_ID)

    if not self.Data.CreatedMinimapMarkers[_ID] then

        return;

    end

    local Marker = self.Data.CreatedMinimapMarkers[_ID];



    local ColorOrPlayerID = Marker[1];

    if type(ColorOrPlayerID) == "table" then

        ColorOrPlayerID = API.ConvertTableToString(ColorOrPlayerID);

    end



    info("BundleMinimapMarker: Restoring minimap marker " .._ID);

    Logic.ExecuteInLuaLocalState([[

        BundleMinimapMarker.Local:ShowMinimapMarker(

            ]] .._ID.. [[,]] ..ColorOrPlayerID.. [[,]] ..Marker[2].. [[,]] ..Marker[3].. [[, ]] ..Marker[4].. [[

        )

    ]]);

end



---

-- Stellt Markierungen auf der Minimap wieder her, wenn ein Spielstand

-- geladen wird.

-- 

-- @within Internal

-- @local

--

function BundleMinimapMarker.Global.OnSaveGameLoaded()

    for k, v in pairs(BundleMinimapMarker.Global.Data.CreatedMinimapMarkers) do

        if v and v[4] ~= 7 then

            BundleMinimapMarker.Global:ShowMinimapMarker(k);

        end

    end

end



-- Local Script ------------------------------------------------------------- --



---

-- Initialisiert das Bundle im globalen Skript.

-- @within Internal

-- @local

--

function BundleMinimapMarker.Local:Install()

end



---

-- Initialisiert das Bundle im globalen Skript.

--

-- @param[type=number] _PlayerID ID des Besitzers

-- @param[type=number] _X X-Koordinate des Markers

-- @param[type=number] _Y Y-Koordinate des Makers

-- @param[type=number] _Type Typ des Markers

-- @return[type=number] ID des Markers

-- @within Internal

-- @local

--

function BundleMinimapMarker.Local:ShowMinimapMarker(_ID, _PlayerID, _X, _Y, _Type)

    local R, G, B;

    if type(_PlayerID) == "number" then

        R, G, B = GUI.GetPlayerColor(_PlayerID);

    else

        R = _PlayerID[1];

        G = _PlayerID[2];

        B = _PlayerID[3];

    end

    GUI.CreateMinimapSignalRGBA(_ID, _X, _Y, R, G, B, 255, _Type);

end



-- -------------------------------------------------------------------------- --



Core:RegisterBundle("BundleMinimapMarker");



-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleNonPlayerCharacter                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle wird ein spezieller Modus für Nichtspieler-Charaktere
-- bereitgestellt. Die Helden eines Spielers können mit diesen NPCs sprechen.
-- Dazu muss der Held selektiert sein. Dann kann der Spieler ihm mit einem
-- Rechtsklick befehlen, den NPC anzusprechen. Dabei wird der Mauszeiger zu
-- einer Hand.
--
-- Ein NPC wird durch ein leichtes Glitzern auf der Spielwelt hervorgehoben.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleNonPlayerCharacter = {};

API = API or {};
QSB = QSB or {};

QSB.NonPlayerCharacterObjects = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt einen neuen NPC für den angegebenen Siedler.
--
-- Der NPC wird sofort aktiviert und kann angesprochen werden. Er wird durch
-- eine glitzernde Aura hervorgehoben.
--
-- Mögliche Einstellungen für den NPC:
-- <table border="1">
-- <tr>
-- <th><b>Eigenschaft</b></th>
-- <th><b>Beschreibung</b></th>
-- </tr>
-- <tr>
-- <td>Name</td>
-- <td>Stringname des Siedlers, der zum NPC werden soll.</td>
-- </tr>
-- <tr>
-- <td>Hero</td>
-- <td>Skriptname eines Helden, mit dem der NPC sprechen will.</td>
-- </tr>
-- <tr>
-- <td>WrongHeroMessage</td>
-- <td>Eine optionale Nachricht, wenn der falsche Held angesprochen wird.</td>
-- </tr>
-- <tr>
-- <td>Callback</td>
-- <td>Eine Funktion, die aufgerufen wird, wenn der NPC angesprochen wird.</td>
-- </tr>
-- <tr>
-- <td>Reposition</td>
-- <td>Standardmäßig aktiv. Schaltet die Neupositionierung und Neuausrichtung
-- der Charaktere an/aus.</td>
-- </tr>
-- </table>
--
-- <p><b>Alias:</b> CreateNPC</p>
--
-- @param[type=table] _Data Nichtspieler-Charakter
-- @return[type=table] NonPlayerCharacter Objekt
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcCompose {
--     Name     = "horst",
--     Callback = function(_Npc, _Hero)
--        -- Hier kann was passieren
--     end,
-- }
--
function API.NpcCompose(_Data)
    local WronHeroCallback = function(_Npc)
        if _Npc.WrongHeroMessage then
            API.Note(_Npc.WrongHeroMessage);
        end
    end

    local NPC = QSB.NonPlayerCharacter:New(_Data.Name);
    NPC:SetDialogPartner(_Data.Hero);
    NPC:SetWrongPartnerCallback(WronHeroCallback);
    NPC:SetCallback(_Data.Callback);
    NPC:SetType(_Data.Type or 1);
    if  BundleNonPlayerCharacter.Global.UseRepositionByDefault
    and _Data.Reposition == nil then
        _Data.Reposition = true;
    end
    NPC:SetRepositionOnAction(_Data.Reposition);
    return NPC:Activate();
end
CreateNPC = API.NpcCompose;

---
-- Entfernt den NPC komplett vom Entity. Das Entity bleibt dabei erhalten.
--
-- <p><b>Alias:</b> DestroyNPC</p>
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcDispose("horst")
--
function API.NpcDispose(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    NPC:Dispose();
end
DestroyNPC = API.NpcDispose;

---
-- Aktiviert einen inaktiven NPC. Wenn ein NPC bereits gesprochen hat, muss
-- er zuvor zurückgesetzt werden.
--
-- <p><b>Alias:</b> EnableNPC</P>
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcActivate("horst")
--
function API.NpcActivate(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    NPC:Activate();
end
EnableNPC = API.NpcActivate;

---
-- Deaktiviert einen NPC, sodass dieser nicht angesprochen werden kann.
--
-- <p><b>Alias:</b> DisableNPC</P>
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcDeactivate("horst")
--
function API.NpcDeactivate(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    NPC:Deactivate();
end
DisableNPC = API.NpcDeactivate;

---
-- Setzt einen NPC zurück, sodass er nicht mehr als angesprochen gilt.
--
-- <p><b>Alias:</b> ResetNPC<p>
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcReset("horst")
--
function API.NpcReset(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    NPC:Reset();
end
ResetNPC = API.NpcReset;

---
-- Prüft, ob der NPC bereits angesprochen wurde. Wenn ein Ansprechpartner
-- vorgegeben ist, muss dieser den NPC ansprechen.
--
-- <p><b>Alias:</b> TalkedToNPC</p>
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @return[type=boolean] NPC wurde angesprochen
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcHasSpoken("horst")
--
function API.NpcHasSpoken(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    return NPC:HasTalkedTo();
end
TalkedToNPC = API.NpcHasSpoken;

---
-- Setzt die Repositionierung von Charakteren per Default aktiv oder inaktiv.
-- Der Default wird verwendet, wenn nicht explizit im NPC angegeben.
--
-- @param[type=boolean] _Flag Repositionierung an/aus
-- @within Anwenderfunktionen
--
function API.SetUseRepositionByDefault(_Flag)
    BundleNonPlayerCharacter.Global.UseRepositionByDefault = _Flag == true;
end

-- -------------------------------------------------------------------------- --
-- Klassen                                                                    --
-- -------------------------------------------------------------------------- --

QSB.NonPlayerCharacter = {};

---
-- Konstruktor
-- @param[type=string] _ScriptName Skriptname des NPC
-- @within QSB.NonPlayerCharacter
-- @local
-- @usage
-- -- Einen normalen NPC erzeugen:
-- QSB.NonPlayerCharacter:New("npc")
--     :SetDialogPartner("hero")                 -- Optional
--     :SetCallback(Briefing1)                   -- Optional
--     :Activate();
--
function QSB.NonPlayerCharacter:New(_ScriptName)
    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');
    local npc = API.InstanceTable(self);
    npc.m_NpcName  = _ScriptName;
    npc.m_NpcType  = BundleNonPlayerCharacter.Global.DefaultNpcType
    npc.m_Distance = 350;
    if Logic.IsKnight(GetID(_ScriptName)) then
        npc.m_Distance = 400;
    end
    QSB.NonPlayerCharacterObjects[_ScriptName] = npc;
    npc:CreateMarker();
    return npc;
end

---
-- Gibt das Objekt des NPC zurück, wenn denn eins für dieses Entity existiert.
--
-- Wurde noch kein NPC für diesen Skriptnamen erzeugt, wird nil zurückgegeben.
--
-- @param[type=string] _ScriptName Skriptname des NPC
-- @return[type=table] Interaktives Objekt
-- @within QSB.NonPlayerCharacter
-- @local
-- @usage -- NPC ermitteln
-- local NPC = QSB.NonPlayerCharacter:GetInstance("horst");
-- -- Etwas mit dem NPC tun
-- NPC:SetDialogPartner("hilda");
--
function QSB.NonPlayerCharacter:GetInstance(_ScriptName)
    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');
    local EntityID = GetID(_ScriptName)
    local ScriptName = Logic.GetEntityName(EntityID);
    if Logic.IsEntityInCategory(EntityID, EntityCategories.Soldier) == 1 then
        local LeaderID = Logic.SoldierGetLeaderEntityID(EntityID);
        if IsExisting(LeaderID) then
            ScriptName = Logic.GetEntityName(LeaderID);
        end
    end
    return QSB.NonPlayerCharacterObjects[ScriptName];
end

---
-- Gibt die Entity ID des letzten angesprochenen NPC zurück.
--
-- @return[type=number] ID des letzten NPC
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:GetNpcId()
    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');
    return BundleNonPlayerCharacter.Global.LastNpcEntityID;
end

---
-- Gibt die Entity ID des letzten Helden zurück, der einen NPC
-- angesprochen hat.
--
-- @return[type=number] ID des letzten Heden
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:GetHeroId()
    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');
    return BundleNonPlayerCharacter.Global.LastHeroEntityID;
end

---
-- Gibt die Entity ID des NPC zurück. Ist der NPC ein Leader, wird
-- der erste Soldat zurückgegeben, wenn es einen gibt.
--
-- @return[type=number] ID des NPC
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:GetID()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    local EntityID = GetID(self.m_NpcName);
    if Logic.IsEntityInCategory(EntityID, EntityCategories.Leader) == 1 then
        local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntityID)};
        if Soldiers[1] > 0 then
            return Soldiers[2];
        end
    end
    return EntityID
end

---
-- Löscht einen NPC.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
-- @usage -- NPC löschen
-- NPC:Dispose();
--
function QSB.NonPlayerCharacter:Dispose()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self:Deactivate();
    self:DestroyMarker();
    QSB.NonPlayerCharacterObjects[self.m_NpcName] = nil;
end

---
-- Aktiviert einen inaktiven NPC, sodass er wieder angesprochen werden kann.
--
-- @param[type=number] _Type NPC-Typ [1-4]
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
-- @local
-- @usage -- NPC aktivieren:
-- NPC:Activate();
--
function QSB.NonPlayerCharacter:Activate(_Type)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if IsExisting(self.m_NpcName) then
        Logic.SetOnScreenInformation(self:GetID(), _Type or self.m_NpcType);
        self:ShowMarker();
    end
    return self;
end

---
-- Deaktiviert einen aktiven NPC, sodass er nicht angesprochen werden kann.
--
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
-- @local
-- @usage -- NPC deaktivieren:
-- NPC:Deactivate();
--
function QSB.NonPlayerCharacter:Deactivate()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if IsExisting(self.m_NpcName) then
        Logic.SetOnScreenInformation(self:GetID(), 0);
        self:HideMarker();
    end
    return self;
end

---
-- <p>Gibt true zurück, wenn der NPC aktiv ist.</p>
--
-- @return[type=boolean] NPC ist aktiv
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:IsActive()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    return Logic.GetEntityScriptingValue(self:GetID(), 6) > 0;
end

---
-- Setzt den NPC zurück, sodass er erneut aktiviert werden kann.
--
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:Reset()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if IsExisting(self.m_NpcName) then
        Logic.SetOnScreenInformation(self:GetID(), 0);
        self.m_TalkedTo = nil;
        self:HideMarker();
    end
    return self;
end

---
-- Gibt true zurück, wenn der NPC angesprochen wurde. Ist ein
-- spezieller Ansprechpartner definiert, wird nur dann true
-- zurückgegeben, wenn dieser Held mit dem NPC spricht.
--
-- @return[type=boolean] NPC wurde angesprochen
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:HasTalkedTo()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if self.m_HeroName then
        return self.m_TalkedTo == GetID(self.m_HeroName);
    end
    return self.m_TalkedTo ~= nil;
end

---
-- Gibt die Entity ID des letzten angesprochenen NPC zurück.
--
-- @param[type=number] _Type Typ des Npc
-- @return[type=number] ID des letzten NPC
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:SetType(_Type)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self.m_NpcType = _Type;
    if _Type > 1 then
        self:HideMarker();
    end
    return self;
end

function QSB.NonPlayerCharacter:SetRepositionOnAction(_Flag)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self.m_RepositionOnAction = _Flag == true;
    return self;
end

---
-- Setzt die Entfernung, die unterschritten werden muss, damit
-- ein NPC als angesprochen gilt.
--
-- @param[type=number] _Distance Aktivierungsdistanz
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:SetTalkDistance(_Distance)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self.m_Distance = _Distance or 350;
    return self;
end

---
-- Setzt den Ansprechpartner für diesen NPC.
--
-- @param[type=string] _HeroName Skriptname des Helden
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:SetDialogPartner(_HeroName)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self.m_HeroName = _HeroName;
    return self;
end

---
-- Setzt das Callback für den Fall, dass ein falscher Held den
-- NPC anspricht.
--
-- @param[type=function] _Callback Callback
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:SetWrongPartnerCallback(_Callback)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self.m_WrongHeroCallback = _Callback;
    return self;
end

---
-- Setzt das Callback des NPC, dass beim Ansprechen ausgeführt wird.
--
-- @param[type=function] _Callback Callback
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:SetCallback(_Callback)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    assert(type(_Callback) == "function", 'callback must be a function!');
    self.m_Callback = _Callback;
    return self;
end

---
-- Rotiert alle nahen Helden zum NPC und den NPC zu dem Helden,
-- der ihn angesprochen hat.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:RotateActors()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if self.m_RepositionOnAction == false then
        return;
    end
    local PlayerID = Logic.EntityGetPlayer(BundleNonPlayerCharacter.Global.LastHeroEntityID);
    local PlayerKnights = {};
    Logic.GetKnights(PlayerID, PlayerKnights);
    for k, v in pairs(PlayerKnights) do
        -- Alle Helden stoppen, die sich zu NPC bewegen
        local SV = QSB.ScriptingValues[QSB.ScriptingValues.Game].Destination.X;
        local x1 = math.floor(Core:ScriptingValueIntegerToFloat(Logic.GetEntityScriptingValue(v, SV)));
        local SV = QSB.ScriptingValues[QSB.ScriptingValues.Game].Destination.Y;
        local y1 = math.floor(Core:ScriptingValueIntegerToFloat(Logic.GetEntityScriptingValue(v, SV)));
        local x2, y2 = Logic.EntityGetPos(GetID(self.m_NpcName));
        if x1 == math.floor(x2) and y1 == math.floor(y2) then
            local x, y, z = Logic.EntityGetPos(v);
            Logic.MoveEntity(v, x, y);
            LookAt(v, self.m_NpcName);
        end
    end
    API.Confront(self.m_NpcName, BundleNonPlayerCharacter.Global.LastHeroEntityID)
end

---
-- Setzt den Helden, der den NPC angesprochen hat, auf eine Position, die
-- in der richtigen Entfernung zum NPC ist.
--
-- <b>Hinweis</b>: Dies ist ein temporärer Fix für das Kollisionsproblem.
-- Sobald eine bessere Lösung zur Verfügung steht, sollte diese Methode
-- wieder entfernt werden!
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:RepositionHero()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if self.m_RepositionOnAction == false then
        return;
    end
    local HeroID = BundleNonPlayerCharacter.Global.LastHeroEntityID;
    local NPCID  = GetID(self.m_NpcName);
    if GetDistance(HeroID, NPCID) < self.m_Distance -50 then
        -- Position des NPC bestimmen
        local Orientation = Logic.GetEntityOrientation(NPCID);
        local x1, y1, z1 = Logic.EntityGetPos(NPCID);
        -- Relative Position bestimmen
        local x2 = x1 + (self.m_Distance * math.cos(math.rad(Orientation)));
        local y2 = y1 + (self.m_Distance * math.sin(math.rad(Orientation)));
        -- Nächste erreichbare Position bei Punkt bestimmen
        local ID = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, x2, y2, 0, 0);
        local x3, y3, z3 = Logic.EntityGetPos(ID);
        -- Held neu positionieren
        Logic.MoveSettler(HeroID, x3, y3);
        StartSimpleHiResJobEx( function(_HeroID, _NPCID)
            if Logic.IsEntityMoving(_HeroID) == false then
                API.Confront(_HeroID, _NPCID);
                return true;
            end
        end, HeroID, NPCID);
    end
end

---
-- Erzeugt das Entity des NPC-Markers.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:CreateMarker()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    local x,y,z = Logic.EntityGetPos(self:GetID());
    local MarkerID = Logic.CreateEntity(Entities.XD_ScriptEntity, x, y, 0, 0);
    DestroyEntity(self.m_MarkerID);
    self.m_MarkerID = MarkerID;
    self:HideMarker();
    return self;
end

---
-- Entfernt das Entity des NPC-Markers.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:DestroyMarker()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if self.m_MarkerID then
        DestroyEntity(self.m_MarkerID);
        self.m_MarkerID = nil;
    end
    return self;
end

---
-- Zeigt den NPC-Marker des NPC an.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:ShowMarker()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if self.m_NpcType == 1 and IsExisting(self.m_MarkerID) then
        local SV = QSB.ScriptingValues[QSB.ScriptingValues.Game].Size;
        local EntityScale = Logic.GetEntityScriptingValue(self:GetID(), SV);
        Logic.SetEntityScriptingValue(self.m_MarkerID, SV, EntityScale);
        Logic.SetModel(self.m_MarkerID, Models.Effects_E_Wealth);
        Logic.SetVisible(self.m_MarkerID, true);
    end
    self.m_MarkerVisibility = true;
    return self;
end

---
-- Versteckt den NPC-Marker des NPC.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:HideMarker()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if IsExisting(self.m_MarkerID) then
        Logic.SetModel(self.m_MarkerID, Models.Effects_E_NullFX);
        Logic.SetVisible(self.m_MarkerID, false);
    end
    self.m_MarkerVisibility = false;
    return self;
end

---
-- Gibt true zurück, wenn der Marker des NPC sichtbar ist.
--
-- @return[type=boolen] Sichtbarkeit
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:IsMarkerVisible()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    return IsExisting(self.m_MarkerID) and self.m_MarkerVisibility == true;
end

---
-- Kontrolliert die Sichtbarkeit und die Position des NPC-Markers.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:ControlMarker()
    -- Nur, wenn Standard-NPC
    if self.m_NpcType == 1 then
        if self:IsActive() and not self:HasTalkedTo() then
            -- Blinken
            if self:IsMarkerVisible() then
                self:HideMarker();
            else
                self:ShowMarker();
            end

            -- Repositionierung
            local x1,y1,z1 = Logic.EntityGetPos(self.m_MarkerID);
            local x2,y2,z2 = Logic.EntityGetPos(self:GetID());
            if math.abs(x1-x2) > 20 or math.abs(y1-y2) > 20 then
                Logic.DEBUG_SetPosition(self.m_MarkerID, x2, y2);
            end
        end
        -- Während Briefings immer verstecken
        if IsBriefingActive and IsBriefingActive() then
            self:HideMarker();
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleNonPlayerCharacter = {
    Global = {
        LastNpcEntityID = 0,
        LastHeroEntityID = 0,
        DefaultNpcType = 1,
        UseRepositionByDefault = true,
    },
    Local = {}
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global:Install()
    -- NPC stuff --

    StartSimpleJob("BundleNonPlayerCharacter_ControlMarkerJob");
    StartSimpleHiResJob("BundleNonPlayerCharacter_DialogTriggerJob");

    GameCallback_OnNPCInteraction_Orig_QSB_NPC_Rewrite = GameCallback_OnNPCInteraction
    GameCallback_OnNPCInteraction = function(_EntityID, _PlayerID)
        GameCallback_OnNPCInteraction_Orig_QSB_NPC_Rewrite(_EntityID, _PlayerID)
        Quest_OnNPCInteraction(_EntityID, _PlayerID)
    end

    Quest_OnNPCInteraction = function(_EntityID, _PlayerID)
        local KnightIDs = {};
        Logic.GetKnights(_PlayerID, KnightIDs);

        local ClosestKnightID = 0;
        local ClosestKnightDistance = Logic.WorldGetSize();
        for i= 1, #KnightIDs, 1 do
            local DistanceBetween = Logic.GetDistanceBetweenEntities(KnightIDs[i], _EntityID);
            if DistanceBetween < ClosestKnightDistance then
                ClosestKnightDistance = DistanceBetween;
                ClosestKnightID = KnightIDs[i];
            end
        end
        BundleNonPlayerCharacter.Global.LastHeroEntityID = ClosestKnightID;
        local NPC = QSB.NonPlayerCharacter:GetInstance(_EntityID);
        BundleNonPlayerCharacter.Global.LastNpcEntityID = NPC:GetID();

        if NPC then
            NPC:RotateActors();
            NPC:RepositionHero();
            NPC.m_TalkedTo = ClosestKnightID;
            if NPC:HasTalkedTo() then
                NPC:Deactivate();
                if NPC.m_Callback then
                    NPC.m_Callback(NPC, ClosestKnightID);
                end
            else
                if NPC.m_WrongHeroCallback then
                    NPC.m_WrongHeroCallback(NPC, ClosestKnightID);
                end
            end
        end
    end

    -- Quest stuff --

    QuestTemplate.RemoveQuestMarkers_Orig_BundleNonPlayerCharacter = QuestTemplate.RemoveQuestMarkers
    QuestTemplate.RemoveQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[1] ~= -65565 then
                    QuestTemplate.RemoveQuestMarkers_Orig_BundleNonPlayerCharacter(self);
                else
                    QuestTemplate.RemoveNPCMarkers(self);
                end
            else
                QuestTemplate.RemoveQuestMarkers_Orig_BundleNonPlayerCharacter(self);
            end
        end
    end

    QuestTemplate.ShowQuestMarkers_Orig_BundleNonPlayerCharacter = QuestTemplate.ShowQuestMarkers
    QuestTemplate.ShowQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[1] ~= -65565 then
                    QuestTemplate.ShowQuestMarkers_Orig_BundleNonPlayerCharacter(self);
                end
            end
        end
    end

    function QuestTemplate:RemoveNPCMarkers()
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[1] == -65565 then
                    if self.Objectives[i].Data[4] and self.Objectives[i].Data[4].NpcInstance then
                        self.Objectives[i].Data[4].NpcInstance:Dispose();
                        self.Objectives[i].Data[4].NpcInstance = nil;
                    end
                end
            end
        end
    end

    QuestTemplate.IsObjectiveCompleted_Orig_BundleNonPlayerCharacter = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        local data = objective.Data;
        if objective.Completed ~= nil then
            return objective.Completed;
        end

        if objectiveType ~= Objective.Distance then
            return self:IsObjectiveCompleted_Orig_BundleNonPlayerCharacter(objective);
        else
            if data[1] == -65565 then
                if not IsExisting(data[3]) then
                    error(data[3].. " is dead! :(");
                    objective.Completed = false;
                else
                    if not data[4].NpcInstance then
                        local NPC = QSB.NonPlayerCharacter:New(data[3]);
                        NPC:SetDialogPartner(data[2]);
                        data[4].NpcInstance = NPC;
                    end
                    if data[4].NpcInstance:HasTalkedTo(data[2]) then
                        objective.Completed = true;
                    end
                    if not objective.Completed then
                        if not data[4].NpcInstance:IsActive() then
                            data[4].NpcInstance:Activate();
                        end
                    end
                end
            else
                return self:IsObjectiveCompleted_Orig_BundleNonPlayerCharacter(objective);
            end
        end
    end
end

---
-- Setzt den Standardtypen des NPC. Der Typ gibt an, ob Glitter verwendet wird
-- oder auf die NPC-Marker zurückgegriffen wird.
--
-- @param[type=number] _Type Typ des NPC [1-4]
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global:SetDefaultNPCType(_Type)
    self.DefaultNpcType = _Type;
end

---
-- Setzt die Repositionierung von Charakteren per Default aktiv oder inaktiv.
-- Der Default wird verwendet, wenn nicht explizit im NPC angegeben.
--
-- @param[type=boolean] _Flag Repositionierung an/aus
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global:SetUseRepositionByDefault(_Flag)
    self.UseRepositionByDefault = _Flag == true;
end

---
-- Gibt die ID des kontrollierenden Spielers zurück.
-- 
-- @return[type=number] Kontrollierender Spieler
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global:GetControllingPlayer()
    return QSB.HumanPlayerID;
end

---
-- Kontrolliert die "Glitter Marker" der NPCs.
--
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global.ControlMarker()
    for k, v in pairs(QSB.NonPlayerCharacterObjects) do
        if IsExisting(v:GetID()) then
            v:ControlMarker();
        end
    end
end
BundleNonPlayerCharacter_ControlMarkerJob = BundleNonPlayerCharacter.Global.ControlMarker;

---
-- Prüft, ob ein NPC durch die emulierte Aktivierungsdistanz angesprochen
-- wird. Die Bedingung wird für alle NPCs geprüft. Der erste NPC, der
-- die Bedingung erfüllt, wird aktiviert.
--
-- Der Job prüft nur NPCs, deren Aktivierungsdistanz 350 oder höher ist.
--
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global.DialogTriggerController()
    local PlayerID = BundleNonPlayerCharacter.Global:GetControllingPlayer();
    local PlayersKnights = {};
    Logic.GetKnights(PlayerID, PlayersKnights);
    for i= 1, #PlayersKnights, 1 do
        if Logic.GetCurrentTaskList(PlayersKnights[i]) == "TL_NPC_INTERACTION" then
            for k, v in pairs(QSB.NonPlayerCharacterObjects) do
                if v and v.m_TalkedTo == nil and v.m_Distance >= 350 then
                    local SV = QSB.ScriptingValues[QSB.ScriptingValues.Game].Destination.X;
                    local x1 = math.floor(Core:ScriptingValueIntegerToFloat(Logic.GetEntityScriptingValue(PlayersKnights[i], SV)));
                    local SV = QSB.ScriptingValues[QSB.ScriptingValues.Game].Destination.Y;
                    local y1 = math.floor(Core:ScriptingValueIntegerToFloat(Logic.GetEntityScriptingValue(PlayersKnights[i], SV)));
                    local x2, y2 = Logic.EntityGetPos(GetID(k));
                    if x1 == math.floor(x2) and y1 == math.floor(y2) then
                        if IsExisting(k) and IsNear(PlayersKnights[i], k, v.m_Distance) then
                            GameCallback_OnNPCInteraction(GetID(k), PlayerID);
                            return;
                        end
                    end
                end
            end
        end
    end
end
BundleNonPlayerCharacter_DialogTriggerJob = BundleNonPlayerCharacter.Global.DialogTriggerController;

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Local:Install()
    g_CurrentDisplayedQuestID = 0;

    GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter = GUI_Interaction.DisplayQuestObjective
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local QuestIndexTemp = tonumber(_QuestIndex);
        if QuestIndexTemp then
            _QuestIndex = QuestIndexTemp;
        end

        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
        local QuestObjectiveContainer;
        local QuestTypeCaption;

        local ParentQuest = Quests[_QuestIndex];
        local ParentQuestIdentifier;
        if ParentQuest ~= nil
        and type(ParentQuest) == "table" then
            ParentQuestIdentifier = ParentQuest.Identifier;
        end
        local HookTable = {};

        g_CurrentDisplayedQuestID = _QuestIndex;

        if QuestType == Objective.Distance then
            QuestObjectiveContainer = QuestObjectivesPath .. "/List";
            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction");
            local ObjectList = {};

            if Quest.Objectives[1].Data[1] == -65565 then
                QuestObjectiveContainer = QuestObjectivesPath .. "/Distance";
                QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestMoveHere");
                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{7,10});

                local MoverEntityID = GetEntityId(Quest.Objectives[1].Data[2]);
                local MoverEntityType = Logic.GetEntityType(MoverEntityID);
                local MoverIcon = g_TexturePositions.Entities[MoverEntityType];
                if not MoverIcon then
                    MoverIcon = {7, 9};
                end
                SetIcon(QuestObjectiveContainer .. "/IconMover", MoverIcon);

                local TargetEntityID = GetEntityId(Quest.Objectives[1].Data[3]);
                local TargetEntityType = Logic.GetEntityType(TargetEntityID);
                local TargetIcon = g_TexturePositions.Entities[TargetEntityType];
                if not TargetIcon then
                    TargetIcon = {14, 10};
                end

                local IconWidget = QuestObjectiveContainer .. "/IconTarget";
                local ColorWidget = QuestObjectiveContainer .. "/TargetPlayerColor";

                SetIcon(IconWidget, TargetIcon);
                XGUIEng.SetMaterialColor(ColorWidget, 0, 255, 255, 255, 0);

                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{16,12});
                local caption = {
                    de = "Gespräch beginnen",
                    en = "Start conversation",
                };
                QuestTypeCaption = API.Localize(caption);

                XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);
                XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
            else
                GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter(_QuestIndex, _MessageKey);
            end
        else
            GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter(_QuestIndex, _MessageKey);
        end
    end

    GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter = GUI_Interaction.GetEntitiesOrTerritoryListForQuest
    GUI_Interaction.GetEntitiesOrTerritoryListForQuest = function( _Quest, _QuestType )
        local EntityOrTerritoryList = {}
        local IsEntity = true

        if _QuestType == Objective.Distance then
            if _Quest.Objectives[1].Data[1] == -65565 then
                local Entity = GetEntityId(_Quest.Objectives[1].Data[3]);
                table.insert(EntityOrTerritoryList, Entity);
            else
                return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter( _Quest, _QuestType );
            end

        else
            return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter( _Quest, _QuestType );
        end
        return EntityOrTerritoryList, IsEntity
    end
end

Core:RegisterBundle("BundleNonPlayerCharacter");

-- -------------------------------------------------------------------------- --
-- Behavior                                                                   --
-- -------------------------------------------------------------------------- --

---
-- Der Held muss einen Nichtspielercharakter ansprechen.
--
-- Es wird automatisch ein NPC erzeugt und überwacht, sobald der Quest
-- aktiviert wurde. Ein NPC darf nicht auf geblocktem Gebiet stehen oder
-- seine Enity-ID verändern.
--
-- <b>Hinweis</b>: Jeder Siedler kann zu jedem Zeitpunkt nur <u>einen</u> NPC 
-- haben. Wird ein weiterer NPC zugewiesen, wird der alte überschrieben und
-- der verknüpfte Quest funktioniert nicht mehr!
--
-- @param[type=string] _NpcName  Skriptname des NPC
-- @param[type=string] _HeroName (optional) Skriptname des Helden
-- @within Goal
--
function Goal_NPC(...)
    return b_Goal_NPC:new(...);
end

b_Goal_NPC = {
    Name             = "Goal_NPC",
    Description     = {
        en = "Goal: The hero has to talk to a non-player character.",
        de = "Ziel: Der Held muss einen Nichtspielercharakter ansprechen.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "NPC",  de = "NPC" },
        { ParameterType.ScriptName, en = "Hero", de = "Held" },
    },
}

function b_Goal_NPC:GetGoalTable(_Quest)
    return {Objective.Distance, -65565, self.Hero, self.NPC, self}
end

function b_Goal_NPC:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.NPC = _Parameter
    elseif (_Index == 1) then
        self.Hero = _Parameter
        if self.Hero == "-" then
            self.Hero = nil
        end
   end
end

function b_Goal_NPC:GetIcon()
    return {14,10}
end

Core:RegisterBehavior(b_Goal_NPC);

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundlePlayerHelperFunctions                                   # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle kommen einige Funktionalitäten zur Steuerung von
-- spielerbezogenen Features.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundlePlayerHelperFunctions = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Setzt die Einnahmen für alle Stadtgebäude eines Spielers. Stadtgebäude
-- können nur Einnahmen zwischen 0 und 100 Talern haben.
--
-- <p><b>Alias:</b> SetPlayerEarnings</p>
--
-- @param[type=number] _PlayerID Partei oder nil für alle
-- @param[type=number] _Earnings Einnahmen [0 | 100]
-- @within Anwenderfunktionen
--
function API.SetEarningsOfPlayerCity(_PlayerID, _Earnings)
    if GUI then
        return;
    end
    if _PlayerID ~= -1 and Logic.GetStoreHouse(_PlayerID) == 0 then
        log("API.SetEarningsOfPlayerCity: Player " ..tostring(_PlayerID).. " is dead! :(", LEVEL_ERROR);
        return;
    end
    if _Earnings == nil or (_Earnings < 0 or _Earnings > 100) then
        log("API.SetEarningsOfPlayerCity: _Earnings must be between 0 and 100!", LEVEL_ERROR);
        return;
    end
    return BundlePlayerHelperFunctions.Global:SetEarningsOfPlayerCity(_PlayerID, _Earnings);
end
SetPlayerEarnings = API.SetEarningsOfPlayerCity;

---
-- Setzt den Befriedigungsstatus eines Bedürfnisses für alle Gebäude
-- des angegebenen Spielers. Der Befriedigungsstatus ist eine Zahl
-- zwischen 0.0 und 1.0.
--
-- <p><b>Alias:</b> SetNeedSatisfactionLevel</p>
--
-- @param[type=number] _Need Bedürfnis
-- @param[type=number] _State Erfüllung des Bedürfnisses
-- @param[type=number] _PlayerID Partei oder -1 für alle
-- @within Anwenderfunktionen
--
function API.SetNeedSatisfaction(_Need, _State, _PlayerID)
    if GUI then
        return;
    end
    if _PlayerID ~= -1 and Logic.GetStoreHouse(_PlayerID) == 0 then
        log("API.SetNeedSatisfaction: Player " ..tostring(_PlayerID).. " is dead! :(", LEVEL_ERROR);
        return;
    end
    if _State < 0 or _State > 1 then
        log("API.SetNeedSatisfaction: _State must be between 0 and 1!", LEVEL_ERROR);
        return;
    end
    return BundlePlayerHelperFunctions.Global:SetNeedSatisfactionLevel(_Need, _State, _PlayerID);
end
SetNeedSatisfactionLevel = API.SetNeedSatisfaction;

---
-- Diese Funktion ermöglicht das sichere Entsperren eines gesperrten Titels.
--
-- <p><b>Alias:</b> UnlockTitleForPlayer</p>
--
-- @param[type=number] _PlayerID Zielpartei
-- @param[type=number] _KnightTitle Titel zum Entsperren
-- @within Anwenderfunktionen
--
function API.UnlockTitleForPlayer(_PlayerID, _KnightTitle)
    if GUI then
        return;
    end
    return BundlePlayerHelperFunctions.Global:UnlockTitleForPlayer(_PlayerID, _KnightTitle);
end
UnlockTitleForPlayer = API.UnlockTitleForPlayer;

---
-- Startet ein Fest für den Spieler. Ist dieser Typ von Fest für
-- den Spieler verboten, wird er automatisch erlaubt.
--
-- <p><b>Alias:</b> StartNormalFestival</p>
--
-- @param[type=number] _PlayerID Spieler
-- @within Anwenderfunktionen
--
function API.StartNormalFestival(_PlayerID)
    if GUI then
        return;
    end
    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, false);
    Logic.StartFestival(_PlayerID, 0);
end
StartNormalFestival = API.StartNormalFestival;

---
-- Startet ein Beförderungsfest für den Spieler. Ist dieser Typ
-- von Fest für den Spieler verboten, wird er automatisch erlaubt.
--
-- <p><b>Alias:</b> StartCityUpgradeFestival</p>
--
-- @param[type=number] _PlayerID Spieler
-- @within Anwenderfunktionen
--
function API.StartCityUpgradeFestival(_PlayerID)
    if GUI then
        return;
    end
    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 1, false);
    Logic.StartFestival(_PlayerID, 1);
end
StartCityUpgradeFestival = API.StartCityUpgradeFestival;

---
-- Verbietet ein normales Fest und sperrt die Technologie.
--
-- <p><b>Alias:</b> ForbidFestival</p>
--
-- @param[type=number] _PlayerID Spieler
-- @within Anwenderfunktionen
--
function API.ForbidFestival(_PlayerID)
    if GUI then
        return;
    end

    local KnightTitle = Logic.GetKnightTitle(_PlayerID)
    local Technology = Technologies.R_Festival;
    local State = TechnologyStates.Locked;
    if KnightTitleNeededForTechnology[Technology] == nil or KnightTitle >= KnightTitleNeededForTechnology[Technology] then
        State = TechnologyStates.Prohibited;
    end
    Logic.TechnologySetState(_PlayerID, Technology, State);
    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, true);
    Logic.ExecuteInLuaLocalState("BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[" .._PlayerID.. "] = true");
end
ForbidFestival = API.ForbidFestival;

---
-- Erlaubt ein normales Fest und gibt die Technologie frei.
--
-- <p><b>Alias:</b> AllowFestival</p>
--
-- @param[type=number] _PlayerID Spieler
-- @within Anwenderfunktionen
--
function API.AllowFestival(_PlayerID)
    if GUI then
        return;
    end

    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, false);
    local KnightTitle = Logic.GetKnightTitle(_PlayerID)
    local Technology = Technologies.R_Festival;
    local State = TechnologyStates.Unlocked;
    if KnightTitleNeededForTechnology[Technology] == nil or KnightTitle >= KnightTitleNeededForTechnology[Technology] then
        State = TechnologyStates.Researched;
    end
    Logic.TechnologySetState(_PlayerID, Technology, State);
    Logic.ExecuteInLuaLocalState("BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[" .._PlayerID.. "] = false");
end
AllowFestival = API.AllowFestival;

---
-- Wechselt die Spieler ID des menschlichen Spielers. Die neue ID muss
-- einen Primärritter haben. Diese Funktion kann nicht im Multiplayer
-- Mode verwendet werden.
--
-- <p><b>Alias:</b> PlayerSetPlayerID</p>
--
-- @param[type=number]  _OldID Alte ID des menschlichen Spielers
-- @param[type=number]  _NewID Neue ID des menschlichen Spielers
-- @param[type=string]  _NewName Name in der Statistik
-- @param[type=boolean] _RetainKnight Ritter mitnehmen
-- @within Anwenderfunktionen
--
function API.SetControllingPlayer(_OldID, _NewID, _NewName, _RetainKnight)
    if GUI then
        return;
    end
    if type(_OldID) ~= "number" or type(_NewID) ~= "number" or _OldID == _NewID 
    or _OldID < 1 or _OldID > 8 or _NewID < 1 or _NewID > 8 then
        error("API.SetControllingPlayer: Trying to change player " ..tostring(_OldID).. " to " ..tostring(_NewID).. " which is not possible!");
        return;
    end
    return BundlePlayerHelperFunctions.Global:SetControllingPlayer(_OldID, _NewID, _NewName, _RetainKnight);
end
PlayerSetPlayerID = API.SetControllingPlayer;

---
-- Gibt die ID des kontrollierenden Spielers zurück. Der erste als menschlich
-- definierte Spieler wird als kontrollierender Spieler angenommen.
--
-- <p><b>Alias:</b> PlayerGetPlayerID</p>
--
-- @return[type=number] PlayerID
-- @within Anwenderfunktionen
--
function API.GetControllingPlayer()
    if not GUI then
        return QSB.HumanPlayerID;
    else
        return GUI.GetPlayerID();
    end
end
PlayerGetPlayerID = API.GetControllingPlayer;

---
-- Prüft, ob der Spieler die Ware prinzipiell herstellen kann.
--
-- Für alle gewöhnlichen Waren werden die benötigten Technologien transitiv
-- abgefragt. Ein Bannermacher benötigt z.B. Wolle, also muss der Spieler
-- nicht nur Banner, sondern ebenfalls Wolle herstellen können dürfen.
--
-- <b>Achtung:</b> Spezialwaren, wie z.B. G_MedicineLadyHealing werden nicht
-- unterstützt. Luxusgüter können ebenfalls nicht hergestellt werden.
--
-- <b>Hinweis:</b> Über Skript ausgeblendete Buttons können nicht abgefangen
-- werden. Ebenso ausgeblendetes Baumenü!
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _GoodType Warentyp
-- @return[type=boolean] Ware kann produziert werden
-- @within Anwenderfunktionen
--
function API.CanPlayerProduceGood(_PlayerID, _GoodType)
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CanPlayerProduceGood: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return false;
    end
    local TypeName = GetNameOfKeyInTable(Goods, _GoodType);
    if TypeName == nil then
        error("API.CanPlayerProduceGood: _GoodType (" ..tostring(_GoodType).. ") is wrong!");
        return true;
    end
    return BundlePlayerHelperFunctions.Shared:CanPlayerProduceGoodInPrinciple(_PlayerID, _GoodType);
end

---
-- Prüft, ob der Spieler die Ware tatsächlich herstellen kann.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _GoodType Warentyp
-- @return[type=boolean] Ware kann produziert werden
-- @within Anwenderfunktionen
--
function API.CanPlayerCurrentlyProduceGood(_PlayerID, _GoodType)
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CanPlayerCurrentlyProduceGood: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return false;
    end
    local TypeName = GetNameOfKeyInTable(Goods, _GoodType);
    if TypeName == nil then
        warn("API.CanPlayerCurrentlyProduceGood: _GoodType (" ..tostring(_GoodType).. ") is wrong!");
        return false;
    end
    return BundlePlayerHelperFunctions.Shared:CanPlayerProduceGood(_PlayerID, _GoodType);
end

---
-- Gibt den Rohstoff zum Produkt am Anfang der Produktionskette zurück.
--
-- @param[type=number] _GoodType Warentyp
-- @return[type=number] Rohstoff
-- @within Anwenderfunktionen
--
function API.GetResourceOfProduct(_GoodType)
    local TypeName = GetNameOfKeyInTable(Goods, _GoodType);
    if TypeName == nil then
        error("API.GetResourceOfProduct: _GoodType (" ..tostring(_GoodType).. ") is wrong!");
        return true;
    end
    return BundlePlayerHelperFunctions.Shared:ProductToResource(_GoodType);
end

---
-- Prüft, ob der Spieler Zugang zum Rohstoff der angegebenen Ware hat.
--
-- @param[type=number]  _PlayerID ID des Spielers
-- @param[type=number]  _GoodType Warentyp
-- @param[type=boolean] _WithNeutral Entities auf neutralen Territorien zählen
-- @return[type=boolean] Resource ist vorhanden
-- @within Anwenderfunktionen
--
function API.HasPlayerAccessToResource(_PlayerID, _GoodType, _WithNeutral)
    if GUI then
        return false;
    end
    local TypeName = GetNameOfKeyInTable(Goods, _GoodType);
    if TypeName == nil then
        error("API.HasPlayerAccessToResource: _GoodType (" ..tostring(_GoodType).. ") is wrong!");
        return true;
    end
    local Amount, Results = BundlePlayerHelperFunctions.Shared:GetResourceEntitiesOfPlayerForGoodType(_PlayerID, _GoodType, _WithNeutral);
    return Amount == -1 or Amount > 0;
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundlePlayerHelperFunctions = {
    Global = {
        Data = {
            FestivalBlacklist = {},
            DiscoveredTerritories = {};
        }
    },
    Local = {
        Data = {
            NormalFestivalLockedForPlayer = {},
        }
    },
    Shared = {
        Data = {
            GoodsTechnologiesMap = {},
        }
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:Install()
    BundlePlayerHelperFunctions.Shared:CreateGoodsTechnologiesMap();
    BundlePlayerHelperFunctions.Shared:CreateProductToResourceMap();
    BundlePlayerHelperFunctions.Shared:CreateGoodsResourcesMap();
    self:InitFestival();
    API.AddSaveGameAction(BundlePlayerHelperFunctions.Global.OnSaveGameLoaded);
end

---
-- Überschreibt Logic.StartFestival, sodass das Feierverhalten der KI gesteuert
-- werden kann.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:InitFestival()
    Logic.StartFestival_Orig_NothingToCelebrate = Logic.StartFestival;
    Logic.StartFestival = function(_PlayerID, _Index)
        if BundlePlayerHelperFunctions.Global.Data.FestivalBlacklist[_PlayerID] then
            if BundlePlayerHelperFunctions.Global.Data.FestivalBlacklist[_PlayerID][_Index] then
                return;
            end
        end
        Logic.StartFestival_Orig_NothingToCelebrate(_PlayerID, _Index);
    end
end

---
-- Setzt die Einnahmen für alle Stadtgebäude eines Spielers. Stadtgebäude
-- können nur Einnahmen zwischen 0 und 100 Talern haben.
--
-- <b>Alias:</b> SetPlayerEarnings
--
-- @param[type=number] _PlayerID Partei oder nil für alle
-- @param[type=number] _Earnings Einnahmen [0 | 100]
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:SetEarningsOfPlayerCity(_PlayerID, _Earnings)
    if _PlayerID == -1 then
        for i=1, 8, 1 do
            self:SetEarningsOfPlayerCity(i, _Earnings);
        end
    else
        local City = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)};
        for i=1, #City, 1 do
            Logic.SetBuildingEarnings(City[i], _Earnings);
        end
    end
end

---
-- Setzt den Befriedigungsstatus eines Bedürfnisses für alle Gebäude
-- des angegebenen Spielers. Der Befriedigungsstatus ist eine Zahl
-- zwischen 0.0 und 1.0.
--
-- @param[type=number] _Need Bedürfnis
-- @param[type=number] _State Erfüllung des Bedürfnisses
-- @param[type=number] _PlayerID Partei oder -1 für alle
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:SetNeedSatisfactionLevel(_Need, _State, _PlayerID)
    if _PlayerID == -1 then
        for i=1, 8, 1 do
            self:SetNeedSatisfactionLevel(_Need, _State, i);
        end
    else
        local City = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)};
        if _Need == Needs.Nutrition or _Need == Needs.Medicine then
            local Rim = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.OuterRimBuilding)};
            City = Array_Append(City, Rim);
        end
        for j=1, #City, 1 do
            if Logic.IsNeedActive(City[j], _Need) then
                Logic.SetNeedState(City[j], _Need, _State);
            end
        end
    end
end

---
-- Entsperrt einen gesperrten Titel für den Spieler.
--
-- @param[type=number] _PlayerID Zielpartei
-- @param[type=number] _KnightTitle Titel zum Entsperren
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:UnlockTitleForPlayer(_PlayerID, _KnightTitle)
    if LockedKnightTitles[_PlayerID] == _KnightTitle
    then
        LockedKnightTitles[_PlayerID] = nil;
        for KnightTitle= _KnightTitle, #NeedsAndRightsByKnightTitle
        do
            local TechnologyTable = NeedsAndRightsByKnightTitle[KnightTitle][4];
            if TechnologyTable ~= nil
            then
                for i=1, #TechnologyTable
                do
                    local TechnologyType = TechnologyTable[i];
                    Logic.TechnologySetState(_PlayerID, TechnologyType, TechnologyStates.Unlocked);
                end
            end
        end
    end
end

---
-- Erlaubt oder verbietet ein Fest für den angegebenen Spieler.
--
-- @param[type=number]  _PlayerID ID des Spielers
-- @param[type=number]  _Index    Index des Fest
-- @param[type=boolean] _Flag     Erlauben/verbieten
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, _Index, _Flag)
    self.Data.FestivalBlacklist[_PlayerID] = self.Data.FestivalBlacklist[_PlayerID] or {};
    self.Data.FestivalBlacklist[_PlayerID][_Index] = _Flag == true;
end

---
-- Wechselt die Spieler ID des menschlichen Spielers. Die neue ID muss
-- einen Primärritter haben. Diese Funktion kann nicht im Multiplayer
-- Mode verwendet werden.
--
-- @param[type=number] _oldPlayerID Alte ID des menschlichen Spielers
-- @param[type=number] _newPlayerID Neue ID des menschlichen Spielers
-- @param[type=string] _newNameForStatistics Name in der Statistik
-- @param[type=boolean] _retainPrimaryKnight Ritter mitnehmen
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:SetControllingPlayer(_oldPlayerID, _newPlayerID, _newNameForStatistics, _retainPrimaryKnight)
    assert(type(_oldPlayerID) == "number");
    assert(type(_newPlayerID) == "number");
    _newNameForStatistics = _newNameForStatistics or "";
    _retainPrimaryKnight = (_retainPrimaryKnight and true) or false;

    local eID,eName,eType;
    if _retainPrimaryKnight then
        eID   = Logic.GetKnightID(_oldPlayerID);
        eName = Logic.GetEntityName(eID);
        eType = Logic.GetEntityType(eID);
        Logic.ChangeEntityPlayerID(eID,_newPlayerID);
        Logic.SetPrimaryKnightID(_newPlayerID,GetID(eName));
    else
        eID   = Logic.GetKnightID(_newPlayerID);
        eName = Logic.GetEntityName(eID);
        eType = Logic.GetEntityType(eID);
    end

    Logic.PlayerSetIsHumanFlag(_oldPlayerID, 0);
    Logic.PlayerSetIsHumanFlag(_newPlayerID, 1);
    Logic.PlayerSetGameStateToPlaying(_newPlayerID);

    self.Data.HumanKnightType = eType;
    self.Data.HumanPlayerID = _newPlayerID;
    QSB.HumanPlayerID = _newPlayerID;

    GameCallback_PlayerLost = function( _PlayerID )
        if _PlayerID == QSB.HumanPlayerID then
            QuestTemplate:TerminateEventsAndStuff()
            if MissionCallback_Player1Lost then
                MissionCallback_Player1Lost()
            end
        end
    end

    Logic.ExecuteInLuaLocalState([[
        GUI.ClearSelection()
        GUI.SetControlledPlayer(]].._newPlayerID..[[)
        QSB.HumanPlayerID = ]].._newPlayerID..[[;

        for k,v in pairs(Buffs)do
            GUI_Buffs.UpdateBuffsInInterface(]].._newPlayerID..[[,v)
            GUI.ResetMiniMap()
        end

        if IsExisting(Logic.GetKnightID(GUI.GetPlayerID())) then
            local portrait = GetKnightActor(]]..eType..[[)
            g_PlayerPortrait[GUI.GetPlayerID()] = portrait
            LocalSetKnightPicture()
        end

        local newName = "]].._newNameForStatistics..[["
        if newName ~= "" then
            GUI_MissionStatistic.PlayerNames[GUI.GetPlayerID()] = newName
        end
        HideOtherMenus()

        function GUI_Knight.GetTitleNameByTitleID(_KnightType, _TitleIndex)
            local KeyName = "Title_" .. GetNameOfKeyInTable(KnightTitles, _TitleIndex) .. "_" .. KnightGender[]]..eType..[[]
            local String = XGUIEng.GetStringTableText("UI_ObjectNames/" .. KeyName)
            if String == nil or String == "" then
                String = "Knight not in Gender Table? (localscript.lua)"
            end
            return String
        end
    ]]);

    self.Data.HumanPlayerChangedOnce = true;
end

---
-- Stellt nicht-persistente Änderungen nach dem laden wieder her.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global.OnSaveGameLoaded()
    -- Feste sperren --
    Logic.StartFestival_Orig_NothingToCelebrate = nil;
    BundlePlayerHelperFunctions.Global:InitFestival();

    -- Menschlichen Spieler ändern --
    if BundlePlayerHelperFunctions.Global.Data.HumanPlayerChangedOnce then
        Logic.ExecuteInLuaLocalState([[
            GUI.SetControlledPlayer(]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[)
            for k,v in pairs(Buffs)do
                GUI_Buffs.UpdateBuffsInInterface(]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[,v)
                GUI.ResetMiniMap()
            end
            if IsExisting(Logic.GetKnightID(GUI.GetPlayerID())) then
                local portrait = GetKnightActor(]]..BundlePlayerHelperFunctions.Global.Data.HumanKnightType..[[)
                g_PlayerPortrait[]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[] = portrait
                LocalSetKnightPicture()
            end
        ]]);
    end
end

-- Local Script ------------------------------------------------------------- --

function BundlePlayerHelperFunctions.Local:Install()
    BundlePlayerHelperFunctions.Shared:CreateGoodsTechnologiesMap();
    BundlePlayerHelperFunctions.Shared:CreateProductToResourceMap();
    BundlePlayerHelperFunctions.Shared:CreateGoodsResourcesMap();
    self:InitForbidFestival();
    self:OverrideQuestLogPlayerIcon();
    self:OverrideQuestPlayerIcon();
end

---
-- Überschreibt den Button zum Start eines Festes, sodass er nicht angezeigt
-- wird, wenn Feste verboten sind.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Local:InitForbidFestival()
    NewStartFestivalUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local PlayerID = GUI.GetPlayerID();
        if BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[PlayerID] then
            XGUIEng.ShowWidget(WidgetID, 0);
            return true;
        end
    end
    Core:StackFunction("GUI_BuildingButtons.StartFestivalUpdate", NewStartFestivalUpdate);
end

---
-- Überschreibt das Quest Icon für Spieler, die keinem Typen zugeordnet sind.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Local:OverrideQuestPlayerIcon()
    GUI_Interaction.SetPlayerIcon_Orig_BundlePlayerHelperFunctions = GUI_Interaction.SetPlayerIcon;
    GUI_Interaction.SetPlayerIcon = function(_PlayerIconContainer, _PlayerID)
        if _PlayerID == GUI.GetPlayerID() then
            GUI_Interaction.SetPlayerIcon_Orig_BundlePlayerHelperFunctions(_PlayerIconContainer, _PlayerID);
            return;
        end

        -- Icon
        local PlayerIcon;
        local LogoWidget = _PlayerIconContainer .. "/Logo";
        local PatternWidget = _PlayerIconContainer .. "/Pattern";
        local PlayerCategory = GetPlayerCategoryType(_PlayerID);
        local PlayerIcon = g_TexturePositions.PlayerCategories[PlayerCategory];
        if Mission_Callback_OverridePlayerIconForQuest then
            PlayerIcon = Mission_Callback_OverridePlayerIconForQuest(_PlayerID) or PlayerIcon;
        end
        if PlayerIcon == nil then
            PlayerIcon = {13, 7};
        end
        SetIcon(LogoWidget, PlayerIcon);

        -- Background
        SetIcon(PatternWidget, {14, 1});
        local R, G, B = GUI.GetPlayerColor(_PlayerID);
        if PlayerCategory == PlayerCategories.Harbour then
            R, G, B = 255, 255, 255;
        end
        XGUIEng.SetMaterialColor(PatternWidget, 0, R, G, B, 255);
    end
end

---
-- Überschreibt das Quest log Icon für Spieler, die keinem Typen zugeordnet sind.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Local:OverrideQuestLogPlayerIcon()
    QuestLog.PushQuestGiverLogo_Orig_BundlePlayerHelperFunctions = QuestLog.PushQuestGiverLogo;
    QuestLog.PushQuestGiverLogo = function(_widgetlist, _PlayerID)
        local Frame = "Icons.png";
        local IconSize = 44;
        local PlayerCategory = GetPlayerCategoryType(_PlayerID);
        local Coordinates = g_TexturePositions.PlayerCategories[PlayerCategory];
        
        if Coordinates ~= nil or Mission_Callback_OverridePlayerIconForQuest then
            QuestLog.PushQuestGiverLogo_Orig_BundlePlayerHelperFunctions(_widgetlist, _PlayerID);
            return;
        end
        Coordinates = {13, 7};

        local u0 = (Coordinates[1] - 1) * IconSize;
        local v0 = (Coordinates[2] - 1) * IconSize;
        local u1 = Coordinates[1] * IconSize;
        local v1 = Coordinates[2] * IconSize;

        if Coordinates[3] and Coordinates[3] == 1 then
            Frame = "Icons2.png";
        end
        XGUIEng.ListBoxPushItemEx(_widgetlist, "", Frame, nil, u0, v0, u1, v1);
    end
end

-- Shared ------------------------------------------------------------------- --

---
-- Prüft, ob der Spieler die Ware aktuell tatsächlich hergestellt werden kann.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _GoodType Warentyp
-- @return[type=boolean] Ware kann produziert werden
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Shared:CanPlayerProduceGood(_PlayerID, _GoodType)
    if not self:CanPlayerProduceGoodInPrinciple(_PlayerID, _GoodType) then
        return false;
    end
    local Length = #self.Data.GoodsTechnologiesMap[_GoodType];
    if Length == 0 then
        return true;
    end
    local Technology = self.Data.GoodsTechnologiesMap[_GoodType][Length];
    return Logic.TechnologyGetState(_PlayerID, Technology) == TechnologyStates.Researched;
end

---
-- Prüft, ob der Spieler die Ware prinzipiell herstellen kann.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _GoodType Warentyp
-- @return[type=boolean] Ware kann produziert werden
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Shared:CanPlayerProduceGoodInPrinciple(_PlayerID, _GoodType)
    if not self.Data.GoodsTechnologiesMap[_GoodType] then
        return false;
    end
    for k, v in pairs(self.Data.GoodsTechnologiesMap[_GoodType]) do
        if Logic.TechnologyGetState(_PlayerID, v) == TechnologyStates.Prohibited 
        or Logic.TechnologyGetState(_PlayerID, v) == TechnologyStates.Locked then
            return false;
        end
    end
    return true;
end

---
-- Gibt den Rohstoff zur angegebenen Ware zurück. Wird kein Rohstoff gefunden,
-- wird Goods.G_Gold zurückgegeben.
--
-- @param[type=number] _GoodType Warentyp
-- @return[type=boolean] Ware kann produziert werden
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Shared:ProductToResource(_GoodType)
    if Logic.GetGoodCategoryForGoodType(_GoodType) == GoodCategories.GC_Resource then
        return _GoodType;
    end
    local TypeName = Logic.GetGoodTypeName(_GoodType);
    local Resource = self.Data.ProductResourceMap[TypeName];
    if Resource == nil then
        Resource = Goods.G_Gold;
    end
    return Resource;
end

---
-- Gibt die Rohstoff-Entities zur Ware zurück, die der Spieler besitzt.
--
-- Benötigt eine Ware keine Rohstoffe, wird -1 und eine leere Liste
-- zurückgegeben.
--
-- Optional können auch Entities auf neutralen Territorien einbezogen werden.
--
-- Es werden nur Entities zurückgegeben, die erreichbar sind. Entities hinter
-- Blocking werden ausgeschlossen.
--
-- @param[type=number]  _PlayerID ID des Spielers
-- @param[type=number]  _GoodType Warentyp
-- @param[type=boolean] _WithNeutral Entities auf neutralen Territorien zählen
-- @return[type=number] Anzahl Entities
-- @return[type=table] Liste der Entities
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Shared:GetResourceEntitiesOfPlayerForGoodType(_PlayerID, _GoodType, _WithNeutral)
    -- Rohstofftyp ermitteln
    local Resources = self.Data.GoodsResourcesMap[_GoodType];
    if Resources == nil or #Resources == 0 then
        local GoodTypeName = Logic.GetGoodTypeName(_GoodType);
        if self.Data.ProductResourceMap[GoodTypeName] then
            _GoodType = self.Data.ProductResourceMap[GoodTypeName];
            if _GoodType then
                Resources = self.Data.GoodsResourcesMap[_GoodType];
                if Resources == nil or #Resources == 0 then
                    return -1, {};
                end
            end
        end
    end
    Resources = Resources or {};

    -- Territorien des Spielers ermitteln
    local PlayerTerritories = {Logic.GetTerritories()}
    for i= #PlayerTerritories, 1, -1 do
        if not _WithNeutral and Logic.GetTerritoryPlayerID(PlayerTerritories[i]) ~= _PlayerID then
            table.remove(PlayerTerritories, i);
        elseif _WithNeutral and Logic.GetTerritoryPlayerID(PlayerTerritories[i]) > 0 
        and    Logic.GetTerritoryPlayerID(PlayerTerritories[i]) ~= _PlayerID then
            table.remove(PlayerTerritories, i);
        end
    end

    -- Rohstoffe prüfen
    local ResultList = {};
    if #Resources > 0 then
        for k, v in pairs(Resources) do
            local Type = Logic.GetEntityTypeID(v);
            if Type ~= nil then
                local ResEntities, ResEntityAmount;
                if Type == Entities.A_X_Cow01 or Type == Entities.A_X_Sheep01 or Type == Entities.A_X_Sheep02 then
                    for i= 1, #PlayerTerritories, 1 do
                        ResEntities = {Logic.GetEntitiesOfTypeInTerritory(PlayerTerritories[i], _PlayerID, Type, 0)};
                        if #ResEntities > 0 then
                            ResultList = Array_Append(ResultList, ResEntities);
                        end
                    end
                else
                    ResEntities = {Logic.GetEntities(Type, 48)};
                    ResEntityAmount = table.remove(ResEntities, 1);
                    if ResEntityAmount > 0 then
                        for j= 1, #ResEntities do
                            for i= 1, #PlayerTerritories, 1 do
                                if GetTerritoryUnderEntity(ResEntities[j]) == PlayerTerritories[i] then
                                    table.insert(ResultList, ResEntities[j]);
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    -- Nicht erreichbare Entities entfernen
    for i= #ResultList, 1, -1 do
        local x,y,z = Logic.EntityGetPos(ResultList[i]);
        local SH1ID = Logic.GetStoreHouse(_PlayerID);
        local PosID = Logic.CreateEntityOnUnblockedLand(
            Entities.XD_ScriptEntity, x, y, 0, 0
        )
        if not CanEntityReachTarget(_PlayerID, SH1ID, PosID, nil, PlayerSectorTypes.Military) then
            table.remove(ResultList, i);
        end
        DestroyEntity(PosID);
    end
    return #ResultList, ResultList;
end

-- BundlePlayerHelperFunctions.Shared:GetResourceEntitiesOfPlayerForGoodType(1, Goods.G_Soap, false)

---
-- Generiert die Map für Die Zuordnung Produkt zu Rohstoff.
--
-- Produkte, die aus anderen Produkten hergestellt werden haben den Rohstoff
-- des anderen Produktes als Rohstoff (transitive Beziezung).
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Shared:CreateProductToResourceMap()
    self.Data.ProductResourceMap = {
        ["G_Banner"]            = Goods.G_Wool,
        ["G_Beer"]              = Goods.G_Honeycomb,
        ["G_Bow"]               = Goods.G_Iron,
        ["G_Bread"]             = Goods.G_Grain,
        ["G_Broom"]             = Goods.G_Wood,
        ["G_Candle"]            = Goods.G_Honeycomb,
        ["G_Cheese"]            = Goods.G_Milk,
        ["G_Clothes"]           = Goods.G_Wool,
        ["G_EntBaths"]          = Goods.G_Water,
        ["G_Leather"]           = Goods.G_Carcass,
        ["G_Medicine"]          = Goods.G_Herb,
        ["G_Ornament"]          = Goods.G_Wood,
        ["G_PlayMaterial"]      = Goods.G_Wool,
        ["G_PoorBow"]           = Goods.G_Iron,
        ["G_PoorSword"]         = Goods.G_Iron,
        ["G_Sausage"]           = Goods.G_Carcass,
        ["G_SiegeEnginePart"]   = Goods.G_Iron,
        ["G_Sign"]              = Goods.G_Iron,
        ["G_SmokedFish"]        = Goods.G_RawFish,
        ["G_Soap"]              = Goods.G_Carcass,
        ["G_Sword"]             = Goods.G_Iron,
    }
end

---
-- Generiert die Map für Güter und deren benötigte Technologien.
--
-- Für alle gewöhnlichen Waren werden die benötigten Technologien gespeichert
-- Ein Bannermacher benötigt z.B. Wolle, also muss der Spieler nicht nur Banner,
-- sondern ebenfalls Wolle herstellen können.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Shared:CreateGoodsTechnologiesMap()
    -- Evergreens
    self.Data.GoodsTechnologiesMap = {
        [Goods.G_Gold]        = {},
        [Goods.G_Water]       = {},
    }

    -- Gathering
    self.Data.GoodsTechnologiesMap[Goods.G_Stone]       = {Technologies.R_Gathering, Technologies.R_StoneQuarry};
    self.Data.GoodsTechnologiesMap[Goods.G_Iron]        = {Technologies.R_Gathering, Technologies.R_IronMine};
    self.Data.GoodsTechnologiesMap[Goods.G_Wood]        = {Technologies.R_Gathering, Technologies.R_Woodcutter};
    self.Data.GoodsTechnologiesMap[Goods.G_Milk]        = {Technologies.R_Gathering, Technologies.R_CattleFarm};
    self.Data.GoodsTechnologiesMap[Goods.G_Grain]       = {Technologies.R_Gathering, Technologies.R_GrainFarm};
    self.Data.GoodsTechnologiesMap[Goods.G_RawFish]     = {Technologies.R_Gathering, Technologies.R_FishingHut};
    self.Data.GoodsTechnologiesMap[Goods.G_Carcass]     = {Technologies.R_Gathering, Technologies.R_HuntersHut};
    self.Data.GoodsTechnologiesMap[Goods.G_Honeycomb]   = {Technologies.R_Gathering, Technologies.R_Beekeeper};
    self.Data.GoodsTechnologiesMap[Goods.G_Wool]        = {Technologies.R_Gathering, Technologies.R_SheepFarm};
    self.Data.GoodsTechnologiesMap[Goods.G_Herb]        = {Technologies.R_Gathering, Technologies.R_HerbGatherer};

    -- Food
    self.Data.GoodsTechnologiesMap[Goods.G_Bread] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Grain]),
        Technologies.R_Nutrition, Technologies.R_Bakery,
    };
    self.Data.GoodsTechnologiesMap[Goods.G_Cheese] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Milk]),
        Technologies.R_Nutrition, Technologies.R_Dairy
    };
    self.Data.GoodsTechnologiesMap[Goods.G_Sausage] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Carcass]),
        Technologies.R_Nutrition, Technologies.R_Butcher
    };
    self.Data.GoodsTechnologiesMap[Goods.G_SmokedFish] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_RawFish]),
        Technologies.R_Nutrition, Technologies.R_SmokeHouse
    };

    -- Clothes
    self.Data.GoodsTechnologiesMap[Goods.G_Clothes] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Wool]),
        Technologies.R_Clothes, Technologies.R_Weaver,
    };
    self.Data.GoodsTechnologiesMap[Goods.G_Leather] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Carcass]),
        Technologies.R_Clothes, Technologies.R_Tanner
    };

    -- Hygiene
    self.Data.GoodsTechnologiesMap[Goods.G_Broom] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Wood]),
        Technologies.R_Hygiene, Technologies.R_BroomMaker,
    };
    self.Data.GoodsTechnologiesMap[Goods.G_Soap] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Carcass]),
        Technologies.R_Hygiene, Technologies.R_Soapmaker
    };
    self.Data.GoodsTechnologiesMap[Goods.G_Medicine] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Herb]),
        Technologies.R_Hygiene, Technologies.R_Pharmacy
    };

    -- Entertainment
    self.Data.GoodsTechnologiesMap[Goods.G_Beer] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Honeycomb]),
        Technologies.R_Entertainment, Technologies.R_Tavern,
    };
    self.Data.GoodsTechnologiesMap[Goods.G_EntBaths] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Water]),
        Technologies.R_Construction, Technologies.R_Entertainment, Technologies.R_Baths
    };
    self.Data.GoodsTechnologiesMap[Goods.G_EntTheatre] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Wool]),
        Technologies.R_Entertainment, Technologies.R_Theatre
    };

    -- Wealth
    self.Data.GoodsTechnologiesMap[Goods.G_Banner] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Wool]),
        Technologies.R_Wealth, Technologies.R_BannerMaker
    };
    self.Data.GoodsTechnologiesMap[Goods.G_Sign] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Iron]),
        Technologies.R_Wealth, Technologies.R_Blacksmith
    };
    self.Data.GoodsTechnologiesMap[Goods.G_Candle] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Honeycomb]),
        Technologies.R_Wealth, Technologies.R_CandleMaker,
    };
    self.Data.GoodsTechnologiesMap[Goods.G_Ornament] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Wood]),
        Technologies.R_Wealth, Technologies.R_Carpenter
    };

    -- Military Raw
    self.Data.GoodsTechnologiesMap[Goods.G_PoorBow] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Iron]),
        Technologies.R_Military, Technologies.R_BowMaker
    };
    self.Data.GoodsTechnologiesMap[Goods.G_PoorSword] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Iron]),
        Technologies.R_Military, Technologies.R_SwordSmith
    };
    self.Data.GoodsTechnologiesMap[Goods.G_SiegeEnginePart] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_Iron]),
        Technologies.R_Military, Technologies.R_SiegeEngineWorkshop
    };

    -- Military Equipment
    self.Data.GoodsTechnologiesMap[Goods.G_Bow] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_PoorBow]),
        Technologies.R_Military, Technologies.R_BarracksArchers
    };
    self.Data.GoodsTechnologiesMap[Goods.G_Sword] = {
        unpack(self.Data.GoodsTechnologiesMap[Goods.G_PoorSword]),
        Technologies.R_Military, Technologies.R_Barracks
    };
end

---
-- 
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Shared:CreateGoodsResourcesMap()
    -- Evergreens
    self.Data.GoodsResourcesMap = {
        [Goods.G_Carcass]       = {
            "S_AxisDeer_AS",
            "S_Deer_ME",
            "S_FallowDeer_SE",
            "S_Gazelle_NA",
            "S_Moose_NE",
            "S_Reindeer_NE",
            "S_WildBoar",
            "S_Zebra_NA"
        },
        [Goods.G_Herb]          = {
            "S_Herbs"
        },
        [Goods.G_Iron]          = {
            "R_IronMine"
        },
        [Goods.G_Milk]          = {
            "A_X_Cow01"
        },
        [Goods.G_RawFish]       = {
            "S_RawFish"
        },
        [Goods.G_Stone]         = {
            "R_StoneMine"
        },
        [Goods.G_Wool]          = {
            "A_X_Sheep01",
            "A_X_Sheep02"
        },
    };
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundlePlayerHelperFunctions");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleSaveGameTools                                          # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet Funktionen an, mit denen Anlegen und Laden von
-- Spielständen kontrolliert werden können.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleSaveGameTools = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Speichert das Spiel mit automatisch fortlaufender Nummer im Namen
-- des Spielstandes. Wenn nicht gespeichert werden kann, wird bis
-- zum nächsten mäglichen Zeitpunkt gewartet.
--
-- @param _name [string] Name des Spielstandes
-- @within Anwenderfunktionen
--
function API.AutoSaveGame(_name)
    assert(_name == nil or type(_name) == "string");
    if not GUI then
        Logic.ExecuteInLuaLocalState('API.AutoSaveGame("'.._name..'")');
        return;
    end
    BundleSaveGameTools.Local:AutoSaveGame(_name);
end

---
-- Speichert den Spielstand in das angegebene Verzeichnis. Es können
-- keine Verzeichnise erzeugt werden. Der Pfad beginnt relativ vom
-- Spielstandverzeichnis.
--
-- @param _path [string] Pfad zum Ziel
-- @param _name [string] Name des Spielstandes
-- @within Anwenderfunktionen
--
function API.SaveGameToFolder(_path, _name)
    assert(_path);
    assert(_name);
    if not GUI then
        Logic.ExecuteInLuaLocalState('API.SaveGameToFolder("'.._path..'", "'.._name..'")');
        return;
    end
    BundleSaveGameTools.Local:SaveGameToFolder(_path, _name);
end

---
-- Läd einen Spielstand aus dem angegebenen Verzeichnis. Der Pfad
-- beginnt relativ vom Spielstandverzeichnis. Optional kann der
-- Ladebildschirm gehalten werden, bis der Spieler das Spiel per
-- Button startet.
--
-- @param _path [string] Pfad zum Ziel
-- @param _name [string] Name des Spielstandes
-- @param _needButton [number] Startbutton anzeigen (0 oder 1)
-- @within Anwenderfunktionen
--
function API.LoadGameFromFolder(_path, _name, _needButton)
    assert(_path);
    assert(_name);
    assert(_needButton);
    if not GUI then
        Logic.ExecuteInLuaLocalState('API.LoadGameFromFolder("'.._path..'", "'.._name..'", "'.._needButton..'")');
        return;
    end
    BundleSaveGameTools.Local:LoadGameFromFolder(_path, _name, _needButton);
end

---
-- Startet eine Map aus dem angegebenen Verzeichnis. Die Verzeichnisse
-- werden durch IDs unterschieden.
-- <ul>
-- <li>Kampagne: -1</li>
-- <li>Development:	1</li>
-- <li>Singleplayer: 0</li>
-- <li>Multiplayer:	2</li>
-- <li>Usermap: 3</li>
-- </ul>
--
-- @param _map [string] Name der Map
-- @param _knight [number] Index des Helden
-- @param _folder [number] Mapordner
-- @param _needButton [number] Startbutton nutzen
-- @within Anwenderfunktionen
--
function API.StartMap(_map, _knight, _folder, _needButton)
    assert(_map);
    assert(_knight);
    assert(_folder);
    assert(_needButton);
    if not GUI then
        Logic.ExecuteInLuaLocalState('API.StartMap("'.._map..'", "'.._knight..'", "'.._needButton..'", "'.._needButton..'")');
        return;
    end
    BundleSaveGameTools.Local:StartMap(_map, _knight, _folder, _needButton);
end

---
-- Sperrt das Speichern von Spielständen oder gibt es wieder frei.
--
-- <p><b>Alias:</b> ForbidSaveGame</p>
--
-- @param[type=boolean] _Flag Speichern gesperrt
-- @within Anwenderfunktionen
--
function API.ForbidSaveGame(_Flag)
    if GUI then
        GUI.SendScriptCommand("API.ForbidSaveGame(".. tostring(_Flag) ..")");
        return;
    end
    Logic.ExecuteInLuaLocalState([[
        BundleSaveGameTools.Local.Data.ForbidSave = ]].. tostring(_Flag) ..[[ == true
        BundleSaveGameTools.Local:DisplaySaveButtons(]].. tostring(_Flag) ..[[)
    ]]);
end
ForbidSaveGame = API.ForbidSaveGame;

---
-- Aktiviert oder deaktiviert die automatische Speicherung der History Edition.
--
-- <b>Hinweis</b>: Diese Funktion hat keinen Effekt beim Originalspiel. Nur die
-- History Edition erzeugt automatische Spielstände.
--
-- @param[type=boolean] _Flag HE Quicksave deaktivieren
-- @within Anwenderfunktionen
--
function API.DisableAutomaticQuickSave(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[BundleSaveGameTools.Local.Data.DisableQuicksaveHE = %s]],
            tostring(_Flag == true)
        ));
        return;
    end
    BundleSaveGameTools.Local.Data.DisableQuicksaveHE = _Flag == true;
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleSaveGameTools = {
    Global = {
        Data = {}
    },
    Local = {
        Data = {
            AutoSaveCounter = 0,
            DisableQuicksaveHE = false,
            ForbidSave = false,
        }
    },
}

-- Global Script ---------------------------------------------------------------

function BundleSaveGameTools.Global:Install()
    API.AddSaveGameAction(function()
        Logic.ExecuteInLuaLocalState([[
            BundleSaveGameTools.Local:AlterQuickSaveHotkey();
        ]])
    end);
end

-- Local Script ----------------------------------------------------------------

function BundleSaveGameTools.Local:Install()
    self:InitForbidSaveGame();
    self:AlterQuickSaveHotkey();
end

function BundleSaveGameTools.Local:AutoSaveGame(_Name)
    _Name = _Name or Framework.GetCurrentMapName();

    local MapName = Tool_GetLocalizedMapName(_Name);
    local Counter = BundleSaveGameTools.Local.Data.AutoSaveCounter +1;
    BundleSaveGameTools.Local.Data.AutoSaveCounter = Counter;

    local Text
	if string.len(MapName) > 15 then
	    Text = XGUIEng.GetStringTableText("UI_Texts/Saving_center") .. "{cr}{cr}" .. MapName
	else
	    Text = "{cr}{cr}" .. XGUIEng.GetStringTableText("UI_Texts/Saving_center") .. "{cr}{cr}" .. MapName
	end

    if self:CanGameBeSaved() then
        OpenDialog(API.Localize(Text), XGUIEng.GetStringTableText("UI_Texts/MainMenuSaveGame_center"));
        XGUIEng.ShowWidget("/InGame/Dialog/Ok", 0);
        Framework.SaveGame("Autosave "..Counter.." --- ".._Name, "Saved by QSB");
    else
        StartSimpleJobEx( function()
            if BundleSaveGameTools.Local:CanGameBeSaved() then
                OpenDialog(API.Localize(Text), XGUIEng.GetStringTableText("UI_Texts/MainMenuSaveGame_center"));
                XGUIEng.ShowWidget("/InGame/Dialog/Ok", 0);
                Framework.SaveGame("Autosave - "..Counter.." --- ".._Name, "Saved by QSB");
                return true;
            end
        end);
    end
end

function BundleSaveGameTools.Local:CanGameBeSaved()
    if self.Data.ForbidSave then
        return false;
    end
    if not Core:CanGameBeSaved() then
        return false;
    end
    return true;
end

function BundleSaveGameTools.Local:SaveGameToFolder(_path, _name)
    _name = _name or Framework.GetCurrentMapName();
    Framework.SaveGame(_path .. "/" .. _name, "--");
end

function BundleSaveGameTools.Local:LoadGameFromFolder(_path, _name, _needButton)
    _needButton = _needButton or 0;
    assert( type(_name) == "string" );
    local SaveName = _path .. "/" .. _name .. GetSaveGameExtension();
    local Name, Type, Campaign = Framework.GetSaveGameMapNameAndTypeAndCampaign(SaveName);
    InitLoadScreen(false, Type, Name, Campaign, 0);
    Framework.ResetProgressBar();
    Framework.SetLoadScreenNeedButton(_needButton);
    Framework.LoadGame(SaveName);
end

function BundleSaveGameTools.Local:StartMap(_map, _knight, _folder, _needButton)
    _needButton = _needButton or 1;
    _knight = _knight or 0;
    _folder = _folder or 3;
    local name, desc, size, mode = Framework.GetMapNameAndDescription(_map, _folder);
    if name ~= nil and name ~= "" then
        XGUIEng.ShowAllSubWidgets("/InGame",0);
        Framework.SetLoadScreenNeedButton(_needButton);
        InitLoadScreen(false, _folder, _map, 0, _knight);
        Framework.ResetProgressBar();
        Framework.StartMap(_map, _folder, _knight);
    else
        GUI.AddNote("ERROR: invalid mapfile!");
    end
end

-- -------------------------------------------------------------------------- --

function BundleSaveGameTools.Local:InitForbidSaveGame()
    KeyBindings_SaveGame = function(_ByUser)
        -- In der History Edition wird diese Funktion aufgerufen, wenn der
        -- letzte Spielstand der Map älter als 15 Minuten ist. Wenn ein
        -- Briefing oder eine Cutscene aktiv ist oder das Speichern generell
        -- verboten wurde, sollen keine Quicksaves erstellt werden.
        if not BundleSaveGameTools.Local:CanGameBeSaved() then
            return;
        end
        -- Außerdem soll es möglich sein, die Quicksaves der HE zu verbieten,
        -- aber dem Spieler weiterhin Quicksaves zu erlauben
        if not _ByUser and BundleSaveGameTools.Local.Data.DisableQuicksaveHE then
            return;
        end
        KeyBindings_SaveGame_Orig_Core_SaveGame();
    end
end

function BundleSaveGameTools.Local:DisplaySaveButtons(_Flag)
    XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame",  (_Flag and 0) or 1);
    XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", (_Flag and 0) or 1);
end

function BundleSaveGameTools.Local:AlterQuickSaveHotkey()
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.S,
        "KeyBindings_SaveGame(true)",
        2,
        false
    );
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleSaveGameTools");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleSoundOptions                                           # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet die Möglichkeit die Lautstärke im Spiel zu regeln.
-- Außerdem kannst du Stimmen abspielen und stoppen.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleSoundOptions = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Startet eine Playlist, welche als XML angegeben ist.
--
-- Eine als XML definierte Playlist wird nicht als Voice abgespielt sondern
-- als Music. Als Musik werden MP3-Dateien verwendet. Diese können entweder
-- im Spiel vorhanden sein oder im Ordner <i>music/</i> im Root-Verzeichnis
-- des Spiels gespeichert werden. Die Playlist gehört ebenfalls ins Root-
-- Verzeichnis nach <i>config/sound/</i>.
--
-- Bereits vorhandene Playlists im Hauptspiel:
-- <pre>config/sound/playlistbackgroundgeneric.xml
--config/sound/playlistbackgroundmiddleeurope.xml
--config/sound/playlistbackgroundnorthafrica.xml
--config/sound/playlistbackgroundnortheurope.xml
--config/sound/playlistbackgroundsoutheurope.xml
--config/sound/playlistbackgroundwintergeneric.xml
--config/sound/playlistbackgroundwintermiddleeurope.xml
--config/sound/playlistbackgroundwinternorthafrica.xml
--config/sound/playlistbackgroundwinternortheurope.xml
--config/sound/playlistbackgroundwintersoutheurope.xml
--config/sound/playlistcombatlargegeneric.xml
--config/sound/playlistcombatlargemiddleeurope.xml
--config/sound/playlistcombatlargenorthafrica.xml
--config/sound/playlistcombatlargenortheurope.xml
--config/sound/playlistcombatlargesoutheurope.xml
--config/sound/playlistcombatsmallgeneric.xml
--config/sound/playlistcombatsmallmiddleeurope.xml
--config/sound/playlistcombatsmallnorthafrica.xml
--config/sound/playlistcombatsmallnortheurope.xml
--config/sound/playlistcombatsmallsoutheurope.xml
--config/sound/playlisteventantagonist.xml
--config/sound/playlisteventblaze.xml
--config/sound/playlisteventexploration.xml
--config/sound/playlisteventfestival.xml
--config/sound/playlisteventgamelost.xml
--config/sound/playlisteventgamewon.xml
--config/sound/playlisteventheroic.xml
--config/sound/playlisteventplague.xml
--config/sound/playlisteventsad.xml
--config/sound/playlisteventsiege.xml
--config/sound/playlisteventsinging.xml
--config/sound/playlisteventstorm.xml
--config/sound/playlistlocation.xml
--config/sound/playlistlocationcitymiddleeurope.xml
--config/sound/playlistlocationcitynorthafrica.xml
--config/sound/playlistlocationcitynortheurope.xml
--config/sound/playlistlocationcitysoutheurope.xml
--config/sound/playlistlocationvillagemiddleeurope.xml
--config/sound/playlistlocationvillagenorthafrica.xml
--config/sound/playlistlocationvillagenortheurope.xml
--config/sound/playlistlocationvillagesoutheurope.xml
--config/sound/playlistthroneroommiddleeurope.xml
--config/sound/playlistthroneroomnorthafrica.xml
--config/sound/playlistthroneroomnortheurope.xml
--config/sound/playlistthroneroomsoutheurope.xml
--config/sound/playlistui.xml</pre>
--
-- Zusätzlich vorhandene Playlists in Reich des Ostens:
--<pre>config/sound/playlistbackgroundasia.xml
--config/sound/playlistbackgroundwinterasia.xml
--config/sound/playlistcombatsmallasia.xml
--config/sound/playlistthroneroomasia.xml</pre>
--
-- Verzeichnisstruktur für eigene Musik:
-- <pre>map_xyz.s6xmap.unpacked
--|-- music/*        <-- Hier liegen die MP3-Dateien
--|-- config/sound/* <-- Hier liegen die XML-Dateien
--|-- maps/externalmap/map_xyz/*
--|-- ...</pre>
--
-- In der QSB sind bereits die Variablen <i>gvMission.MusicRootPath</i> und
-- <i>gvMission.PlaylistRootPath</i> mit den entsprechenden Pfaden vordefiniert.
--
-- Wenn du eigene Musik verwendest, achte darauf, einen möglichst eindeutigen
-- Namen zu verwenden. Und natürlich auch auf Urheberrecht!
--
-- Beispiel für eine eigene Playlist:
-- <pre>
--&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
--&lt;PlayList&gt;
-- &lt;PlayListEntry&gt;
--   &lt;FileName&gt;Music\some_music_file.mp3&lt;/FileName&gt;
--   &lt;Type&gt;Loop&lt;/Type&gt;
-- &lt;/PlayListEntry&gt;
-- &lt;!-- Hier können weitere Einträge folgen. --&gt;
--&lt;/PlayList&gt;
--</pre>
-- Als Typ können "Loop" oder "Normal" gewählt werden. Normale Musik wird
-- einmalig abgespielt. Ein Loop läuft endlos weiter.
--
-- Außerdem kann zusätzlich zum Typ eine Abspielwahrscheinlichkeit mit
-- angegeben werden:
-- <pre>&lt;Chance&gt;10&lt;/Chance&gt;</pre>
-- Es sind Zahlen von 1 bis 100 möglich.
--
-- @param _Playlist Pfad zur Playlist
-- @param _PlayerID (Optional) ID des menschlichen Spielers
-- @within Anwenderfunktionen
--
-- @usage API.StartEventPlaylist(gvMission.PlaylistRootPath .."my_playlist.xml");
--
function API.StartEventPlaylist(_Playlist, _PlayerID)
    _PlayerID = _PlayerID or 1;
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.StartEventPlaylist('%s', %d)", _Playlist, _PlayerID));
        return;
    end
    if _PlayerID == GUI.GetPlayerID() then
        Sound.MusicStartEventPlaylist(_Playlist)
    end
end

---
-- Beendet eine Event Playlist.
--
-- @param _Playlist Pfad zur Playlist
-- @param _PlayerID (Optional) ID des menschlichen Spielers
-- @within Anwenderfunktionen
--
-- @usage API.StopEventPlaylist("config/sound/my_playlist.xml");
--
function API.StopEventPlaylist(_Playlist, _PlayerID)
    _PlayerID = _PlayerID or 1;
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.StopEventPlaylist('%s', %d)", _Playlist, _PlayerID));
        return;
    end
    if _PlayerID == GUI.GetPlayerID() then
        Sound.MusicStopEventPlaylist(_Playlist)
    end
end

---
-- Spielt einen Sound aus dem Spiel ab.
--
-- Wenn eigene Sounds verwendet werden sollen, müssen sie im WAV-Format
-- vorliegen und in die zwei Verzeichnisse für niedrige und hohe Qualität
-- kopiert werden.
--
-- Verzeichnisstruktur für eigene Sounds:
-- <pre>map_xyz.s6xmap.unpacked
--|-- sounds/high/ui/*
--|-- sounds/low/ui/*
--|-- maps/externalmap/map_xyz/*
--|-- ...</pre>
--
-- @param _Sound    Pfad des Sound
-- @param _PlayerID (Optional) ID des menschlichen Spielers
-- @within Anwenderfunktionen
--
-- @usage API.PlaySound("ui\\menu_left_gold_pay");
--
function API.PlaySound(_Sound, _PlayerID)
    _PlayerID = _PlayerID or 1;
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format([[API.PlaySound("%s", %d)]], _Sound, _PlayerID));
        return;
    end
    if _PlayerID == GUI.GetPlayerID() then
        Sound.FXPlay2DSound(_Sound);
    end
end

---
-- Setzt die allgemeine Lautstärke. Die allgemeine Lautstärke beeinflusst alle
-- anderen Laufstärkeregler.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage API.SoundSetVolume(100);
--
function API.SoundSetVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetVolume(%d)", _Volume));
        return;
    end
    BundleSoundOptions.Local:AdjustSound(_Volume, nil, nil, nil, nil);
end

---
-- Setzt die Lautstärke der Musik.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage API.SoundSetMusicVolume(100);
--
function API.SoundSetMusicVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetMusicVolume(%d)", _Volume));
        return;
    end
    BundleSoundOptions.Local:AdjustSound(nil, _Volume, nil, nil, nil);
end

---
-- Setzt die Lautstärke der Stimmen.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage API.SoundSetVoiceVolume(100);
--
function API.SoundSetVoiceVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetVoiceVolume(%d)", _Volume));
        return;
    end
    BundleSoundOptions.Local:AdjustSound(nil, nil, _Volume, nil, nil);
end

---
-- Setzt die Lautstärke der Umgebung.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage API.SoundSetAtmoVolume(100);
--
function API.SoundSetAtmoVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetAtmoVolume(%d)", _Volume));
        return;
    end
    BundleSoundOptions.Local:AdjustSound(nil, nil, nil, _Volume, nil);
end

---
-- Setzt die Lautstärke des Interface.
--
-- <b>Hinweis:</b> Es wird automatisch ein Backup der Einstellungen angelegt
-- wenn noch keins angelegt wurde.
--
-- @param _Volume Lautstärke
-- @within Anwenderfunktionen
--
-- @usage API.SoundSetUIVolume(100);
--
function API.SoundSetUIVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.SoundSetUIVolume(%d)", _Volume));
        return;
    end
    BundleSoundOptions.Local:AdjustSound(nil, nil, nil, nil, _Volume);
end

---
-- Erstellt ein Backup der Soundeinstellungen, wenn noch keins erstellt wurde.
--
-- @within Anwenderfunktionen
--
-- @usage API.SoundSave();
--
function API.SoundSave()
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.SoundSave()");
        return;
    end
    BundleSoundOptions.Local:SaveSound();
end

---
-- Stellt den Sound wieder her, sofern ein Backup erstellt wurde.
--
-- @within Anwenderfunktionen
--
-- @usage API.SoundRestore();
--
function API.SoundRestore()
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.SoundRestore()");
        return;
    end
    BundleSoundOptions.Local:RestoreSound();
end

---
-- Gibt eine MP3-Datei als Stimme wieder. Diese Funktion kann auch benutzt
-- werden um Geräusche abzuspielen.
--
-- @param[type=string] _File Abzuspielende Datei
-- @within Anwenderfunktionen
--
-- @usage API.PlayVoice("music/puhdys_alt_wie_ein_baum.mp3");
--
function API.PlayVoice(_File)
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format("API.PlayVoice('%s')", _File));
        return;
    end
    API.StopVoice();
    Sound.PlayVoice("ImportantStuff", _File);
end
PlaySound = API.PlaySound;

---
-- Stoppt alle als Stimme abgespielten aktiven Sounds.
--
-- @within Anwenderfunktionen
--
-- @usage API.StopSound();
--
function API.StopVoice()
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.StopVoice()");
        return;
    end
    Sound.StopVoice("ImportantStuff");
end
StopSound = API.StopVoice;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleSoundOptions = {
    Local = {
        Data = {
            SoundBackup = {},
        }
    },
}

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleSoundOptions.Local:Install()
end

function BundleSoundOptions.Local:AdjustSound(_Global, _Music, _Voice, _Atmo, _UI)
    self:SaveSound();
    if _Global then
        Sound.SetGlobalVolume(_Global);
    end
    if _Music then
        Sound.SetMusicVolume(_Music);
    end
    if _Voice then
        Sound.SetSpeechVolume(self.Data.SoundBackup.Voice);
    end
    if _Atmo then
        Sound.SetFXSoundpointVolume(_Atmo);
        Sound.SetFXAtmoVolume(_Atmo);
    end
    if _UI then
        Sound.Set2DFXVolume(_UI);
        Sound.SetFXVolume(_UI);
    end
end

function BundleSoundOptions.Local:SaveSound()
    if self.Data.SoundBackup.FXSP == nil then
        self.Data.SoundBackup.FXSP = Sound.GetFXSoundpointVolume();
        self.Data.SoundBackup.FXAtmo = Sound.GetFXAtmoVolume();
        self.Data.SoundBackup.FXVol = Sound.GetFXVolume();
        self.Data.SoundBackup.Sound = Sound.GetGlobalVolume();
        self.Data.SoundBackup.Music = Sound.GetMusicVolume();
        self.Data.SoundBackup.Voice = Sound.GetSpeechVolume();
        self.Data.SoundBackup.UI = Sound.Get2DFXVolume();
    end
end

function BundleSoundOptions.Local:RestoreSound()
    if self.Data.SoundBackup.FXSP ~= nil then
        Sound.SetFXSoundpointVolume(self.Data.SoundBackup.FXSP)
        Sound.SetFXAtmoVolume(self.Data.SoundBackup.FXAtmo)
        Sound.SetFXVolume(self.Data.SoundBackup.FXVol)
        Sound.SetGlobalVolume(self.Data.SoundBackup.Sound)
        Sound.SetMusicVolume(self.Data.SoundBackup.Music)
        Sound.SetSpeechVolume(self.Data.SoundBackup.Voice)
        Sound.Set2DFXVolume(self.Data.SoundBackup.UI)
        self.Data.SoundBackup = {}
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleSoundOptions");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleGameHelperFunctions                                    # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle stellt die als "Speedbremse" bekannte Funktionalität zur 
-- Verfügung. Die maximale Beschleunigung des Spiels kann gesteuert werden.
--
-- Wenn die Geschwindigkeit festgelegt werden soll, muss zuerst bestimmt werden
-- wo die Obergrenze liegt.
-- <pre>API.SpeedLimitSet(1)</pre>
-- Diese Festlegung gilt solange, bis sie irgend wann einmal geändert wird.
--
-- Danach kann die Sperre jederzeit aktiviert oder deaktiviert werden.
-- <pre>API.SpeedLimitActivate(true)</pre>
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleGameHelperFunctions = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Diese Funktion setzt die maximale Spielgeschwindigkeit bis zu der das Spiel
-- beschleunigt werden kann.
--
-- <p><b>Alias:</b> SetSpeedLimit</p>
--
-- @param[type=number] _Limit Obergrenze für Spielgeschwindigkeit
-- @within Anwenderfunktionen
-- @see API.SpeedLimitActivate
--
-- @usage -- Legt die Speedbremse auf Stufe 1 fest.
-- API.SpeedLimitSet(1)
-- -- Legt die Speedbremse auf Stufe 2 fest.
-- API.SpeedLimitSet(2)
--
function API.SpeedLimitSet(_Limit)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.SpeedLimitSet(" ..tostring(_Limit).. ")");
        return;
    end
    return BundleGameHelperFunctions.Local:SetSpeedLimit(_Limit);
end
SetSpeedLimit = API.SpeedLimitSet

---
-- Aktiviert die zuvor eingestellte Maximalgeschwindigkeit.
--
-- <p><b>Alias:</b> ActivateSpeedLimit</p>
--
-- @param[type=boolean] _Flag Speedbremse ist aktiv
-- @within Anwenderfunktionen
-- @see API.SpeedLimitSet
--
function API.SpeedLimitActivate(_Flag)
    if GUI then
        return;
    end
    return Logic.ExecuteInLuaLocalState("BundleGameHelperFunctions.Local:ActivateSpeedLimit(" ..tostring(_Flag).. ")");
end
ActivateSpeedLimit = API.SpeedLimitActivate;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleGameHelperFunctions = {
    Local = {
        Data = {
            SpeedLimit = 32,
        }
    },
}

-- -------------------------------------------------------------------------- --

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:Install()
    self:InitForbidSpeedUp();
end

-- -------------------------------------------------------------------------- --

---
-- Setzt die Obergrenze für die Spielgeschwindigkeit fest.
--
-- @param[type=number] _Limit Obergrenze
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:SetSpeedLimit(_Limit)
    _Limit = (_Limit < 1 and 1) or math.floor(_Limit);
    info("BundleGameHelperFunctions: Setting speed limit to " .._Limit);
    self.Data.SpeedLimit = _Limit;
end

---
-- Aktiviert die Speedbremse. Die vorher eingestellte Maximalgeschwindigkeit
-- kann nicht mehr überschritten werden.
--
-- @param[type=boolean] _Flag Speedbremse ist aktiv
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:ActivateSpeedLimit(_Flag)
    self.Data.UseSpeedLimit = _Flag == true;
    if _Flag and Game.GameTimeGetFactor(GUI.GetPlayerID()) > self.Data.SpeedLimit then
        info("BundleGameHelperFunctions: Speed is capped at " ..self.Data.SpeedLimit);
        Game.GameTimeSetFactor(GUI.GetPlayerID(), self.Data.SpeedLimit);
    end
end

---
-- Überschreibt das Callback, das nach dem Ändern der Spielgeschwindigkeit
-- aufgerufen wird und installiert die Speedbremse.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:InitForbidSpeedUp()
    GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp = GameCallback_GameSpeedChanged;
    GameCallback_GameSpeedChanged = function( _Speed )
        GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp( _Speed );
        if BundleGameHelperFunctions.Local.Data.UseSpeedLimit == true then
            info("BundleGameHelperFunctions: Checking speed limit.");
            if _Speed > BundleGameHelperFunctions.Local.Data.SpeedLimit then
                info("BundleGameHelperFunctions: Speed is capped at " ..tostring(_Speed).. ".");
                Game.GameTimeSetFactor(GUI.GetPlayerID(), BundleGameHelperFunctions.Local.Data.SpeedLimit);
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleGameHelperFunctions");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleStockbreeding                                          # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht die Aufzucht von Nutzrieren wie Schafe und Kühe durch den Spieler.
-- 
-- Kosten für die Aufzucht oder die benötigte Menge an Tieren um mit der
-- Zucht zu beginnen, sind frei konfigurierbar.
--
-- Zusätzlich können die Tiere kleiner gespawnt werden und wachsen dann mit
-- der Zeit automatisch. Diese Funktionalität kann abgeschaltet werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleStockbreeding = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erlaube oder verbiete dem Spieler Schafe zu züchten.
--
-- Wenn der Spieler keine Schafe züchten soll, kann ihm dieses Recht durch
-- diese Funktion genommen werden. Natürlich kann das Recht auf diesem Weg
-- auch wieder zurückgegeben werden.
--
-- <p><b>Alias:</b> UseBreedSheeps</p>
--
-- @param[type=boolean] _Flag Schafzucht aktiv/inaktiv
-- @within Anwenderfunktionen
--
-- @usage
-- -- Schafsaufzucht ist erlaubt
-- API.UseBreedSheeps(true);
--
function API.UseBreedSheeps(_Flag)
    if GUI then
        return;
    end

    BundleStockbreeding.Global.Data.AllowBreedSheeps = _Flag == true;
    Logic.ExecuteInLuaLocalState("BundleStockbreeding.Local.Data.AllowBreedSheeps = " ..tostring(_Flag == true));
    if _Flag ~= true then
        local Price = MerchantSystem.BasePricesOrigBundleStockbreeding[Goods.G_Sheep]
        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;
        Logic.ExecuteInLuaLocalState("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);
    else
        local Price = BundleStockbreeding.Global.Data.SheepMoneyCost;
        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;
        Logic.ExecuteInLuaLocalState("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);
    end
end
UseBreedSheeps = API.UseBreedSheeps;

---
-- Erlaube oder verbiete dem Spieler Kühe zu züchten.
--
-- Wenn der Spieler keine Kühe züchten soll, kann ihm dieses Recht durch
-- diese Funktion genommen werden. Natürlich kann das Recht auf diesem Weg
-- auch wieder zurückgegeben werden.
--
-- <p><b>Alias:</b> UseBreedCattle</p>
--
-- @param[type=boolean] _Flag Kuhzucht aktiv/inaktiv
-- @within Anwenderfunktionen
--
-- @usage
-- -- Es können keine Kühe gezüchtet werden
-- API.UseBreedCattle(false);
--
function API.UseBreedCattle(_Flag)
    if GUI then
        return;
    end

    BundleStockbreeding.Global.Data.AllowBreedCattle = _Flag == true;
    Logic.ExecuteInLuaLocalState("BundleStockbreeding.Local.Data.AllowBreedCattle = " ..tostring(_Flag == true));
    if _Flag ~= true then
        local Price = MerchantSystem.BasePricesOrigBundleStockbreeding[Goods.G_Cow];
        MerchantSystem.BasePrices[Goods.G_Cow] = Price;
        Logic.ExecuteInLuaLocalState("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);
    else
        local Price = BundleStockbreeding.Global.Data.CattleMoneyCost;
        MerchantSystem.BasePrices[Goods.G_Cow] = Price;
        Logic.ExecuteInLuaLocalState("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);
    end
end
UseBreedCattle = API.UseBreedCattle;

---
-- Setzt den Typen des verwendeten Schafes.
--
-- Der EntityTyp muss nicht angegeben werden. Folgende Werte sind möglich:
-- <ul>
-- <li>0: Zufällig bei Zucht gewählt</li>
-- <li>1: A_X_Sheep01 (weiß)</li>
-- <li>2: A_X_Sheep02 (grau)</li>
-- </ul>
--
-- <b>Alias</b>: SetSheepType
--
-- @param[type=boolean] _Type Schafstyp
-- @within Anwenderfunktionen
--
-- @usage
-- -- Es wird jedes mal zufällig ausgewählt
-- API.SetSheepType(0);
-- -- Es werden nur graue Schafe erzeugt
-- API.SetSheepType(2);
--
function API.SetSheepType(_Type)
    if GUI then
        return;
    end
    if type(_Type) ~= "number" or _Type > 2 or _Type < 0 then
        log("API.SetCattleNeeded: Needed amount is invalid!", LEVEL_ERROR);
    end
    BundleStockbreeding.Global.Data.SheepType = _Type * (-1);
end
SetSheepType = API.SetSheepType;

---
-- Aktiviert oder deaktiviert den "Baby Mode" für Schafe.
--
-- Ist der Modus aktiv, werden neu gekaufte Tiere mit 40% ihrer Große erzeugt
-- und wachseln allmählich heran. Dies ist nur kosmetisch und hat keinen
-- Einfluss auf ihre Funktion.
--
-- <b>Alias</b>: SetSheepBabyMode
--
-- @param[type=boolean] _Flag Baby Mode aktivieren/deaktivieren
-- @within Anwenderfunktionen
--
-- @usage
-- -- Schafe werden verkleinert erzeugt und wachsen mit der Zeit
-- API.SetSheepBabyMode(true);
--
function API.SetSheepBabyMode(_Flag)
    if GUI then
        return;
    end
    BundleStockbreeding.Global.Data.SheepBaby = _Flag == true;
end
SetSheepBabyMode = API.SetSheepBabyMode;

---
-- Setzt die Dauer des Fütterungsintervals für Schafe.
--
-- Das Fütterungsinterval bestimmt, wie viele Sekunden es dauert, bis ein
-- Getreide durch Zucht verbraucht wird.
--
-- <b>Hinweis:</b> Das Interval ist auf 45 Sekunden voreingestellt und kann
-- nicht unter 15 Sekunden gesenkt werden.
--
-- <b>Alias</b>: SetSheepFeedingTimer
--
-- @param[type=number] _Timer Fütterungsinterval
-- @within Anwenderfunktionen
--
-- @usage
-- -- Es wird alle 60 Sekunden Getreide verbraucht.
-- API.SetSheepFeedingInvervalForBreeding(60);
--
function API.SetSheepFeedingInvervalForBreeding(_Timer)
    if GUI then
        return;
    end
    if type(_Timer) ~= "number" or _Timer < 15 then 
        error("API.SetSheepFeedingInvervalForBreeding: Time ist to short! Must be at least 15 seconds!");
        return;
    end
    BundleStockbreeding.Global.Data.SheepFeedingTimer = _Timer;
end
SetSheepFeedingTimer = API.SetSheepFeedingInvervalForBreeding;

---
-- Aktiviert oder deaktiviert den "Baby Mode" für Kühe.
--
-- Ist der Modus aktiv, werden neu gekaufte Tiere mit 40% ihrer Große erzeugt
-- und wachseln allmählich heran. Dies ist nur kosmetisch und hat keinen
-- Einfluss auf ihre Funktion.
--
-- <b>Alias</b>: SetCattleBaby
--
-- @param[type=boolean] _Flag Baby Mode aktivieren/deaktivieren
-- @within Anwenderfunktionen
--
-- @usage
-- -- Kühe werden verkleinert erzeugt und wachsen mit der Zeit
-- API.SetCattleBabyMode(true);
--
function API.SetCattleBabyMode(_Flag)
    if GUI then
        return;
    end
    BundleStockbreeding.Global.Data.CattleBaby = _Flag == true;
end
SetCattleBaby = API.SetCattleBaby;

---
-- Setzt die Dauer des Fütterungsintervals für Kühe.
--
-- Das Fütterungsinterval bestimmt, wie viele Sekunden es dauert, bis ein
-- Getreide durch Zucht verbraucht wird.
--
-- <b>Hinweis:</b> Das Interval ist auf 45 Sekunden voreingestellt und kann
-- nicht unter 15 Sekunden gesenkt werden.
--
-- <b>Alias</b>: SetCattleFeedingTimer
--
-- @param[type=number] _Timer Fütterungsinterval
-- @within Anwenderfunktionen
--
-- @usage
-- -- Es wird alle 60 Sekunden Getreide verbraucht.
-- API.SetCattleFeedingInvervalForBreeding(60);
--
function API.SetCattleFeedingInvervalForBreeding(_Timer)
    if GUI then
        return;
    end
    if type(_Timer) ~= "number" or _Timer < 15 then 
        error("API.SetCattleFeedingInvervalForBreeding: Time ist to short! Must be at least 15 seconds!");
        return;
    end
    BundleStockbreeding.Global.Data.CattleFeedingTimer = _Timer;
end
SetCattleFeedingTimer = API.SetCattleFeedingInvervalForBreeding;

---
-- Stellt die benötigte Menge an Tieren ein.
--
-- Sind weniger Tiere als angegeben im Einzugsbereich des Gatters, können
-- keine neuen Tiere gezüchtet werden.
--
-- <b>Hinweis:</b> Die Mindestmenge ist standardmäßig auf 2 eingestellt.
--
-- <b>Alias</b>: SetBreedingAnimalsAmount
--
-- @param[type=number] _Amount Menge an Tieren
-- @within Anwenderfunktionen
-- @see API.SetCatchmentAreaForPasture
--
-- @usage
-- -- Es werden keine Tiere benötigt um zu züchten.
-- API.SetRequiredAnimalsInCatchmentArea(0);
--
function API.SetRequiredAnimalsInCatchmentArea(_Amount)
    if GUI then
        return;
    end
    if type(_Amount) ~= "number" or _Amount < 0 or _Amount > 5 then
        error("API.SetRequiredAnimalsInCatchmentArea: Amount must be a number between 0 and 5!");
        return;
    end
    BundleStockbreeding.Global.Data.MinAmountNearby = _Amount;
end
SetBreedingAnimalsAmount = API.SetRequiredAnimalsInCatchmentArea;

---
-- Legt die Größe des Einzugsbereich des Gatters fest.
--
-- Im eingestellten Gebiet muss sich die Mindestmenge an Tieren aufhalten,
-- damit gezüchtet werden kann.
--
-- <b>Hinweis:</b> Der Einzugsbereich ist standardmäßig auf 3000 eingestellt
-- und kann nicht unter 800 gesenkt werden.
--
-- <b>Alias</b>: SetBreedingAreaSize
--
-- @param[type=number] _AreaSize Einzugsbereich des Gatters
-- @within Anwenderfunktionen
-- @see API.SetRequiredAnimalsInCatchmentArea
--
-- @usage
-- -- Es zählen nur Tiere innerhalb des Gatters.
-- API.SetSizeOfCatchmentAreaOfPasture(800);
-- -- Tiere auf der ganzen Map zählen.
-- API.SetSizeOfCatchmentAreaOfPasture(Logic.WorldGetSize());
--
function API.SetSizeOfCatchmentAreaOfPasture(_AreaSize)
    if GUI then
        return;
    end
    if type(_AreaSize) ~= "number" or _AreaSize < 800 then
        error("API.SetSizeOfCatchmentAreaOfPasture: Amount must be at least 800!");
        return;
    end
    BundleStockbreeding.Global.Data.AreaSizeNearby = _AreaSize;
end
SetBreedingAreaSize = API.SetSizeOfCatchmentAreaOfPasture;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleStockbreeding = {
    Global = {
        Data = {
            AnimalChildren = {},
            GrothTime = 45,
            ShrinkedSize = 0.4,
            MinAmountNearby = 2,
            AreaSizeNearby = 3000,

            AllowBreedCattle = true,
            CattlePastures = {},
            CattleBaby = true,
            CattleFeedingTimer = 45,
            CattleMoneyCost = 300,

            AllowBreedSheeps = true,
            SheepPastures = {},
            SheepBaby = true,
            SheepFeedingTimer = 45,
            SheepMoneyCost = 300,
            SheepType = -1,
        }
    },
    Local = {
        Data = {
            AllowBreedCattle = true,
            AllowBreedSheeps = true,
        },

        Description = {
            BreedingActive = {
                Title = {
                    de = "Zucht aktiv",
                    en = "Breeding active",
                },
                Text = {
                    de = "- Klicken um Zucht zu stoppen",
                    en = "- Click to stop breeding",
                },
                Disabled = {
                    de = "Zucht ist gesperrt!",
                    en = "Breeding is locked!",
                },
            },
            BreedingInactive = {
                Title = {
                    de = "Zucht gestoppt",
                    en = "Breeding stopped",
                },
                Text = {
                    de = "- Klicken um Zucht zu starten {cr}- Benötigt Platz {cr}- Benötigt Getreide",
                    en = "- Click to allow breeding {cr}- Requires space {cr}- Requires grain",
                },
                Disabled = {
                    de = "Zucht ist gesperrt!",
                    en = "Breeding is locked!",
                },
            },
        },
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:Install()
    MerchantSystem.BasePricesOrigBundleStockbreeding                = {};
    MerchantSystem.BasePricesOrigBundleStockbreeding[Goods.G_Sheep] = MerchantSystem.BasePrices[Goods.G_Sheep];
    MerchantSystem.BasePricesOrigBundleStockbreeding[Goods.G_Cow]   = MerchantSystem.BasePrices[Goods.G_Cow];

    MerchantSystem.BasePrices[Goods.G_Sheep] = BundleStockbreeding.Global.Data.SheepMoneyCost;
    MerchantSystem.BasePrices[Goods.G_Cow]   = BundleStockbreeding.Global.Data.CattleMoneyCost;

    StartSimpleJobEx(self.AnimalBreedJob);
    StartSimpleJobEx(self.AnimalGrouthJob);
end

---
-- Gibt die Skalierung (Größe) eines Entity zurück.
-- @param              _Entity Skriptname oder EntityID des Entity
-- @return[type=number] Skalierung des Entity
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:GetScale(_Entity)
    local ID = GetID(_Entity);
    local SV = QSB.ScriptingValues[QSB.ScriptingValues.Game].Size;
    local IntVal = Logic.GetEntityScriptingValue(ID, SV);
    return Core:ScriptingValueIntegerToFloat(IntVal);
end

---
-- Setzt die Skalierung (Größe) eines Entity.
-- @param              _Entity Skriptname oder EntityID des Entity
-- @param[type=number] _Scale  Zu setzende Größe
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:SetScale(_Entity, _Scale)
    local ID = GetID(_Entity);
    local SV = QSB.ScriptingValues[QSB.ScriptingValues.Game].Size;
    local IntVal = Core:ScriptingValueFloatToInteger(_Scale);
    Logic.SetEntityScriptingValue(ID, SV, IntVal);
end

---
-- Erzeugt ein Nutztier vor dem Gatter und zieht die Kosten ab.
--
-- Falls der "Baby Mode" für die Tierart aktiv ist, wird das Tier kleiner
-- gemacht und zur Wachstumskontrolle hinzugefügt.
--
-- @param[type=number]  _PastureID Gatter ID
-- @param[type=number]  _Type      Typ des Tieres
-- @param[type=number]  _GrainCost Getreidekosten
-- @param[type=boolean] _Shrink    Tier geschrumptf erzeugen
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:CreateAnimal(_PastureID, _Type, _Shrink)
    local PlayerID = Logic.EntityGetPlayer(_PastureID);
    local x, y = Logic.GetBuildingApproachPosition(_PastureID);
    local Type = (_Type > 0 and _Type) or (_Type == 0 and Entities["A_X_Sheep0" ..math.random(1, 2)]) or Entities["A_X_Sheep0" ..(_Type * (-1))];
    local ID = Logic.CreateEntity(Type, x, y, 0, PlayerID);
    if _Shrink == true then
        self:SetScale(ID, self.Data.ShrinkedSize);
        table.insert(self.Data.AnimalChildren, {ID, self.Data.GrothTime});
    end
end

---
-- Gibt zurück, nach wie viel Zeit ein neues Tier erzeugt werden kann.
-- @param[type=number] _Animals Anzahl Tiere im Gatter
-- @return[type=number] Benötigte Zeit in Sekunden
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:BreedingTimeTillNext(_Animals)
    if self.Data.MinAmountNearby <= _Animals then
        local Time = 240 - (_Animals * 15);
        if Time < 30 then
            Time = 30;
        end
        return Time;
    end
    return -1;
end

---
-- Gibt zurück, ob der Spieler noch freie Plätze für Kühe hat.
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=boolean] Platz vorhanden
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:IsCattleNeeded(_PlayerID)
    local AmountOfCattle = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CattlePasture)};
    local AmountOfPasture = Logic.GetNumberOfEntitiesOfTypeOfPlayer(_PlayerID, Entities.B_CattlePasture);
    return #AmountOfCattle < AmountOfPasture * 5;
end

---
-- Gibt zurück, ob der Spieler noch freie Plätze für Schafe hat.
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=boolean] Platz vorhanden
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:IsSheepNeeded(_PlayerID)
    local AmountOfSheep = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.SheepPasture)};
    local AmountOfPasture = Logic.GetNumberOfEntitiesOfTypeOfPlayer(_PlayerID, Entities.B_SheepPasture);
    return #AmountOfSheep < AmountOfPasture * 5;
end

---
-- Gibt die Menge der Kühe zurück, die sich im Gatter befinden.
-- @param[type=_PastureID] ID des Gatter
-- @return[type=number] Kühe im Gatter
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:CountCattleNearby(_PastureID)
    local PlayerID = Logic.EntityGetPlayer(_PastureID);
    local x, y, z  = Logic.EntityGetPos(_PastureID);
    local AreaSize = self.Data.AreaSizeNearby;
    local Cattle   = {Logic.GetPlayerEntitiesInArea(PlayerID, Entities.A_X_Cow01, x, y, AreaSize, 16)};
    table.remove(Cattle, 1);
    return #Cattle;
end

---
-- Gibt die Menge der Schafe zurück, die sich im Gatter befinden.
-- @param[type=_PastureID] ID des Gatter
-- @return[type=number] Schafe im Gatter
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:CountSheepsNearby(_PastureID)
    local PlayerID = Logic.EntityGetPlayer(_PastureID);
    local x, y, z  = Logic.EntityGetPos(_PastureID);
    local AreaSize = self.Data.AreaSizeNearby;
    local Sheeps1  = {Logic.GetPlayerEntitiesInArea(PlayerID, Entities.A_X_Sheep01, x, y, AreaSize, 16)};
    local Sheeps2  = {Logic.GetPlayerEntitiesInArea(PlayerID, Entities.A_X_Sheep02, x, y, AreaSize, 16)};
    table.remove(Sheeps1, 1);
    table.remove(Sheeps1, 1);
    return #Sheeps1 + #Sheeps2;
end

---
-- Steuert die Produktion neuer Tiere der einzelnen Gatter.
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:AnimalBreedController()
    local PlayerID = QSB.HumanPlayerID;

    -- Kühe
    if self.Data.AllowBreedCattle then
        local Pastures = GetPlayerEntities(PlayerID, Entities.B_CattlePasture);
        for k, v  in pairs(Pastures) do
            -- Tiere zählen
            local AmountNearby = self:CountCattleNearby(v);
            -- Zuchtzähler
            self.Data.CattlePastures[v] = self.Data.CattlePastures[v] or 0;
            if self:IsCattleNeeded(PlayerID) and Logic.IsBuildingStopped(v) == false then
                self.Data.CattlePastures[v] = self.Data.CattlePastures[v] +1;
                -- Alle X Sekunden wird 1 Getreide verbraucht
                local FeedingTime = self.Data.CattleFeedingTimer;
                if self.Data.CattlePastures[v] > 0 and FeedingTime > 0 and Logic.GetTime() % FeedingTime == 0 then
                    if GetPlayerResources(Goods.G_Grain, PlayerID) > 0 then
                        AddGood(Goods.G_Grain, -1, PlayerID);
                    else
                        self.Data.CattlePastures[v] = self.Data.CattlePastures[v] - FeedingTime;
                    end
                end
            end
            -- Kuh spawnen
            local TimeTillNext = self:BreedingTimeTillNext(AmountNearby);
            if TimeTillNext > -1 and self.Data.CattlePastures[v] > TimeTillNext then
                local x, y, z = Logic.EntityGetPos(v);
                if self:IsCattleNeeded(PlayerID) then
                    self:CreateAnimal(v, Entities.A_X_Cow01, self.Data.CattleBaby);
                    self.Data.CattlePastures[v] = 0;
                end
            end
        end
    end

    -- Schafe
    if self.Data.AllowBreedSheeps then
        local Pastures = GetPlayerEntities(PlayerID, Entities.B_SheepPasture);
        for k, v  in pairs(Pastures) do
            -- Tier zählen
            local AmountNearby = self:CountSheepsNearby(v);
            -- Zuchtzähler
            self.Data.SheepPastures[v] = self.Data.SheepPastures[v] or 0;
            if self:IsSheepNeeded(PlayerID) and Logic.IsBuildingStopped(v) == false then
                self.Data.SheepPastures[v] = self.Data.SheepPastures[v] +1;
                -- Alle X Sekunden wird 1 Getreide verbraucht
                local FeedingTime = self.Data.SheepFeedingTimer;
                if self.Data.SheepPastures[v] > 0 and FeedingTime > 0 and Logic.GetTime() % FeedingTime == 0 then
                    if GetPlayerResources(Goods.G_Grain, PlayerID) > 0 then
                        AddGood(Goods.G_Grain, -1, PlayerID);
                    else
                        self.Data.SheepPastures[v] = self.Data.SheepPastures[v] - FeedingTime;
                    end
                end
            end
            -- Schaf spawnen
            local TimeTillNext = self:BreedingTimeTillNext(AmountNearby);
            if TimeTillNext > -1 and self.Data.SheepPastures[v] > TimeTillNext then
                local x, y, z = Logic.EntityGetPos(v);
                if self:IsSheepNeeded(PlayerID) then
                    self:CreateAnimal(v, self.Data.SheepType, self.Data.SheepBaby);
                    self.Data.SheepPastures[v] = 0;
                end
            end
        end
    end
end

---
-- Steuert das Wachstum aller registrierten Tiere.
-- @within Internal
-- @local
--
function BundleStockbreeding.Global:AnimalGrouthController()
    for k, v in pairs(self.Data.AnimalChildren) do
        if v then
            if not IsExisting(v[1]) then
                self.Data.AnimalChildren[k] = nil;
            else
                self.Data.AnimalChildren[k][2] = v[2] -1;
                if v[2] < 0 then
                    self.Data.AnimalChildren[k][2] = self.Data.GrothTime;
                    local Scale = self:GetScale(v[1]);
                    if Scale < 1 then
                        self:SetScale(v[1], Scale + 0.1);
                    else
                        self.Data.AnimalChildren[k] = nil;
                    end
                end
            end
        end
    end
end

-- Controller Job ruft nur eigentlichen Controller auf.
function BundleStockbreeding.Global.AnimalBreedJob()
    BundleStockbreeding.Global:AnimalBreedController();
end

-- Controller Job ruft nur eigentlichen Controller auf.
function BundleStockbreeding.Global.AnimalGrouthJob()
    BundleStockbreeding.Global:AnimalGrouthController();
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleStockbreeding.Local:Install()
    MerchantSystem.BasePricesOrigBundleStockbreeding                = {};
    MerchantSystem.BasePricesOrigBundleStockbreeding[Goods.G_Sheep] = MerchantSystem.BasePrices[Goods.G_Sheep];
    MerchantSystem.BasePricesOrigBundleStockbreeding[Goods.G_Cow]   = MerchantSystem.BasePrices[Goods.G_Cow];

    MerchantSystem.BasePrices[Goods.G_Sheep] = BundleStockbreeding.Local.Data.SheepMoneyCost;
    MerchantSystem.BasePrices[Goods.G_Cow]   = BundleStockbreeding.Local.Data.CattleMoneyCost;

    self:OverwriteBuySiegeEngine();
end

---
-- Schaltet den Zuchtstatus des Gatters um.
-- @param[type=number] _BarrackID ID des Gatter
-- @within Internal
-- @local
--
function BundleStockbreeding.Local:ToggleBreedingState(_BarrackID)
    local BuildingEntityType = Logic.GetEntityType(_BarrackID);
    if BuildingEntityType == Entities.B_CattlePasture then
        GUI.SetStoppedState(_BarrackID, not Logic.IsBuildingStopped(_BarrackID));
    elseif BuildingEntityType == Entities.B_SheepPasture then
        GUI.SetStoppedState(_BarrackID, not Logic.IsBuildingStopped(_BarrackID));
    end
end

---
-- Diese Funktion überschreibt die Belagerungswaffenwerkstattsteuerung. Dabei
-- wird die Nutztierzucht implementiert.
--
-- @within Internal
-- @local
--
function BundleStockbreeding.Local:OverwriteBuySiegeEngine()
    GUI_BuildingButtons.BuySiegeEngineCartMouseOver = function(_EntityType,_TechnologyType)
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local BarrackID = GUI.GetSelectedEntity();
        local BuildingEntityType = Logic.GetEntityType(BarrackID);

        if  BuildingEntityType ~= Entities.B_SiegeEngineWorkshop
        and BuildingEntityType ~= Entities.B_CattlePasture
        and BuildingEntityType ~= Entities.B_SheepPasture then
            return;
        end

        local Costs = {Logic.GetUnitCost(BarrackID, _EntityType)}

        if BuildingEntityType == Entities.B_CattlePasture then
            local Description = BundleStockbreeding.Local.Description.BreedingActive;
            if Logic.IsBuildingStopped(BarrackID) then
                Description = BundleStockbreeding.Local.Description.BreedingInactive;
            end
            BundleStockbreeding.Local:TextCosts(
                API.Localize(Description.Title), API.Localize(Description.Text), API.Localize(Description.Disabled),
                {Goods.G_Grain, 1},
                false
            );
        elseif BuildingEntityType == Entities.B_SheepPasture then
            local Description = BundleStockbreeding.Local.Description.BreedingActive;
            if Logic.IsBuildingStopped(BarrackID) then
                Description = BundleStockbreeding.Local.Description.BreedingInactive;
            end
            BundleStockbreeding.Local:TextCosts(
                API.Localize(Description.Title), API.Localize(Description.Text), API.Localize(Description.Disabled),
                {Goods.G_Grain, 1},
                false
            );
        else
            GUI_Tooltip.TooltipBuy(Costs,nil,nil,_TechnologyType);
        end
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.BuySiegeEngineCartClicked_Orig_Stockbreeding = GUI_BuildingButtons.BuySiegeEngineCartClicked
    GUI_BuildingButtons.BuySiegeEngineCartClicked = function(_EntityType)
        local BarrackID = GUI.GetSelectedEntity()
        local eType = Logic.GetEntityType(BarrackID)
        if eType == Entities.B_CattlePasture or eType == Entities.B_SheepPasture then
            BundleStockbreeding.Local:ToggleBreedingState(BarrackID);
        else
            GUI_BuildingButtons.BuySiegeEngineCartClicked_Orig_Stockbreeding(_EntityType)
        end
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.BuySiegeEngineCartUpdate = function(_Technology)
        local PlayerID = GUI.GetPlayerID();
        local KnightTitle = Logic.GetKnightTitle(PlayerID);
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        local EntityType = Logic.GetEntityType(EntityID);
        local grain = GetPlayerResources(Goods.G_Grain,PlayerID);
        local pos = GetPosition(EntityID);

        if EntityType == Entities.B_SiegeEngineWorkshop then
            XGUIEng.ShowWidget(CurrentWidgetID,1);
            if _Technology == Technologies.R_BatteringRam then
                SetIcon(CurrentWidgetID, {9,5});
            elseif _Technology == Technologies.R_SiegeTower then
                SetIcon(CurrentWidgetID, {9,6});
            elseif _Technology == Technologies.R_Catapult then
                SetIcon(CurrentWidgetID, {9,4});
            end
        elseif EntityType == Entities.B_CattlePasture then
            local Icon = {4, 13};
            if Logic.IsBuildingStopped(EntityID) then
                Icon = {4, 12};
            end
            SetIcon(CurrentWidgetID, Icon);

            if _Technology == Technologies.R_Catapult and BundleStockbreeding.Local.Data.AllowBreedCattle then
                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons",1);
                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart",1);

                local DisableState = (BundleStockbreeding.Local.Data.AllowBreedCattle and 0) or 1;
                XGUIEng.DisableButton(CurrentWidgetID, DisableState);
                XGUIEng.ShowWidget(CurrentWidgetID, 1);
            else
                XGUIEng.ShowWidget(CurrentWidgetID, 0);
            end
        elseif EntityType == Entities.B_SheepPasture then
            local Icon = {4, 13};
            if Logic.IsBuildingStopped(EntityID) then
                Icon = {4, 12};
            end
            SetIcon(CurrentWidgetID, Icon)

            if _Technology == Technologies.R_Catapult and BundleStockbreeding.Local.Data.AllowBreedSheeps then
                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons",1);
                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart",1);

                local DisableState = (BundleStockbreeding.Local.Data.AllowBreedSheeps and 0) or 1;
                XGUIEng.DisableButton(CurrentWidgetID, DisableState);
                XGUIEng.ShowWidget(CurrentWidgetID, 1);
            else
                XGUIEng.ShowWidget(CurrentWidgetID, 0);
            end
        else
            XGUIEng.ShowWidget(CurrentWidgetID,0);
            return;
        end

        if Logic.IsConstructionComplete(GUI.GetSelectedEntity()) == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID,0);
            return;
        end

        if EntityType ~= Entities.B_SheepPasture and EntityType ~= Entities.B_CattlePasture then
            local TechnologyState = Logic.TechnologyGetState(PlayerID, _Technology);
            if EnableRights == nil or EnableRights == false then
                XGUIEng.DisableButton(CurrentWidgetID,0);
                return
            end
            if TechnologyState == TechnologyStates.Researched then
                XGUIEng.DisableButton(CurrentWidgetID,0);
            else
                XGUIEng.DisableButton(CurrentWidgetID,1);
            end
        end
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    HouseMenuStopProductionClicked_Orig_Stockbreeding = HouseMenuStopProductionClicked;
    HouseMenuStopProductionClicked = function()
        HouseMenuStopProductionClicked_Orig_Stockbreeding();
        local WidgetName = HouseMenu.Widget.CurrentBuilding;
        local EntityType = Entities[WidgetName];
        local PlayerID = GUI.GetPlayerID();
        local Bool = HouseMenu.StopProductionBool;

        if EntityType == Entities.B_CattleFarm then
            local Buildings = GetPlayerEntities(PlayerID, Entities.B_CattlePasture);
            for i=1, #Buildings, 1 do
                GUI.SetStoppedState(Buildings[i], Bool);
            end
        elseif EntityType == Entities.B_SheepFarm then
            local Buildings = GetPlayerEntities(PlayerID, Entities.B_SheepPasture);
            for i=1, #Buildings, 1 do
                GUI.SetStoppedState(Buildings[i], Bool);
            end
        end
    end
end

---
-- Setzt den Kostentooltip des aktuellen Widgets.
--
-- @param[type=string]  _Title        Titel des Tooltip
-- @param[type=string]  _Text         Text des Tooltip
-- @param[type=string]  _DisabledText (optional) Textzusatz wenn inaktiv
-- @param[type=number]  _Costs        Kostentabelle
-- @param[type=boolean] _InSettlement Kosten in Siedlung suchen
-- @within Internal
-- @local
--
function BundleStockbreeding.Local:TextCosts(_Title, _Text, _DisabledText, _Costs, _InSettlement)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")
    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")
    local PositionWidget = XGUIEng.GetCurrentWidgetID()
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)
    GUI_Tooltip.SetCosts(TooltipCostsContainer, _Costs, _InSettlement)
    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)
    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)

    _DisabledText = _DisabledText or "";
    local disabled = ""
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title)
    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled)
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleStockbreeding");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleSymfoniaBehaviors                                      # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle enthält einige weitere nützliche Behavior, welche es so nicht
-- in der ursprünglichen QSB gab.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleSymfoniaBehaviors = {};

API = API or {};
QSB = QSB or {};

QSB.VictoryWithPartyEntities = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

-- Hier gibt es keine Funktionen!

-- -------------------------------------------------------------------------- --
-- Goals                                                                      --
-- -------------------------------------------------------------------------- --

---
-- Ein Entity muss sich zu einem Ziel bewegen und eine Distanz unterschreiten.
--
-- Optional kann das Ziel mit einem Marker markiert werden.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Target     Skriptname des Ziels
-- @param _Distance   Entfernung
-- @param _UseMarker  Ziel markieren
--
-- @within Goal
--
function Goal_MoveToPosition(...)
    return b_Goal_MoveToPosition:new(...);
end

b_Goal_MoveToPosition = {
    Name = "Goal_MoveToPosition",
    Description = {
        en = "Goal: A entity have to moved as close as the distance to another entity. The target can be marked with a static marker.",
        de = "Ziel: Eine Entity muss sich einer anderen bis auf eine bestimmte Distanz nähern. Die Lupe wird angezeigt, das Ziel kann markiert werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",   de = "Entity" },
        { ParameterType.ScriptName, en = "Target",   de = "Ziel" },
        { ParameterType.Number,     en = "Distance", de = "Entfernung" },
        { ParameterType.Custom,     en = "Marker",   de = "Ziel markieren" },
    },
}

function b_Goal_MoveToPosition:GetGoalTable()
    return {Objective.Distance, self.Entity, self.Target, self.Distance, self.Marker}
end

function b_Goal_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter
    elseif (_Index == 1) then
        self.Target = _Parameter
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1
    elseif (_Index == 3) then
        self.Marker = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Goal_MoveToPosition:GetCustomData( _Index )
    local Data = {};
    if _Index == 3 then
        Data = {"true", "false"}
    end
    return Data
end

Core:RegisterBehavior(b_Goal_MoveToPosition);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss einen bestimmten Quest abschließen.
--
-- @param _QuestName Name des Quest
--
-- @within Goal
--
function Goal_WinQuest(...)
    return b_Goal_WinQuest:new(...);
end

b_Goal_WinQuest = {
    Name = "Goal_WinQuest",
    Description = {
        en = "Goal: The player has to win a given quest",
        de = "Ziel: Der Spieler muss eine angegebene Quest erfolgreich abschliessen.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name",      de = "Questname" },
    },
}

function b_Goal_WinQuest:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_WinQuest:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Quest = _Parameter;
    end
end

function b_Goal_WinQuest:CustomFunction(_Quest)
    local quest = Quests[GetQuestID(self.Quest)];
    if quest then
        if quest.Result == QuestResult.Failure then
            return false;
        end
        if quest.Result == QuestResult.Success then
            return true;
        end
    end
    return nil;
end

function b_Goal_WinQuest:Debug(_Quest)
    if Quests[GetQuestID(self.Quest)] == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Quest '"..self.Quest.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_WinQuest);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss eine bestimmte Menge Gold mit Dieben stehlen.
--
-- Dabei ist es egal von welchem Spieler. Diebe können Gold nur aus
-- Stadtgebäude stehlen und nur von feindlichen Spielern.
--
-- <b>Hinweis</b>:Das Behavior cheatet allen Zielspielern Einnahmen in den
-- Gebäuden, damit der Quest stets erfüllbar bleibt. Dies gilt auch, wenn
-- der menschliche Spieler das Ziel ist!
--
-- @param _Amount       Menge an Gold
-- @param _ShowProgress Fortschritt ausgeben
--
-- @within Goal
--
function Goal_StealGold(...)
    return b_Goal_StealGold:new(...)
end

b_Goal_StealGold = {
    Name = "Goal_StealGold",
    Description = {
        en = "Goal: Steal an explicit amount of gold from a players or any players city buildings.",
        de = "Ziel: Diebe sollen eine bestimmte Menge Gold aus feindlichen Stadtgebäuden stehlen.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount on Gold", de = "Zu stehlende Menge" },
        { ParameterType.Custom,   en = "Target player",  de = "Spieler von dem gestohlen wird" },
        { ParameterType.Custom,   en = "Print progress", de = "Fortschritt ausgeben" },
    },
}

function b_Goal_StealGold:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_StealGold:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 1) then
        local PlayerID = tonumber(_Paramater) or -1;
        self.Target = PlayerID * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or "true"
        self.Printout = AcceptAlternativeBoolean(_Parameter);
    end
    self.StohlenGold = 0;
end

function b_Goal_StealGold:GetCustomData(_Index)
    if _Index == 1 then
        return { "-", 1, 2, 3, 4, 5, 6, 7, 8 };
    elseif _Index == 2 then
        return { "true", "false" };
    end
end

function b_Goal_StealGold:SetDescriptionOverwrite(_Quest)
    local TargetPlayerName = API.Localize({
        de = " anderen Spielern ",
        en = " different parties"
    });

    if self.Target ~= -1 then
        TargetPlayerName = GetPlayerName(self.Target);
        if TargetPlayerName == nil or TargetPlayerName == "" then
            TargetPlayerName = " PLAYER_NAME_MISSING ";
        end
    end

    -- Cheat earnings
    local PlayerIDs = {self.Target};
    if self.Target == -1 then
        PlayerIDs = {1, 2, 3, 4, 5, 6, 7, 8};
    end
    for i= 1, #PlayerIDs, 1 do
        if i ~= _Quest.ReceivingPlayer and Logic.GetStoreHouse(i) ~= 0 then
            local CityBuildings = {Logic.GetPlayerEntitiesInCategory(i, EntityCategories.CityBuilding)};
            for j= 1, #CityBuildings, 1 do
                local CurrentEarnings = Logic.GetBuildingProductEarnings(CityBuildings[j]);
                if CurrentEarnings < 45 and Logic.GetTime() % 5 == 0 then
                    Logic.SetBuildingEarnings(CityBuildings[j], CurrentEarnings +1);
                end
            end
        end
    end

    local amount = self.Amount-self.StohlenGold;
    amount = (amount > 0 and amount) or 0;
    local text = {
        de = "Gold von %s stehlen {cr}{cr}Aus Stadtgebäuden zu stehlende Goldmenge: %d",
        en = "Steal gold from %s {cr}{cr}Amount on gold to steal from city buildings: %d",
    };
    return "{center}" ..string.format(API.Localize(text), TargetPlayerName, amount);
end

function b_Goal_StealGold:CustomFunction(_Quest)
    Core:ChangeCustomQuestCaptionText(self:SetDescriptionOverwrite(_Quest), _Quest);

    if self.StohlenGold >= self.Amount then
        return true;
    end
    return nil;
end

function b_Goal_StealGold:GetIcon()
    return {5,13};
end

function b_Goal_StealGold:Debug(_Quest)
    if tonumber(self.Amount) == nil and self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

function b_Goal_StealGold:Reset(_Quest)
    self.StohlenGold = 0;
end

Core:RegisterBehavior(b_Goal_StealGold)

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss ein bestimmtes Stadtgebäude bestehlen.
--
-- Eine Kirche wird immer Sabotiert. Ein Lagerhaus verhält sich ähnlich zu
-- einer Burg.
--
-- <b>Hinweis</b>: Das Behavior cheatet in dem Zielgebäude Einnahmen, damit
-- ein Dieb entsandt werden kann.
--
-- @param _ScriptName Skriptname des Gebäudes
--
-- @within Goal
--
function Goal_StealBuilding(...)
    return b_Goal_StealBuilding:new(...)
end

b_Goal_StealBuilding = {
    Name = "Goal_StealBuilding",
    Description = {
        en = "Goal: The player has to steal from a building. Not a castle and not a village storehouse!",
        de = "Ziel: Der Spieler muss ein bestimmtes Gebäude bestehlen. Dies darf keine Burg und kein Dorflagerhaus sein!",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Building", de = "Gebäude" },
    },
}

function b_Goal_StealBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_StealBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    end
    self.RobberList = {};
end

function b_Goal_StealBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function b_Goal_StealBuilding:SetDescriptionOverwrite(_Quest)
    local isCathedral = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Cathedrals) == 1;
    local isWarehouse = Logic.GetEntityType(GetID(self.Building)) == Entities.B_StoreHouse;
    local text;

    if isCathedral then
        text = {
            de = "Sabotage {cr}{cr} Sabotiert die mit Pfeil markierte Kirche.",
            en = "Sabotage {cr}{cr} Sabotage the Church of the opponent.",
        };
    elseif isWarehouse then
        text = {
            de = "Lagerhaus bestehlen {cr}{cr} Sendet einen Dieb in das markierte Lagerhaus.",
            en = "Steal from storehouse {cr}{cr} Steal from the marked storehouse.",
        };
    else
        text = {
            de = "Gebäude bestehlen {cr}{cr} Bestehlt das durch einen Pfeil markierte Gebäude.",
            en = "Steal from building {cr}{cr} Steal from the building marked by an arrow.",
        };
    end
    return "{center}" .. API.Localize(text);
end

function b_Goal_StealBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    local BuildingID = GetID(self.Building);
    if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
    and Logic.GetBuildingEarnings(BuildingID) < 10 then
        Logic.SetBuildingEarnings(BuildingID, 10);
    end

    if self.SuccessfullyStohlen then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function b_Goal_StealBuilding:GetIcon()
    return {5,13};
end

function b_Goal_StealBuilding:Debug(_Quest)
    local eTypeName = Logic.GetEntityTypeName(Logic.GetEntityType(GetID(self.Building)));
    local IsHeadquarter = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Headquarters) == 1;
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is destroyed :(");
        return true;
    elseif string.find(eTypeName, "B_NPC_BanditsHQ") or string.find(eTypeName, "B_NPC_Cloister") or string.find(eTypeName, "B_NPC_StoreHouse") then
        error(_Quest.Identifier.. ": " ..self.Name .. ": village storehouses are not allowed!");
        return true;
    elseif IsHeadquarter then
        error(_Quest.Identifier.. ": " ..self.Name .. ": use Goal_StealInformation for headquarters!");
        return true;
    end
    return false;
end

function b_Goal_StealBuilding:Reset(_Quest)
    self.SuccessfullyStohlen = false;
    self.RobberList = {};
    self.Marker = nil;
end

function b_Goal_StealBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

Core:RegisterBehavior(b_Goal_StealBuilding)

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss ein Gebäude mit einem Dieb ausspoinieren.
--
-- Der Quest ist erfolgreich, sobald der Dieb in das Gebäude eindringt. Es
-- muss sich um ein Gebäude handeln, das bestohlen werden kann (Burg, Lager,
-- Kirche, Stadtgebäude mit Einnahmen)!
--
-- Optional kann der Dieb nach Abschluss gelöscht werden. Diese Option macht
-- es einfacher ihn durch z.B. einen Abfahrenden U_ThiefCart zu "ersetzen".
--
-- <b>Hinweis</b>:Das Behavior cheatet in dem Zielgebäude Einnahmen, damit
-- ein Dieb entsandt werden kann.
--
-- @param _ScriptName  Skriptname des Gebäudes
-- @param _DeleteThief Dieb nach Abschluss löschen
--
-- @within Goal
--
function Goal_SpyBuilding(...)
    return b_Goal_SpyBuilding:new(...)
end

b_Goal_SpyBuilding = {
    Name = "Goal_SpyBuilding",
    IconOverwrite = {5,13},
    Description = {
        en = "Goal: Infiltrate a building with a thief. A thief must be able to steal from the target building.",
        de = "Ziel: Infiltriere ein Gebäude mit einem Dieb. Nur mit Gebaueden möglich, die bestohlen werden koennen.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target Building", de = "Zielgebäude" },
        { ParameterType.Custom,     en = "Destroy Thief", de = "Dieb löschen" },
    },
}

function b_Goal_SpyBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_SpyBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    elseif (_Index == 1) then
        _Parameter = _Parameter or "true"
        self.Delete = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Goal_SpyBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function b_Goal_SpyBuilding:SetDescriptionOverwrite(_Quest)
    if not _Quest.QuestDescription then
        local text = {
            de = "Gebäude infriltrieren {cr}{cr}Spioniere das markierte Gebäude mit einem Dieb aus!",
            en = "Infiltrate building {cr}{cr}Spy on the highlighted buildings with a thief!",
        };
        return API.Localize(text);
    else
        return _Quest.QuestDescription;
    end
end

function b_Goal_SpyBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    local BuildingID = GetID(self.Building);
    if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
    and Logic.GetBuildingEarnings(BuildingID) < 10 then
        Logic.SetBuildingEarnings(BuildingID, 10);
    end

    if self.Infiltrated then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function b_Goal_SpyBuilding:GetIcon()
    return self.IconOverwrite;
end

function b_Goal_SpyBuilding:Debug(_Quest)
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is destroyed :(");
        return true;
    end
    return false;
end

function b_Goal_SpyBuilding:Reset(_Quest)
    self.Infiltrated = false;
    self.Marker = nil;
end

function b_Goal_SpyBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

Core:RegisterBehavior(b_Goal_SpyBuilding);

-- -------------------------------------------------------------------------- --

---
-- Es muss eine Menge an Munition in der Kriegsmaschine erreicht werden.
--
-- <u>Relationen</u>
-- <ul>
-- <li>>= - Anzahl als Mindestmenge</li>
-- <li>< - Weniger als Anzahl</li>
-- </ul>
--
-- @param _ScriptName  Name des Kriegsgerät
-- @param _Relation    Mengenrelation
-- @param _Amount      Menge an Munition
--
-- @within Goal
--
function Goal_AmmunitionAmount(...)
    return b_Goal_AmmunitionAmount:new(...);
end

b_Goal_AmmunitionAmount = {
    Name = "Goal_AmmunitionAmount",
    Description = {
        en = "Goal: Reach a smaller or bigger value than the given amount of ammunition in a war machine.",
        de = "Ziel: Ueber- oder unterschreite die angegebene Anzahl Munition in einem Kriegsgerät.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
        { ParameterType.Number, en = "Amount", de = "Menge" },
    },
}

function b_Goal_AmmunitionAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_AmmunitionAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or _Parameter == "<"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function b_Goal_AmmunitionAmount:CustomFunction()
    local EntityID = GetID(self.Scriptname);
    if not IsExisting(EntityID) then
        return false;
    end
    local HaveAmount = Logic.GetAmmunitionAmount(EntityID);
    if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then
        return true;
    end
    return nil;
end

function b_Goal_AmmunitionAmount:Debug(_Quest)
    if self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount is negative");
        return true
    end
end

function b_Goal_AmmunitionAmount:GetCustomData( _Index )
    if _Index == 1 then
        return {"<", ">="};
    end
end

Core:RegisterBehavior(b_Goal_AmmunitionAmount)

-- -------------------------------------------------------------------------- --

---
-- Eine Menge an Entities des angegebenen Spawnpoint muss zerstört werden.
--
-- <b>Hinweis</b>: Eignet sich vor allem für Raubtiere!
--
-- Wenn die angegebene Anzahl zu Beginn des Quest nicht mit der Anzahl an
-- bereits gespawnten Entities übereinstimmt, wird dies automatisch korrigiert.
-- (Neue Entities gespawnt bzw. überschüssige gelöscht)
--
-- Wenn _Prefixed gesetzt ist, wird anstatt des Namen Entities mit einer
-- fortlaufenden Nummer gesucht, welche mit dem Namen beginnen. Bei der
-- ersten Nummer, zu der kein Entity existiert, wird abgebrochen.
--
-- @param[type=string] _SpawnPoint Skriptname des Spawnpoint
-- @param[type=number] _Amount     Menge zu zerstörender Entities
-- @param[type=number] _Prefixed   Skriptname ist Präfix
--
-- @within Goal
--
function Goal_DestroySpawnedEntities(...)
    return b_Goal_DestroySpawnedEntities:new(...);
end

b_Goal_DestroySpawnedEntities = {
    Name = "Goal_DestroySpawnedEntities",
    Description = {
        en = "Goal: Destroy all entities spawned at the spawnpoint.",
        de = "Ziel: Zerstöre alle Entitäten, die bei dem Spawnpoint erzeugt wurde.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Spawnpoint",       de = "Spawnpoint" },
        { ParameterType.Number,     en = "Amount",           de = "Menge" },
        { ParameterType.Custom,     en = "Name is prefixed", de = "Name ist Präfix" },
    },
};

function b_Goal_DestroySpawnedEntities:GetGoalTable()
    -- Zur Erzeugungszeit Spawnpoint konvertieren
    -- Hinweis: Entities müssen zu diesem Zeitpunkt existieren und müssen
    -- Spawnpoints sein!
    if self.Prefixed then
        local Parameter = table.remove(self.SpawnPoint);
        local i = 1;
        while (IsExisting(Parameter .. i)) do
            table.insert(self.SpawnPoint, Parameter .. i);
            i = i +1;
        end
        -- Hard Error!
        assert(#self.SpawnPoint > 0, "No spawnpoints found!");
    end
    -- Behavior zurückgeben
    return {Objective.DestroyEntities, 3, self.SpawnPoint, self.Amount};
end

function b_Goal_DestroySpawnedEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SpawnPoint = {_Parameter};
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or "false";
        self.Prefixed = AcceptAlternativeBoolean(_Parameter);
    end
end

function b_Goal_DestroySpawnedEntities:GetMsgKey()
    local ID = GetID(self.SpawnPoint[1]);
    if ID ~= 0 then
        local TypeName = Logic.GetEntityTypeName(Logic.GetEntityType(ID));
        if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
            return "Quest_Destroy_Leader";
        elseif TypeName:find("Bear") or TypeName:find("Lion") or TypeName:find("Tiger") or TypeName:find("Wolf") then
            return "Quest_DestroyEntities_Predators";
        elseif TypeName:find("Military") or TypeName:find("Cart") then
            return "Quest_DestroyEntities_Unit";
        end
    end
    return "Quest_DestroyEntities";
end

function b_Goal_DestroySpawnedEntities:GetCustomData(_Index)
    if _Index == 2 then
        return {"false", "true"};
    end
end

Core:RegisterBehavior(b_Goal_DestroySpawnedEntities);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss mindestens den angegebenen Ruf erreichen. Der Ruf muss
-- in Prozent angegeben werden (ohne %-Zeichen).
--
-- @param[type=number] _Reputation Benötigter Ruf
--
-- @within Goal
--
function Goal_CityReputation(...)
    return b_Goal_CityReputation:new(...);
end

b_Goal_CityReputation = {
    Name = "Goal_CityReputation",
    Description = {
        en = "Goal: Der Ruf der Stadt des Empfängers muss mindestens so hoch sein, wie angegeben.",
        de = "Ziel: The reputation of the quest receivers city must at least reach the desired hight.",
    },
    Parameter = {
        { ParameterType.Number, en = "City reputation", de = "Ruf der Stadt" },
    },
    Text = {
        de = "RUF DER STADT{cr}{cr}Hebe den Ruf der Stadt durch weise Herrschaft an!{cr}Benötigter Ruf: %d",
        en = "CITY REPUTATION{cr}{cr}Raise your reputation by fair rulership!{cr}Needed reputation: %d",
    }
}

function b_Goal_CityReputation:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_CityReputation:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Reputation = _Parameter * 1;
    end
end

function b_Goal_CityReputation:CustomFunction(_Quest)
    self:SetCaption(_Quest);
    local CityReputation = Logic.GetCityReputation(_Quest.ReceivingPlayer) * 100;
    if CityReputation >= self.Reputation then
        return true;
    end
end

function b_Goal_CityReputation:SetCaption(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local Text = string.format(API.Localize(self.Text), self.Reputation);
        Core:ChangeCustomQuestCaptionText(Text, _Quest);
    end
end

function b_Goal_CityReputation:Debug(_Quest)
    if type(self.Reputation) ~= "number" or self.Reputation < 0 or self.Reputation > 100 then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Reputation must be between 0 and 100!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_CityReputation);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss X% der Gesamtmenge einer Ware an einen anderen Spieler
-- liefern. Die tatsächlich zu versendende absulute Menge wird zum Start
-- des Quests bestimmt.
--
-- Für die Warenmenge dürfen nur ganze Zahlen zwischen 1 und 100 angegeben
-- werden. Aber sonst funktioniert das Behavior genauso wie Goal_Deliver.
--
-- Wenn die Gesamtmenge an Waren zum Startzeitpunkt des Quest zu gering ist,
-- werden fest vorgegebene Basiswerte zur Berechnung herangezogen:
-- <ul>
-- <li><u>Gold:</u>
-- Wenn weniger als 200 Gold vorhanden sind, dann muss der Prozentwert * 5
-- als absolute Menge versendet werden.
-- </li>
-- <li><u>Rohstoff:</u>
-- Wenn weniger als 18 Einheiten vorhanden sind, dann wird der Prozentwert
-- als absolute Menge verwendet.
-- </li>
-- <li><u>Güter:</u>
-- Wenn weniger als 9 Einheiten vorhanden sind, dann müssen X% von 18
-- versendet werden.
-- </li>
-- <li>Sonstige:</u>
-- analog zu Gütern
-- </li>
-- </ul>
--
-- @param _GoodType      Typ der Ware
-- @param _GoodAmount    Menge der Ware in Prozent
-- @param _OtherTarget   Anderes Ziel als Auftraggeber
-- @param _IgnoreCapture Wagen kann zurückerobert werden
--
-- @within Goal
--
function Goal_LevyTax(...)
    return b_Goal_LevyTax:new(...);
end

b_Goal_LevyTax = API.InstanceTable(b_Goal_Deliver);
b_Goal_LevyTax.Name = "Goal_LevyTax";
b_Goal_LevyTax.Description.en = "Goal: Deliver a relative amount of goods to the requesting player or another player";
b_Goal_LevyTax.Description.de = "Ziel: Liefere eine relative Menge an Waren zum Auftraggeber oder zu einem anderen Spieler.";

b_Goal_LevyTax.GetGoalTable = function(self, _Quest)
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName);
    return { Objective.Deliver, GoodType, math.floor(self.GoodAmount + 0.5), self.OverrideTarget, self.IgnoreCapture, {}, 0, 0, true};
end

Core:RegisterBehavior(b_Goal_LevyTax);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss eine Anzahl an Gegenständen finden, die bei den angegebenen
-- Positionen platziert werden.
--
-- @param _Positions Präfix aller durchnummerierten Enttities
-- @param _Distance  Aktivierungsdistanz (0 = Default = 300)    
--
-- @within Goal
--
function Goal_CollectValuables(...)
    return b_Goal_CollectValuables:new(...);
end

b_Goal_CollectValuables = {
    Name = "Goal_CollectValuables",
    Description = {
        en = "Goal: ",
        de = "Ziel: ",
    },
    Parameter = {
        { ParameterType.Default, en = "Search points",          de = "Suchpunkte" },
        { ParameterType.Custom,  en = "Shared model",           de = "Gemeinsames Modell" },
        { ParameterType.Number,  en = "Distance (0 = Default)", de = "Enternung (0 = Default)" },
    },

    Text = {
        {de = "%d/%d Gegenstände gefunden",
         en = "%d/%d Items gefunden",},
        {de = "GEGENSTÄNDE FINDEN {br}{br}Findet die verloren gegangenen Gegenstände.",
         en = "FIND VALUABLES {br}{br}Find the missing items.",},
    },

    Tools = {
        Models.Doodads_D_X_Sacks,
        Models.Tools_T_BowNet01,
        Models.Tools_T_Hammer02,
        Models.Tools_T_Cushion01,
        Models.Tools_T_Knife02,
        Models.Tools_T_Scythe01,
        Models.Tools_T_SiegeChest01,
    },

    Distance = 300,
    Finished = false,
    Positions = {},
    Marker = {},
}

function b_Goal_CollectValuables:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_CollectValuables:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SearchPositions = _Parameter;
    elseif (_Index == 1) then
        self.Model = _Parameter;
    elseif (_Index == 2) then
        if _Parameter == nil then
            _Parameter = self.Distance;
        end
        self.Distance = _Parameter * 1;
        if self.Distance == 0 then
            self.Distance = 300;
        end
    end
end

function b_Goal_CollectValuables:CustomFunction(_Quest)
    Core:ChangeCustomQuestCaptionText("{center}" ..API.Localize(self.Text[2]), _Quest);
    if not self.Finished then
        self:GetPositions(_Quest);
        self:CreateMarker(_Quest);
        self:CheckPositions(_Quest);
        if #self.Marker > 0 then
            return;
        end
        self.Finished = true;
    end
    return true;
end

function b_Goal_CollectValuables:GetPositions(_Quest)
    if #self.Positions == 0 then
        -- Position ist Table (script only feature)
        if type(self.SearchPositions) == "table" then
            self.Positions = self.SearchPositions;
        -- Suche alle Positionen mit dem Namen
        else
            local Index = 1;
            while (IsExisting(self.SearchPositions .. Index)) do
                table.insert(self.Positions, GetPosition(self.SearchPositions .. Index));
                Index = Index +1;
            end
        end
    end
end

function b_Goal_CollectValuables:CreateMarker(_Quest)
    if #self.Marker == 0 then
        for i= 1, #self.Positions, 1 do
            local ID = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, self.Positions[i].X, self.Positions[i].Y, 0, 0);
            if self.Model ~= nil and self.Model ~= "-" then
                Logic.SetModel(ID, Models[self.Model]);
            else
                Logic.SetModel(ID, self.Tools[math.random(1, #self.Tools)]);
            end
            Logic.SetVisible(ID, true);
            table.insert(self.Marker, ID);
        end
    end
end

function b_Goal_CollectValuables:CheckPositions(_Quest)
    local Heroes = {};
    Logic.GetKnights(_Quest.ReceivingPlayer, Heroes);
    for i= #self.Marker, 1, -1 do
        for j= 1, #Heroes, 1 do
            if IsNear(self.Marker[i], Heroes[j], self.Distance) then
                DestroyEntity(table.remove(self.Marker, i));
                local Max = #self.Positions;
                local Now = Max - #self.Marker;
                API.Note(string.format(API.Localize(self.Text[1]), Now, Max));
                break;
            end
        end
    end
end

function b_Goal_CollectValuables:Reset(_Quest)
    self:Interrupt(_Quest);
end

function b_Goal_CollectValuables:Interrupt(_Quest)
    self.Finished = false;
    self.Positions = {};
    for i= 1, #self.Marker, 1 do
        DestroyEntity(self.Marker[i]);
    end
    self.Marker = {};
end

function b_Goal_CollectValuables:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {};
        -- Erst mal alles entfernen...
        for k, v in pairs(Models) do
            if  not string.find(k, "Animals_")
            and not string.find(k, "MissionMap_")
            and not string.find(k, "R_Fish")
            and not string.find(k, "^[GEHUVXYZgt][ADSTfm]*")
            and not string.find(string.lower(k), "goods|tools_") then
                table.insert(Data, k);
            end
        end
        -- Models hinzufügen
        table.insert(Data, "Effects_Dust01");
        table.insert(Data, "Effects_E_DestructionSmoke");
        table.insert(Data, "Effects_E_DustLarge");
        table.insert(Data, "Effects_E_DustSmall");
        table.insert(Data, "Effects_E_Firebreath");
        table.insert(Data, "Effects_E_Fireworks01");
        table.insert(Data, "Effects_E_Flies01");
        table.insert(Data, "Effects_E_Grasshopper03");
        table.insert(Data, "Effects_E_HealingFX");
        table.insert(Data, "Effects_E_Knight_Chivalry_Aura");
        table.insert(Data, "Effects_E_Knight_Plunder_Aura");
        table.insert(Data, "Effects_E_Knight_Song_Aura");
        table.insert(Data, "Effects_E_Knight_Trader_Aura");
        table.insert(Data, "Effects_E_Knight_Wisdom_Aura");
        table.insert(Data, "Effects_E_KnightFight");
        table.insert(Data, "Effects_E_NA_BlowingSand01");
        table.insert(Data, "Effects_E_NE_BlowingSnow01");
        table.insert(Data, "Effects_E_Oillamp");
        table.insert(Data, "Effects_E_SickBuilding");
        table.insert(Data, "Effects_E_Splash");
        table.insert(Data, "Effects_E_Torch");
        table.insert(Data, "Effects_Fire01");
        table.insert(Data, "Effects_FX_Lantern");
        table.insert(Data, "Effects_FX_SmokeBIG");
        table.insert(Data, "Effects_XF_BuildingSmoke");
        table.insert(Data, "Effects_XF_BuildingSmokeLarge");
        table.insert(Data, "Effects_XF_BuildingSmokeMedium");
        table.insert(Data, "Effects_XF_HouseFire");
        table.insert(Data, "Effects_XF_HouseFireLo");
        table.insert(Data, "Effects_XF_HouseFireMedium");
        table.insert(Data, "Effects_XF_HouseFireSmall");
        if g_GameExtraNo > 0 then
            table.insert(Data, "Effects_E_KhanaTemple_Fire");
            table.insert(Data, "Effects_E_Knight_Saraya_Aura");
        end
        -- Sortieren
        table.sort(Data);
        -- "-" Option
        table.insert(Data, 1, "-");
        return Data;
    end
end

function b_Goal_CollectValuables:Debug(_Quest)
    return false;
end

Core:RegisterBehavior(b_Goal_CollectValuables);

-- -------------------------------------------------------------------------- --
-- Reprisals                                                                  --
-- -------------------------------------------------------------------------- --

---
-- Ändert die Position eines Siedlers oder eines Gebäudes.
--
-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert
-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein
-- als 50!
--
-- @param _ScriptName Skriptname des Entity
-- @param _Target     Skriptname des Ziels
-- @param _LookAt     Gegenüberstellen
-- @param _Distance   Relative Entfernung (nur mit _LookAt)
--
-- @within Reprisal
--
function Reprisal_SetPosition(...)
    return b_Reprisal_SetPosition:new(...);
end

b_Reprisal_SetPosition = {
    Name = "Reprisal_SetPosition",
    Description = {
        en = "Reprisal: Places an entity relative to the position of another. The entity can look the target.",
        de = "Vergeltung: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",             de = "Entity", },
        { ParameterType.ScriptName, en = "Target position", de = "Zielposition", },
        { ParameterType.Custom,     en = "Face to face",     de = "Ziel ansehen", },
        { ParameterType.Number,     en = "Distance",         de = "Zielentfernung", },
    },
}

function b_Reprisal_SetPosition:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_SetPosition:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.FaceToFace = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 3) then
        self.Distance = (_Parameter ~= nil and tonumber(_Parameter)) or 100;
    end
end

function b_Reprisal_SetPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x,y = Logic.GetBuildingApproachPosition(target);
    end
    local ori = Logic.GetEntityOrientation(target)+90;

    if self.FaceToFace then
        x = x + self.Distance * math.cos( math.rad(ori) );
        y = y + self.Distance * math.sin( math.rad(ori) );
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
        LookAt(self.Entity, self.Target);
    else
        if Logic.IsBuilding(target) == 1 then
            x,y = Logic.GetBuildingApproachPosition(target);
        end
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
    end
end

function b_Reprisal_SetPosition:GetCustomData(_Index)
    if _Index == 2 then
        return { "true", "false" }
    end
end

function b_Reprisal_SetPosition:Debug(_Quest)
    if self.FaceToFace then
        if tonumber(self.Distance) == nil or self.Distance < 50 then
            error(_Quest.Identifier.. ": " ..self.Name.. ": Distance is nil or to short!");
            return true;
        end
    end
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_SetPosition);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Eigentümer des Entity oder des Battalions.
--
-- @param _ScriptName Skriptname des Entity
-- @param _NewOwner   PlayerID des Eigentümers
--
-- @within Reprisal
--
function Reprisal_ChangePlayer(...)
    return b_Reprisal_ChangePlayer:new(...)
end

b_Reprisal_ChangePlayer = {
    Name = "Reprisal_ChangePlayer",
    Description = {
        en = "Reprisal: Changes the owner of the entity or a battalion.",
        de = "Vergeltung: Aendert den Besitzer einer Entity oder eines Battalions.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },
        { ParameterType.Custom,     en = "Player",     de = "Spieler", },
    },
}

function b_Reprisal_ChangePlayer:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_ChangePlayer:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Player = tostring(_Parameter);
    end
end

function b_Reprisal_ChangePlayer:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    if Logic.IsLeader(eID) == 1 then
        Logic.ChangeSettlerPlayerID(eID, self.Player);
    else
        Logic.ChangeEntityPlayerID(eID, self.Player);
    end
end

function b_Reprisal_ChangePlayer:GetCustomData(_Index)
    if _Index == 1 then
        return {"0", "1", "2", "3", "4", "5", "6", "7", "8"}
    end
end

function b_Reprisal_ChangePlayer:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_ChangePlayer);

-- -------------------------------------------------------------------------- --

---
-- Ändert die Sichtbarkeit eines Entity.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Visible    Sichtbarkeit an/aus
--
-- @within Reprisal
--
function Reprisal_SetVisible(...)
    return b_Reprisal_SetVisible:new(...)
end

b_Reprisal_SetVisible = {
    Name = "Reprisal_SetVisible",
    Description = {
        en = "Reprisal: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Strafe: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },
        { ParameterType.Custom,     en = "Visible",     de = "Sichtbar", },
    },
}

function b_Reprisal_SetVisible:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_SetVisible:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Visible = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reprisal_SetVisible:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end

    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);

    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                local soldiers = {Logic.GetSoldiersAttachedToLeader(spawned[i])};
                for j=2, #soldiers do
                    Logic.SetVisible(soldiers[j], self.Visible);
                end
            else
                Logic.SetVisible(spawned[i], self.Visible);
            end
        end
    else
        if Logic.IsLeader(eID) == 1 then
            local soldiers = {Logic.GetSoldiersAttachedToLeader(eID)};
            for j=2, #soldiers do
                Logic.SetVisible(soldiers[j], self.Visible);
            end
        else
            Logic.SetVisible(eID, self.Visible);
        end
    end
end

function b_Reprisal_SetVisible:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function b_Reprisal_SetVisible:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_SetVisible);

-- -------------------------------------------------------------------------- --

---
-- Macht das Entity verwundbar oder unverwundbar.
--
-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den
-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity 
-- angewendet, werden die gespawnten Entities genommen.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Vulnerable Verwundbarkeit an/aus
--
-- @within Reprisal
--
function Reprisal_SetVulnerability(...)
    return b_Reprisal_SetVulnerability:new(...);
end

b_Reprisal_SetVulnerability = {
    Name = "Reprisal_SetVulnerability",
    Description = {
        en = "Reprisal: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Vergeltung: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",              de = "Entity", },
        { ParameterType.Custom,     en = "Vulnerability",      de = "Verwundbar", },
    },
}

function b_Reprisal_SetVulnerability:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_SetVulnerability:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Vulnerability = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reprisal_SetVulnerability:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    local EntitiesToCheck = {eID};
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        EntitiesToCheck = {Logic.GetSpawnedEntities(eID)};
    end
    local MethodToUse = "MakeInvulnerable";
    if self.Vulnerability then
        MethodToUse = "MakeVulnerable";
    end
    for i= 1, #EntitiesToCheck, 1 do
        if Logic.IsLeader(EntitiesToCheck[i]) == 1 then
            local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntitiesToCheck[i])};
            for j=2, #Soldiers, 1 do
                _G[MethodToUse](Soldiers[j]);
            end
        end
        _G[MethodToUse](EntitiesToCheck[i]);
    end
end

function b_Reprisal_SetVulnerability:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function b_Reprisal_SetVulnerability:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_SetVulnerability);

-- -------------------------------------------------------------------------- --

---
-- Ändert das Model eines Entity.
--
-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können
-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.
-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Model      Neues Model
--
-- @within Reprisal
--
function Reprisal_SetModel(...)
    return b_Reprisal_SetModel:new(...);
end

b_Reprisal_SetModel = {
    Name = "Reprisal_SetModel",
    Description = {
        en = "Reprisal: Changes the model of the entity. Be careful, some models crash the game.",
        de = "Vergeltung: Aendert das Model einer Entity. Achtung: Einige Modelle fuehren zum Absturz.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },
        { ParameterType.Custom,     en = "Model",     de = "Model", },
    },
}

function b_Reprisal_SetModel:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_SetModel:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Model = _Parameter;
    end
end

function b_Reprisal_SetModel:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    Logic.SetModel(eID, Models[self.Model]);
end

-- Hinweis: Kann nicht durch Aufruf der Methode von b_Goal_CollectValuables
-- vereinfacht werden, weil man im Editor keine Methoden aufrufen kann!
function b_Reprisal_SetModel:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {};
        -- Erst mal alles entfernen...
        for k, v in pairs(Models) do
            if  not string.find(k, "Animals_")
            and not string.find(k, "MissionMap_")
            and not string.find(k, "R_Fish")
            and not string.find(k, "^[GEHUVXYZgt][ADSTfm]*")
            and not string.find(string.lower(k), "goods|tools_") then
                table.insert(Data, k);
            end
        end
        -- Models hinzufügen
        table.insert(Data, "Effects_Dust01");
        table.insert(Data, "Effects_E_DestructionSmoke");
        table.insert(Data, "Effects_E_DustLarge");
        table.insert(Data, "Effects_E_DustSmall");
        table.insert(Data, "Effects_E_Firebreath");
        table.insert(Data, "Effects_E_Fireworks01");
        table.insert(Data, "Effects_E_Flies01");
        table.insert(Data, "Effects_E_Grasshopper03");
        table.insert(Data, "Effects_E_HealingFX");
        table.insert(Data, "Effects_E_Knight_Chivalry_Aura");
        table.insert(Data, "Effects_E_Knight_Plunder_Aura");
        table.insert(Data, "Effects_E_Knight_Song_Aura");
        table.insert(Data, "Effects_E_Knight_Trader_Aura");
        table.insert(Data, "Effects_E_Knight_Wisdom_Aura");
        table.insert(Data, "Effects_E_KnightFight");
        table.insert(Data, "Effects_E_NA_BlowingSand01");
        table.insert(Data, "Effects_E_NE_BlowingSnow01");
        table.insert(Data, "Effects_E_Oillamp");
        table.insert(Data, "Effects_E_SickBuilding");
        table.insert(Data, "Effects_E_Splash");
        table.insert(Data, "Effects_E_Torch");
        table.insert(Data, "Effects_Fire01");
        table.insert(Data, "Effects_FX_Lantern");
        table.insert(Data, "Effects_FX_SmokeBIG");
        table.insert(Data, "Effects_XF_BuildingSmoke");
        table.insert(Data, "Effects_XF_BuildingSmokeLarge");
        table.insert(Data, "Effects_XF_BuildingSmokeMedium");
        table.insert(Data, "Effects_XF_HouseFire");
        table.insert(Data, "Effects_XF_HouseFireLo");
        table.insert(Data, "Effects_XF_HouseFireMedium");
        table.insert(Data, "Effects_XF_HouseFireSmall");
        if g_GameExtraNo > 0 then
            table.insert(Data, "Effects_E_KhanaTemple_Fire");
            table.insert(Data, "Effects_E_Knight_Saraya_Aura");
        end
        -- Sortieren
        table.sort(Data);
        return Data;
    end
end

function b_Reprisal_SetModel:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_SetModel);

-- -------------------------------------------------------------------------- --
-- Rewards                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Ändert die Position eines Siedlers oder eines Gebäudes.
--
-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert
-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein
-- als 50!
--
-- @param _ScriptName Skriptname des Entity
-- @param _Target     Skriptname des Ziels
-- @param _LookAt     Gegenüberstellen
-- @param _Distance   Relative Entfernung (nur mit _LookAt)
--
-- @within Reward
--
function Reward_SetPosition(...)
    return b_Reward_SetPosition:new(...);
end

b_Reward_SetPosition = API.InstanceTable(b_Reprisal_SetPosition);
b_Reward_SetPosition.Name = "Reward_SetPosition";
b_Reward_SetPosition.Description.en = "Reward: Places an entity relative to the position of another. The entity can look the target.";
b_Reward_SetPosition.Description.de = "Lohn: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.";
b_Reward_SetPosition.GetReprisalTable = nil;

b_Reward_SetPosition.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Core:RegisterBehavior(b_Reward_SetPosition);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Eigentümer des Entity oder des Battalions.
--
-- @param _ScriptName Skriptname des Entity
-- @param _NewOwner   PlayerID des Eigentümers
--
-- @within Reward
--
function Reward_ChangePlayer(...)
    return b_Reward_ChangePlayer:new(...);
end

b_Reward_ChangePlayer = API.InstanceTable(b_Reprisal_ChangePlayer);
b_Reward_ChangePlayer.Name = "Reward_ChangePlayer";
b_Reward_ChangePlayer.Description.en = "Reward: Changes the owner of the entity or a battalion.";
b_Reward_ChangePlayer.Description.de = "Lohn: Aendert den Besitzer einer Entity oder eines Battalions.";
b_Reward_ChangePlayer.GetReprisalTable = nil;

b_Reward_ChangePlayer.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Core:RegisterBehavior(b_Reward_ChangePlayer);

-- -------------------------------------------------------------------------- --

---
-- Bewegt einen Siedler relativ zu einem Zielpunkt.
--
-- Der Siedler wird sich zum Ziel ausrichten und in der angegeben Distanz
-- und dem angegebenen Winkel Position beziehen.
--
-- <p><b>Hinweis:</b> Funktioniert ähnlich wie MoveEntityToPositionToAnotherOne.
-- </p>
--
-- @param _ScriptName  Skriptname des Entity
-- @param _Destination Skriptname des Ziels
-- @param _Distance    Entfernung
-- @param _Angle       Winkel
--
-- @within Reward
--
function Reward_MoveToPosition(...)
    return b_Reward_MoveToPosition:new(...);
end

b_Reward_MoveToPosition = {
    Name = "Reward_MoveToPosition",
    Description = {
        en = "Reward: Moves an entity relative to another entity. If angle is zero the entities will be standing directly face to face.",
        de = "Lohn: Bewegt eine Entity relativ zur Position einer anderen. Wenn Winkel 0 ist, stehen sich die Entities direkt gegen�ber.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler", de = "Siedler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel" },
        { ParameterType.Number,     en = "Distance", de = "Entfernung" },
        { ParameterType.Number,     en = "Angle", de = "Winkel" },
    },
}

function b_Reward_MoveToPosition:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function b_Reward_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1;
    elseif (_Index == 3) then
        self.Angle = _Parameter * 1;
    end
end

function b_Reward_MoveToPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end
    self.Angle = self.Angle or 0;

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local orientation = Logic.GetEntityOrientation(target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x, y = Logic.GetBuildingApproachPosition(target);
        orientation = orientation -90;
    end
    x = x + self.Distance * math.cos( math.rad(orientation+self.Angle) );
    y = y + self.Distance * math.sin( math.rad(orientation+self.Angle) );
    Logic.MoveSettler(entity, x, y);
    StartSimpleJobEx( function(_entityID, _targetID)
        if Logic.IsEntityMoving(_entityID) == false then
            LookAt(_entityID, _targetID);
            return true;
        end
    end, entity, target);
end

function b_Reward_MoveToPosition:Debug(_Quest)
    if tonumber(self.Distance) == nil or self.Distance < 50 then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Distance is nil or to short!");
        return true;
    elseif not IsExisting(self.Entity) or not IsExisting(self.Target) then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_MoveToPosition);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler gewinnt das Spiel mit einem animierten Siegesfest.
--
-- Wenn nach dem Sieg weiter gespielt wird, wird das Fest gelöscht.
--
-- @within Reward
--
function Reward_VictoryWithParty()
    return b_Reward_VictoryWithParty:new();
end

b_Reward_VictoryWithParty = {
    Name = "Reward_VictoryWithParty",
    Description = {
        en = "Reward: The player wins the game with an animated festival on the market. Continue playing deleates the festival.",
        de = "Lohn: Der Spieler gewinnt das Spiel mit einer animierten Siegesfeier. Bei weiterspielen wird das Fest gelöscht.",
    },
    Parameter = {}
};

function b_Reward_VictoryWithParty:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end

function b_Reward_VictoryWithParty:AddParameter(_Index, _Parameter)
end

function b_Reward_VictoryWithParty:CustomFunction(_Quest)
    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);
    local pID = _Quest.ReceivingPlayer;

    local market = Logic.GetMarketplace(pID);
    if IsExisting(market) then
        local pos = GetPosition(market)
        Logic.CreateEffect(EGL_Effects.FXFireworks01,pos.X,pos.Y,0);
        Logic.CreateEffect(EGL_Effects.FXFireworks02,pos.X,pos.Y,0);
        
        local Generated = b_Reward_VictoryWithParty:GenerateParty(pID);
        QSB.VictoryWithPartyEntities[pID] = Generated;
        
        Logic.ExecuteInLuaLocalState([[
            if IsExisting(]]..market..[[) then
                CameraAnimation.AllowAbort = false
                CameraAnimation.QueueAnimation(CameraAnimation.SetCameraToEntity, ]]..market..[[)
                CameraAnimation.QueueAnimation(CameraAnimation.StartCameraRotation, 5)
                CameraAnimation.QueueAnimation(CameraAnimation.Stay ,9999)
            end

            GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty = GUI_Window.ContinuePlayingClicked
            GUI_Window.ContinuePlayingClicked = function()
                GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty()
                
                local PlayerID = GUI.GetPlayerID()
                GUI.SendScriptCommand("b_Reward_VictoryWithParty:ClearParty(" ..PlayerID.. ")")

                CameraAnimation.AllowAbort = true
                CameraAnimation.Abort()
            end
        ]]);
    end
end

function b_Reward_VictoryWithParty:ClearParty(_PlayerID)
    if QSB.VictoryWithPartyEntities[_PlayerID] then
        for k, v in pairs(QSB.VictoryWithPartyEntities[_PlayerID]) do
            DestroyEntity(v);
        end
        QSB.VictoryWithPartyEntities[_PlayerID] = nil;
    end
end

function b_Reward_VictoryWithParty:GenerateParty(_PlayerID)
    local GeneratedEntities = {};
    local Marketplace = Logic.GetMarketplace(_PlayerID);
    if Marketplace ~= nil and Marketplace ~= 0 then
        local MarketX, MarketY = Logic.GetEntityPosition(Marketplace);
        local ID = Logic.CreateEntity(Entities.D_X_Garland, MarketX, MarketY, 0, _PlayerID)
        table.insert(GeneratedEntities, ID);
        for j=1, 10 do
            for k=1,10 do
                local SettlersX = MarketX -700+ (j*150);
                local SettlersY = MarketY -700+ (k*150);
                
                local rand = Logic.GetRandom(100);
                
                if rand > 70 then
                    local SettlerType = API.GetRandomSettlerType();
                    local Orientation = Logic.GetRandom(360);
                    local WorkerID = Logic.CreateEntityOnUnblockedLand(SettlerType, SettlersX, SettlersY, Orientation, _PlayerID);
                    Logic.SetTaskList(WorkerID, TaskLists.TL_WORKER_FESTIVAL_APPLAUD_SPEECH);
                    table.insert(GeneratedEntities, WorkerID);
                end
            end
        end
    end
    return GeneratedEntities;
end

function b_Reward_VictoryWithParty:Debug(_Quest)
    return false;
end

Core:RegisterBehavior(b_Reward_VictoryWithParty);

-- -------------------------------------------------------------------------- --

---
-- Ändert die Sichtbarkeit eines Entity.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Visible    Sichtbarkeit an/aus
--
-- @within Reprisal
--
function Reward_SetVisible(...)
    return b_Reward_SetVisible:new(...)
end

b_Reward_SetVisible = API.InstanceTable(b_Reprisal_SetVisible);
b_Reward_SetVisible.Name = "Reward_SetVisible";
b_Reward_SetVisible.Description.en = "Reward: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.";
b_Reward_SetVisible.Description.de = "Lohn: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.";
b_Reward_SetVisible.GetReprisalTable = nil;

b_Reward_SetVisible.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

Core:RegisterBehavior(b_Reward_SetVisible);

-- -------------------------------------------------------------------------- --

---
-- Gibt oder entzieht einem KI-Spieler die Kontrolle über ein Entity.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Controlled Durch KI kontrollieren an/aus
--
-- @within Reward
--
function Reward_AI_SetEntityControlled(...)
    return b_Reward_AI_SetEntityControlled:new(...);
end

b_Reward_AI_SetEntityControlled = {
    Name = "Reward_AI_SetEntityControlled",
    Description = {
        en = "Reward: Bind or Unbind an entity or a battalion to/from an AI player. The AI player must be activated!",
        de = "Lohn: Die KI kontrolliert die Entity oder der KI die Kontrolle entziehen. Die KI muss aktiv sein!",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",               de = "Entity", },
        { ParameterType.Custom,     en = "AI control entity", de = "KI kontrolliert Entity", },
    },
}

function b_Reward_AI_SetEntityControlled:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } }
end

function b_Reward_AI_SetEntityControlled:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Hidden = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_AI_SetEntityControlled:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                AICore.HideEntityFromAI(pID, spawned[i], not self.Hidden);
            end
        end
    else
        AICore.HideEntityFromAI(pID, eID, not self.Hidden);
    end
end

function b_Reward_AI_SetEntityControlled:GetCustomData(_Index)
    if _Index == 1 then
        return { "false", "true" }
    end
end

function b_Reward_AI_SetEntityControlled:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_AI_SetEntityControlled);

-- -------------------------------------------------------------------------- --

---
-- Macht das Entity verwundbar oder unverwundbar.
--
-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den
-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity 
-- angewendet, werden die gespawnten Entities genommen.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Vulnerable Verwundbarkeit an/aus
--
-- @within Reward
--
function Reward_SetVulnerability(...)
    return b_Reward_SetVulnerability:new(...);
end

b_Reward_SetVulnerability = API.InstanceTable(b_Reprisal_SetVulnerability);
b_Reward_SetVulnerability.Name = "Reward_SetVulnerability";
b_Reward_SetVulnerability.Description.en = "Reward: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.";
b_Reward_SetVulnerability.Description.de = "Lohn: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen.";
b_Reward_SetVulnerability.GetReprisalTable = nil;

b_Reward_SetVulnerability.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

Core:RegisterBehavior(b_Reward_SetVulnerability);

-- -------------------------------------------------------------------------- --

---
-- Ändert das Model eines Entity.
--
-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können
-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.
-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Model      Neues Model
--
-- @within Reward
--
function Reward_SetModel(...)
    return b_Reward_SetModel:new(...);
end

b_Reward_SetModel = API.InstanceTable(b_Reprisal_SetModel);
b_Reward_SetModel.Name = "Reward_SetModel";
b_Reward_SetModel.Description.en = "Reward: Changes the model of the entity. Be careful, some models crash the game.";
b_Reward_SetModel.Description.de = "Lohn: Aendert das Model einer Entity. Achtung: Einige Modelle fuehren zum Absturz.";
b_Reward_SetModel.GetReprisalTable = nil;

b_Reward_SetModel.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

Core:RegisterBehavior(b_Reward_SetModel);

-- -------------------------------------------------------------------------- --

---
-- Füllt die Munition in der Kriegsmaschine vollständig auf.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Reward
--
function Reward_RefillAmmunition(...)
    return b_Reward_RefillAmmunition:new(...);
end

b_Reward_RefillAmmunition = {
    Name = "Reward_RefillAmmunition",
    Description = {
        en = "Reward: Refills completely the ammunition of the entity.",
        de = "Lohn: Fuellt die Munition der Entity vollständig auf.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Reward_RefillAmmunition:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function b_Reward_RefillAmmunition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    end
end

function b_Reward_RefillAmmunition:CustomFunction()
    local EntityID = GetID(self.Scriptname);
    if not IsExisting(EntityID) then
        return;
    end

    local Ammunition = Logic.GetAmmunitionAmount(EntityID);
    while (Ammunition < 10)
    do
        Logic.RefillAmmunitions(EntityID);
        Ammunition = Logic.GetAmmunitionAmount(EntityID);
    end
end

function b_Reward_RefillAmmunition:Debug(_Quest)
    if not IsExisting(self.Scriptname) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": '"..self.Scriptname.."' is destroyed!");
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_RefillAmmunition)

-- -------------------------------------------------------------------------- --
-- Trigger                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald mindestens X von Y Quests fehlgeschlagen sind.
--
-- @param _MinAmount Mindestens zu verlieren (max. 5)
-- @param _QuestAmount Anzahl geprüfter Quests (max. 5 und >= _MinAmount)
-- @param _Quest1      Name des 1. Quest
-- @param _Quest2      Name des 2. Quest
-- @param _Quest3      Name des 3. Quest
-- @param _Quest4      Name des 4. Quest
-- @param _Quest5      Name des 5. Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastXOfYQuestsFailed(...)
    return b_Trigger_OnAtLeastXOfYQuestsFailed:new(...);
end

b_Trigger_OnAtLeastXOfYQuestsFailed = {
    Name = "Trigger_OnAtLeastXOfYQuestsFailed",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Ausloeser: wenn X von Y angegebener Quests fehlgeschlagen sind.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl" },
        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5" },
    },
}

function b_Trigger_OnAtLeastXOfYQuestsFailed:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnAtLeastXOfYQuestsFailed:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function b_Trigger_OnAtLeastXOfYQuestsFailed:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
		local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
			if (Quests[QuestID].Result == QuestResult.Failure) then
				least = least + 1
				if least >= self.LeastAmount then
					return true
				end
			end
        end
    end
    return false
end

function b_Trigger_OnAtLeastXOfYQuestsFailed:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount <= 0 or leastAmount >5 then
        error(_Quest.Identifier .. ":" .. self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount <= 0 or questAmount > 5 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount > questAmount then
        error(_Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            error(_Quest.Identifier.. ": " ..self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function b_Trigger_OnAtLeastXOfYQuestsFailed:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

Core:RegisterBehavior(b_Trigger_OnAtLeastXOfYQuestsFailed)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald die Munition in der Kriegsmaschine erschöpft ist.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Trigger
--
function Trigger_AmmunitionDepleted(...)
    return b_Trigger_AmmunitionDepleted:new(...);
end

b_Trigger_AmmunitionDepleted = {
    Name = "Trigger_AmmunitionDepleted",
    Description = {
        en = "Trigger: if the ammunition of the entity is depleted.",
        de = "Ausloeser: wenn die Munition der Entity aufgebraucht ist.",
    },
    Parameter = {
        { ParameterType.Scriptname, en = "Script name", de = "Skriptname" },
    },
}

function b_Trigger_AmmunitionDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_AmmunitionDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    end
end

function b_Trigger_AmmunitionDepleted:CustomFunction()
    if not IsExisting(self.Scriptname) then
        return false;
    end

    local EntityID = GetID(self.Scriptname);
    if Logic.GetAmmunitionAmount(EntityID) > 0 then
        return false;
    end

    return true;
end

function b_Trigger_AmmunitionDepleted:Debug(_Quest)
    if not IsExisting(self.Scriptname) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": '"..self.Scriptname.."' is destroyed!");
        return true
    end
    return false
end

Core:RegisterBehavior(b_Trigger_AmmunitionDepleted)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn exakt einer von beiden Quests erfolgreich ist.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnExactOneQuestIsWon(...)
    return b_Trigger_OnExactOneQuestIsWon:new(...);
end

b_Trigger_OnExactOneQuestIsWon = {
    Name = "Trigger_OnExactOneQuestIsWon",
    Description = {
        en = "Trigger: if one of two given quests has been finished successfully, but NOT both.",
        de = "Ausloeser: wenn eine von zwei angegebenen Quests (aber NICHT beide) erfolgreich abgeschlossen wurde.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },
    },
}

function b_Trigger_OnExactOneQuestIsWon:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_OnExactOneQuestIsWon:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function b_Trigger_OnExactOneQuestIsWon:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function b_Trigger_OnExactOneQuestIsWon:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnExactOneQuestIsWon);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn exakt einer von beiden Quests fehlgeschlagen ist.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnExactOneQuestIsLost(...)
    return b_Trigger_OnExactOneQuestIsLost:new(...);
end

b_Trigger_OnExactOneQuestIsLost = {
    Name = "Trigger_OnExactOneQuestIsLost",
    Description = {
        en = "Trigger: If one of two given quests has been lost, but NOT both.",
        de = "Ausloeser: Wenn einer von zwei angegebenen Quests (aber NICHT beide) fehlschlägt.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },
    },
}

function b_Trigger_OnExactOneQuestIsLost:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_OnExactOneQuestIsLost:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function b_Trigger_OnExactOneQuestIsLost:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function b_Trigger_OnExactOneQuestIsLost:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnExactOneQuestIsLost);

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleSymfoniaBehaviors = {
    Global = {},
    Local = {}
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Global:Install()
    Core:StackFunction("QuestTemplate.Trigger", self.OnQuestTriggered);

    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    -- Theif observation
    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    GameCallback_OnThiefDeliverEarnings_Orig_QSB_SymfoniaBehaviors = GameCallback_OnThiefDeliverEarnings;
    GameCallback_OnThiefDeliverEarnings = function(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount)
        GameCallback_OnThiefDeliverEarnings_Orig_QSB_SymfoniaBehaviors(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount);

        for i=1, Quests[0] do
            if Quests[i] and Quests[i].State == QuestState.Active then
                for j=1, Quests[i].Objectives[0] do
                    if Quests[i].Objectives[j].Type == Objective.Custom2 then
                        if Quests[i].Objectives[j].Data[1].Name == "Goal_StealBuilding" then
                            local found;
                            for k=1, #Quests[i].Objectives[j].Data[1].RobberList do
                                local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];
                                if stohlen[1] == GetID(Quests[i].Objectives[j].Data[1].Building) and stohlen[2] == _ThiefID then
                                    found = true;
                                    break;
                                end
                            end
                            if found then
                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;
                            end

                        elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealGold" then
                            local CurrentObjective = Quests[i].Objectives[j].Data[1];
                            local TargetPlayerID = Logic.EntityGetPlayer(_BuildingID);

                            if CurrentObjective.Target ~= -1 and CurrentObjective.Target ~= TargetPlayerID then
                                return;
                            end
                            Quests[i].Objectives[j].Data[1].StohlenGold = Quests[i].Objectives[j].Data[1].StohlenGold + _GoodAmount;
                            if CurrentObjective.Printout then
                                local msg  = {de = "Talern gestohlen",en = "gold stolen",};
                                local curr = CurrentObjective.StohlenGold;
                                local need = CurrentObjective.Amount;
                                API.Note(string.format("%d/%d %s", curr, need, API.Localize(msg)));
                            end
                        end
                    end
                end
            end
        end
    end

    GameCallback_OnThiefStealBuilding_Orig_QSB_SymfoniaBehaviors = GameCallback_OnThiefStealBuilding;
    GameCallback_OnThiefStealBuilding = function(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID)
        GameCallback_OnThiefStealBuilding_Orig_QSB_SymfoniaBehaviors(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);

        for i=1, Quests[0] do
            if Quests[i] and Quests[i].State == QuestState.Active then
                for j=1, Quests[i].Objectives[0] do
                    if Quests[i].Objectives[j].Type == Objective.Custom2 then
                        if Quests[i].Objectives[j].Data[1].Name == "Goal_SpyBuilding" then
                            if  GetID(Quests[i].Objectives[j].Data[1].Building) == _BuildingID and Quests[i].ReceivingPlayer == _ThiefPlayerID then
                                Quests[i].Objectives[j].Data[1].Infiltrated = true;
                                if Quests[i].Objectives[j].Data[1].Delete then
                                    DestroyEntity(_ThiefID);
                                end
                            end

                        elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealBuilding" then
                            local found;
                            local isCathedral = Logic.IsEntityInCategory(_BuildingID, EntityCategories.Cathedrals) == 1;
                            local isWarehouse = Logic.GetEntityType(_BuildingID) == Entities.B_StoreHouse;
                            if isWarehouse or isCathedral then
                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;
                            else
                                for k=1, #Quests[i].Objectives[j].Data[1].RobberList do
                                    local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];
                                    if stohlen[1] == _BuildingID and stohlen[2] == _ThiefID then
                                        found = true;
                                        break;
                                    end
                                end
                            end
                            if not found then
                                table.insert(Quests[i].Objectives[j].Data[1].RobberList, {_BuildingID, _ThiefID});
                            end
                        end
                    end
                end
            end
        end
    end

    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    -- Objectives
    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    QuestTemplate.IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        if objective.Completed ~= nil then
            if objective.Data[1] == 3 then
                objective.Data[5] = nil;
            end
            return objective.Completed;
        end

        if objectiveType == Objective.DestroyEntities then
            if objective.Data[1] == 3 then
                objective.Completed = BundleSymfoniaBehaviors.Global:AreQuestEntitiesDestroyed(self, objective);
            else
                return self:IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors(objective);
            end
        else
            return self:IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors(objective);
        end
    end
end

---
-- Gibt eine Liste von ohne Absturz nutzbaren statischen Modellen zurück.
-- @return[type=table] Liste der Modelle
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Global:GetPossibleModels()
    local Data = {};
    -- Erst mal alles entfernen...
    for k, v in pairs(Models) do
        if  not string.find(k, "Animals_")
        and not string.find(k, "MissionMap_")
        and not string.find(k, "R_Fish")
        and not string.find(k, "^[GEHUVXYZgt][ADSTfm]*")
        and not string.find(string.lower(k), "goods|tools_") then
            table.insert(Data, k);
        end
    end
    -- Models hinzufügen
    table.insert(Data, "Effects_Dust01");
    table.insert(Data, "Effects_E_DestructionSmoke");
    table.insert(Data, "Effects_E_DustLarge");
    table.insert(Data, "Effects_E_DustSmall");
    table.insert(Data, "Effects_E_Firebreath");
    table.insert(Data, "Effects_E_Fireworks01");
    table.insert(Data, "Effects_E_Flies01");
    table.insert(Data, "Effects_E_Grasshopper03");
    table.insert(Data, "Effects_E_HealingFX");
    table.insert(Data, "Effects_E_Knight_Chivalry_Aura");
    table.insert(Data, "Effects_E_Knight_Plunder_Aura");
    table.insert(Data, "Effects_E_Knight_Song_Aura");
    table.insert(Data, "Effects_E_Knight_Trader_Aura");
    table.insert(Data, "Effects_E_Knight_Wisdom_Aura");
    table.insert(Data, "Effects_E_KnightFight");
    table.insert(Data, "Effects_E_NA_BlowingSand01");
    table.insert(Data, "Effects_E_NE_BlowingSnow01");
    table.insert(Data, "Effects_E_Oillamp");
    table.insert(Data, "Effects_E_SickBuilding");
    table.insert(Data, "Effects_E_Splash");
    table.insert(Data, "Effects_E_Torch");
    table.insert(Data, "Effects_Fire01");
    table.insert(Data, "Effects_FX_Lantern");
    table.insert(Data, "Effects_FX_SmokeBIG");
    table.insert(Data, "Effects_XF_BuildingSmoke");
    table.insert(Data, "Effects_XF_BuildingSmokeLarge");
    table.insert(Data, "Effects_XF_BuildingSmokeMedium");
    table.insert(Data, "Effects_XF_HouseFire");
    table.insert(Data, "Effects_XF_HouseFireLo");
    table.insert(Data, "Effects_XF_HouseFireMedium");
    table.insert(Data, "Effects_XF_HouseFireSmall");
    if g_GameExtraNo > 0 then
        table.insert(Data, "Effects_E_KhanaTemple_Fire");
        table.insert(Data, "Effects_E_Knight_Saraya_Aura");
    end
    -- Sortieren
    table.sort(Data);
    return Data;
end

---
-- Prüft, ob alle gespawnten Entities zerstört wurden.
-- @param[type=table] _Quest     Quest Data
-- @param[type=table] _Objective Behavior Data
-- @return[type=boolean] Resultat des Behavior
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Global:AreQuestEntitiesDestroyed(_Quest, _Objective)
    if _Objective.Data[1] == 3 then
        local AllSpawnedEntities = {};
        for i=1, _Objective.Data[2][0], 1 do
            local ID = GetID(_Objective.Data[2][i]);
            AllSpawnedEntities = Array_Append(AllSpawnedEntities, {Logic.GetSpawnedEntities(ID)});
        end
        if #AllSpawnedEntities == 0 then
            return true;
        end
    end
end

---
-- Überschreibt die :Trigger() Methode der Quests.
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Global.OnQuestTriggered(self)
    for b= 1, #self.Objectives, 1 do
        if self.Objectives[b] then
            -- Spezielles Objective.DestroyEntities für Raubtiere
            if self.Objectives[b].Type == Objective.DestroyEntities and self.Objectives[b].Data[1] == 3 then
                if self.Objectives[b].Data[5] ~= true then
                    local SpawnPoints = self.Objectives[b].Data[2][0];
                    local SpawnAmount = self.Objectives[b].Data[3];
                    -- Vorhandene Entities löschen
                    for i=1, SpawnPoints, 1 do
                        local ID = GetID(self.Objectives[b].Data[2][i]);
                        local SpawnedEntities = {Logic.GetSpawnedEntities(ID)};
                        for j= 1, #SpawnedEntities, 1 do
                            DestroyEntity(SpawnedEntities[j]);
                        end
                    end
                    -- Entities neu spawnen und möglichst gerecht über alle
                    -- Spawnpoints verteilen
                    while (SpawnAmount > 0) do
                        for i=1, SpawnPoints, 1 do
                            if SpawnAmount < 1 then
                                break;
                            end
                            local ID = GetID(self.Objectives[b].Data[2][i]);
                            Logic.RespawnResourceEntity_Spawn(ID);
                            SpawnAmount = SpawnAmount -1;
                        end
                    end
                    -- Icon setzen
                    local CategoryDefinigEntity = Logic.GetSpawnedEntities(self.Objectives[b].Data[2][1]);
                    if not self.Objectives[b].Data[6] then
                        self.Objectives[b].Data[6] = {7, 12};
                        if Logic.IsEntityInCategory(CategoryDefinigEntity, EntityCategories.AttackableAnimal) == 1 then
                            self.Objectives[b].Data[6] = {13, 8};
                        end
                    end
                    self.Objectives[b].Data[5] = true;
                end
            
            -- Spezielles Objective.Deliver für errechnete Liefermengen
            -- Ermittelt die zu liefernde Menge prozentual zur aktuellen Menge
            -- einer Ware. Ist die vorhandene Menge zu gering, wird eine
            -- Standardmenge verlangt.
            elseif self.Objectives[b].Type == Objective.Deliver and self.Objectives[b].Data[8] == true then
                local Data = self.Objectives[b].Data;
                -- Sicherstellen, dass es niemals ungültige Werte gibt.
                self.Objectives[b].Data[2] = (Data[2] > 100 and 100) or Data[2];
                self.Objectives[b].Data[2] = (Data[2] < 1 and 1) or Data[2];
                -- Einmalig zum Start die absolut geforderte Menge ermitteln.
                if Data[9] == nil then
                    -- Sicherheitskopie des ursprünglichen Wertes anlegen
                    if self.Objectives[b].Data[9] == nil then
                        self.Objectives[b].Data[9] = self.Objectives[b].Data[2];
                    end
                    -- Werte bestimmen
                    local IsResource = Logic.GetGoodCategoryForGoodType(Data[1]) == GoodCategories.GC_Resource;
                    local IsGold = Data[1] == Goods.G_Gold;
                    local TotalAmount = GetPlayerGoodsInSettlement(Data[1], self.ReceivingPlayer, false);
                    -- Burglager einbeziehen
                    if AddOnCastleStore then
                        TotalAmount = TotalAmount + API.CastleStoreGetGoodAmount(self.ReceivingPlayer, Data[1])
                    end
                    TotalAmount = TotalAmount + math.ceil(TotalAmount * 0.2);
                    -- Defaults, wenn zu wenig
                    if IsGold and TotalAmount < 250 + Data[9] then
                        TotalAmount = 250 + Data[9];
                    elseif IsResource and TotalAmount < 36 then
                        TotalAmount = 36 + math.floor(Data[9]/3);
                    elseif not IsGold and not IsResource and TotalAmount < 18 then
                        TotalAmount = 18 + math.floor(Data[9]/6);
                    end
                    -- Menge bestimmen
                    local Amount = math.ceil((TotalAmount / 100) * Data[9]);
                    self.Objectives[b].Data[2] = Amount;
                end
            end
        end
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Local:Install()
    Core:StackFunction("GUI_Interaction.GetEntitiesOrTerritoryListForQuest", self.GetEntitiesOrTerritoryList);
    Core:StackFunction("GUI_Interaction.SaveQuestEntityTypes", self.SaveQuestEntityTypes);
    Core:StackFunction("GUI_Interaction.DisplayQuestObjective", self.DisplayQuestObjective);
end

---
-- Erweitert die Funktion, welche das Auftragsziel darstellt.
-- 
-- Das richtige Icon für Spawned Entities wird angezeigt.
--
-- Das neue Ziel "LevyTax" wird wie "Deliver" angezeigt.
--
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Local.DisplayQuestObjective(_QuestIndex, _MessageKey)
    local QuestIndexTemp = tonumber(_QuestIndex);
    if QuestIndexTemp then
        _QuestIndex = QuestIndexTemp;
    end
    local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
    local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
    
    -- 
    if QuestType == Objective.DestroyEntities and Quest.Objectives[1].Data[1] == 3 then
        local QuestObjectiveContainer = QuestObjectivesPath .. "/GroupEntityType";
        local QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestDestroy");
        local EntitiesList = GUI_Interaction.GetEntitiesOrTerritoryListForQuest( Quest, QuestType );
        local EntitiesAmount = #EntitiesList;
        if not Quest.Objectives[1].Data[5] and #EntitiesList == 0 then
            EntitiesAmount = #Quest.Objectives[1].Data[2][0] * Quest.Objectives[1].Data[3];
        end

        XGUIEng.ShowWidget(QuestObjectiveContainer .. "/AdditionalCaption", 0);
        XGUIEng.ShowWidget(QuestObjectiveContainer .. "/AdditionalCondition", 0);
        SetIcon(QuestObjectiveContainer .. "/Icon", Quest.Objectives[1].Data[6]);
        XGUIEng.SetText(QuestObjectiveContainer .. "/Number", "{center}" .. EntitiesAmount);

        XGUIEng.SetText(QuestObjectiveContainer .. "/Caption", "{center}" .. QuestTypeCaption);
        XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
        GUI_Interaction.SetQuestTypeIcon(QuestObjectiveContainer .. "/QuestTypeIcon", _QuestIndex);
        if Quest.State == QuestState.Over then
            if Quest.Result == QuestResult.Success then
                XGUIEng.ShowWidget(QuestObjectivesPath .. "/QuestOverSuccess", 1);
            elseif Quest.Result == QuestResult.Failure then
                XGUIEng.ShowWidget(QuestObjectivesPath .. "/QuestOverFailure", 1);
            end
        end
        return true;
    end

    --end if dummy quest
    if QuestObjectiveContainer == nil then
        return
    end
end

---
-- Erweitert die Funktion zur Ermittlung der Sprungziele für die Lupe.
-- Alle gespawnten Entities werden durch die Lupe angezeigt.
-- @param[type=table]  _Quest     Quest Table
-- @param[type=number] _QuestType Typ des Quest
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Local.GetEntitiesOrTerritoryList(_Quest, _QuestType)
    local IsEntity = true;
    local EntityOrTerritoryList = {};
    if _QuestType == Objective.DestroyEntities then
        if _Quest.Objectives[1].Data and _Quest.Objectives[1].Data[1] == 3 then
            for i=1, _Quest.Objectives[1].Data[2][0], 1 do
                local ID = GetID(_Quest.Objectives[1].Data[2][i]);
                EntityOrTerritoryList = Array_Append(EntityOrTerritoryList, {Logic.GetSpawnedEntities(ID)});
            end
            return EntityOrTerritoryList, IsEntity;
        end
    end
end

---
-- Erweitert die Funktion zur Speicherung der Quest Entities. Es wird der
-- neue Typ 3 für Objective.DestroyEntities implementiert.
-- @param[type=number] _QuestIndex Index des Quest
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Local.SaveQuestEntityTypes(_QuestIndex)
    if g_Interaction.SavedQuestEntityTypes[_QuestIndex] ~= nil then
        return;
    end
    local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
    local EntitiesList;
    if QuestType ~= Objective.DestroyEntities or Quest.Objectives[1].Data[1] ~= 3 then
        return;
    end
    EntitiesList = GUI_Interaction.GetEntitiesOrTerritoryListForQuest(Quest, QuestType);
    EntitiesList[0] = #EntitiesList;
    if EntitiesList ~= nil then
        g_Interaction.SavedQuestEntityTypes[_QuestIndex] = {};
        for i = 1, EntitiesList[0], 1 do
            if Logic.IsEntityAlive(EntitiesList[i]) then
                local EntityType = Logic.GetEntityType(GetEntityId(EntitiesList[i]));
                table.insert(g_Interaction.SavedQuestEntityTypes[_QuestIndex], i, EntityType);
            end
        end
        return true;
    end
end

Core:RegisterBundle("BundleSymfoniaBehaviors");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleTerrainAndWater                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle beinhaltet Funktionen zur Veränderung der Höhe von Land und
-- von Wasser.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleTerrainAndWater = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Ändert die Bodentextur innerhalb des Quadrates. Offset bestimmt die
-- Abstände der Eckpunkte zum Zentralpunkt.
--
-- <b>Hinweis:</b> Für weitere Informationen zu Terraintexturen siehe
-- https://siedelwood-neu.de/23879-2/
--
-- <b>Alias:</b> TerrainTypeSquare
--
-- @param              _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number] _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number] _TerrainType Textur ID
-- @within Anwenderfunktionen
--
-- @usage
-- API.ChangeTerrainTypeInSquare("area", 500, 48)
--
function API.ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType)
    if GUI then
        return;
    end
    if not IsExisting(_Center) then
        log("API.ChangeTerrainTypeInSquare: Central point does not exist!", LEVEL_ERROR);
        return;
    end
    if _Offset < 100 then
        log("API.ChangeTerrainTypeInSquare: Check your offset! It seems to small!", LEVEL_WARNING);
    end
    return BundleTerrainAndWater.Global:ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType);
end
TerrainTypeSquare = API.ChangeTerrainTypeInSquare;

---
-- Ändert die Wasserhöhe in einem Quadrat. Offset bestimmt die Abstände
-- der Eckpunkte zum Zentrum.
--
-- Wird die relative Höhe verwendet, wird die Wasserhöhe nicht absolut
-- gesetzt sondern von der aktuellen Wasserhöhe ausgegangen.
--
-- <p><b>Alias:</b> WaterHeightSquare</p>
--
-- @param               _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number]  _Height Neue Höhe
-- @param[type=boolean] _Relative Relative Höhe benutzen
-- @within Anwenderfunktionen
--
-- @usage
-- API.ChangeWaterHeightInSquare("area", 500, 5555, true);
--
function API.ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative)
    if GUI then
        return;
    end
    if not IsExisting(_Center) then
        log("API.ChangeWaterHeightInSquare: Central point does not exist!", LEVEL_ERROR);
        return;
    end
    if _Offset < 100 then
        log("API.ChangeWaterHeightInSquare: Check your offset! It seems to small!", LEVEL_WARNING);
    end
    return BundleTerrainAndWater.Global:ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative);
end
WaterHeightSquare = API.ChangeWaterHeightInSquare;

---
-- Ändert die Landhöhe in einem Quadrat. Offset bestimmt die Abstände
-- der Eckpunkte zum Zentralpunkt.
--
-- Wird die relative Höhe verwendet, wird die Landhöhe nicht absolut
-- gesetzt sondern von der aktuellen Landhöhe ausgegangen. Das Land muss nicht
-- eben sein. Auf diese Weise können Strukturen unverändert angehoben werden.
--
-- <p><b>Alias:</b> TerrainHeightSquare</p>
--
-- @param               _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number]  _Height Neue Höhe
-- @param[type=boolean] _Relative Relative Höhe benutzen
-- @within Anwenderfunktionen
--
-- @usage
-- API.ChangeTerrainHeightInSquare("area", 500, 5555, true);
--
function API.ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative)
    if GUI then
        return;
    end
    if not IsExisting(_Center) then
        log("API.ChangeTerrainHeightInSquare: Central point does not exist!", LEVEL_ERROR);
        return;
    end
    if _Offset < 100 then
        log("API.ChangeTerrainHeightInSquare: Check your offset! It seems to small!", LEVEL_WARNING);
    end
    return BundleTerrainAndWater.Global:ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative);
end
TerrainHeightSquare = API.ChangeTerrainHeightInSquare;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleTerrainAndWater = {
    Global = {
        Data = {}
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleTerrainAndWater.Global:Install()
end 

-- -------------------------------------------------------------------------- --

---
-- Ändert die Bodentextur innerhalb des Quadrates. Offset bestimmt die
-- Abstände der Eckpunkte zum Zentralpunkt.
-- @param              _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number] _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number] _TerrainType Textur ID
-- @within Internal
-- @local
--
function BundleTerrainAndWater.Global:ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType)
    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);
    if Xmin == -1 or Xmin == -2 then
        return Xmin;
    end
    if type(_TerrainType) == "number" then
        for x10 = Xmin, Xmax do
            for y10 = Ymin, Ymax do
                Logic.SetTerrainNodeType( x10, y10, _TerrainType );
            end
        end
    end
    Logic.UpdateBlocking( Xmin, Ymin, Xmax, Ymax);
end

---
-- Ändert die Wasserhöhe in einem Quadrat. Offset bestimmt die Abstände
-- der Eckpunkte zum Zentralpunkt.
-- @param               _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number]  _Height Neue Höhe
-- @param[type=boolean] _Relative Relative Höhe benutzen
-- @within Internal
-- @local
--
function BundleTerrainAndWater.Global:ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative)
    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);
    if Xmin == -1 or Xmin == -2 then
        return Xmin;
    end
    if not _Relative then
        if _Height < 0 then
            return -3;
        end
        Logic.WaterSetAbsoluteHeight(Xmin, Ymin, Xmax, Ymax, _Height);
    else
        if z+_Height < 0 then
            return -3;
        end
        Logic.WaterSetAbsoluteHeight(Xmin, Ymin, Xmax, Ymax, z+_Height);
    end
    Logic.UpdateBlocking(Xmin, Ymin, Xmax, Ymax);
    return 0;
end

---
-- Ändert die Landhöhe in einem Quadrat. Offset bestimmt die Abstände
-- der Eckpunkte zum Zentralpunkt.
-- @param               _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number]  _Height Neue Höhe
-- @param[type=boolean] _Relative Relative Höhe benutzen
-- @within Internal
-- @local
--
function BundleTerrainAndWater.Global:ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative)
    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);
    if Xmin == -1 or Xmin == -2 then
        return Xmin;
    end
    local Height;
    if not _Relative then
        if _Height < 0 then
            return -3;
        end
        Height = _Height;
    else
        if z+_Height < 0 then
            return -3;
        end
        Height = z+_Height;
    end

    for x10 = Xmin, Xmax do
        for y10 = Ymin, Ymax do
            Logic.SetTerrainNodeHeight(x10, y10, Height);
        end
    end
    Logic.UpdateBlocking(Xmin, Ymin, Xmax, Ymax);
    return 0;
end

---
-- Gibt ein Quadrat für Land- und Wassermanipulation zurück.
--
-- Wird verwendet von: WaterHeight, TerrainHeight, TerrainType
--
-- @param              _Center Zentralpunkt des Quadrat (Skriptname oder ID)
-- @param[type=number] _Offset Abstand der Ecken zum Zentrum
-- @return[type=number] X-Koordinate von Punkt 1
-- @return[type=number] Y-Koordinate von Punkt 1
-- @return[type=number] X-Koordinate von Punkt 2
-- @return[type=number] Y-Koordinate von Punkt 2
-- @return[type=number] Bodenhöhe
-- @within Internal
-- @local
--
function BundleTerrainAndWater.Global:GetSquareForWaterAndTerrain(_Center, _Offset)
    local Type = type(_Center);
    if (Type ~= "string" and Type ~= "number") or not IsExisting(_Center) then
        return -1;
    end
    local Xmin, Ymin, Xmax, Ymax;
    local eID = GetID(_Center);
    local x,y,z = Logic.EntityGetPos(eID);
    Xmin = math.floor((x - _Offset)/100);
    Ymin = math.floor((y - _Offset)/100);
    Xmax = math.floor((x + _Offset)/100);
    Ymax = math.floor((y + _Offset)/100);
    if IsValidPosition({X= Xmin, Y= Ymin}) == false or IsValidPosition({X= Xmax, Y= Ymax}) == false then
        return -2;
    end
    return Xmin, Ymin, Xmax, Ymax, z;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleTerrainAndWater");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleTimeLine                                               # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle ermöglicht es Aktionen in einer zeitlichen Abfolge zu
-- gliedern.
--
-- Die Bezeichnung "Time Line" (Zeitstrahl) wird z.B. in der Filmindustrie
-- verwendet und beschreibt einen Ablauf von aufeinander folgenden Ereignissen.
-- Diese Ereignisse sind zeitlich gegliedert.
--
-- Du kannst mit der Implementation eines solchen Zeitstrahls Lua-Funktionen
-- im Abstand einer oder mehrerer Sekunden ausführen lassen. Ein solcher
-- Zeitstrahl verfügt über eine ID, mit der er angesprochen werden kann. So
-- kann er abgebrochen, pausiert, fortgesetzt und neu gestartet werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleTimeLine = {};

API = API or {};
QSB = QSB or {};

QSB.TimeLine = {
    Data = {
        TimeLineUniqueJobID = 1,
        TimeLineJobs = {},
    }
};

-- -------------------------------------------------------------------------- --
-- User Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Startet einen Zeitstrahl. Ein Zeitstrahl hat Stationen,
-- an denen eine Aktion ausgeführt wird. Jede Station muss mindestens eine
-- Sekunde nach der vorherigen liegen.
--
-- Jede Aktion eines Zeitstrahls erhält die Table des aktuellen Ereignisses
-- als Argument. So können Parameter an die Funktion übergeben werden.
--
-- <p><b>Alias:</b> QSB.TimeLine:Start<br></p>
--
-- @param[type=table] _Description Beschreibung
-- @return[type=number] ID des Zeitstrahls
-- @within Anwenderfunktionen
--
-- @usage MyTimeLine = API.TimeLineStart {
--     {Time = 1, Action = MyFirstAction},
--     -- MySecondAction erhält "BOCKWURST" als Parameter
--     {Time = 3, Action = MySecondAction, "BOCKWURST"},
--     -- Inline-Funktion
--     {Time = 9, Action = function() end},
-- }
--
function API.TimeLineStart(_Description)
    if type(_Description) ~= "table" then
        error("API.TimeLineStart: _Description must be a table!");
        return;
    end
    for i= 1, #_Description, 1 do
        if type(_Description.Time) ~= "number" or _Description.Time < 0 then
            error("API.TimeLineStart: _Description[" ..i.. "].Time (".. tostring(_Description.Time).. ") must be a positive number!");
            return;
        end
        if type(_Description.Action) ~= "function" then
            error("API.TimeLineStart: _Description[" ..i.. "].Action must be a function!");
            return;
        end
    end
    return BundleTimeLine.Shared.TimeLine:Start(_Description);
end

---
-- Startet einen Zeitstrahl erneut. Ist der Zeitstrahl noch nicht
-- beendet, beginnt er dennoch von vorn.
--
-- <p><b>Alias:</b> QSB.TimeLine:Restart<br></p>
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @within Anwenderfunktionen
--
-- @usage API.TimeLineRestart(MyTimeLine);
--
function API.TimeLineRestart(_ID)
    return BundleTimeLine.Shared.TimeLine:Restart(_ID)
end

---
-- Prüft, ob der Zeitstrahl noch nicht durchgelaufen ist.
--
-- <p><b>Alias:</b> QSB.TimeLine:IsRunning<br></p>
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @return[type=boolean] Zeitstrahl ist aktiv
-- @within Anwenderfunktionen
--
-- @usage local IsRunning = API.TimeLineIsRunning(MyTimeLine);
--
function API.TimeLineIsRunning(_ID)
    return BundleTimeLine.Shared.TimeLine:IsRunning(_ID);
end

---
-- Hält einen Zeitstrahl an.
--
-- <p><b>Alias:</b> QSB.TimeLine:Yield<br></p>
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @within Anwenderfunktionen
--
-- @usage API.TimeLineYield(MyTimeLine);
--
function API.TimeLineYield(_ID)
    return BundleTimeLine.Shared.TimeLine:Yield(_ID);
end

---
-- Stößt einen angehaltenen Zeitstrahl wieder an.
--
-- <p><b>Alias:</b> QSB.TimeLine:Resume<br></p>
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @within Anwenderfunktionen
--
-- @usage API.TimeLineResume(MyTimeLine);
--
function API.TimeLineResume(_ID)
    return BundleTimeLine.Shared.TimeLine:Resume(_ID);
end

-- -------------------------------------------------------------------------- --
-- TimeLine Klasse                                                            --
-- -------------------------------------------------------------------------- --

---
-- Startet einen Zeitstrahl. Ein Zeitstrahl hat Stationen,
-- an denen eine Aktion ausgeführt wird. Jede Station muss mindestens eine
-- Sekunde nach der vorherigen liegen.
--
-- Jede Aktion eines Zeitstrahls erhält die Table des aktuellen Ereignisses
-- als Argument. So können Parameter an die Funktion übergeben werden.
--
-- @param[type=table] _Description Beschreibung
-- @return[type=number] ID des Zeitstrahls
-- @within Anwenderfunktionen
-- @local
--
-- @usage MyTimeLine = QSB.TimeLine:Start {
--     {Time = 5, Action = MyFirstAction},
--     -- MySecondAction erhält "BOCKWURST" als Parameter
--     {Time = 15, Action = MySecondAction, "BOCKWURST"},
--     -- Inline-Funktion
--     {Time = 30, Action = function() end},
-- }
--
function QSB.TimeLine:Start(_description)
    local JobID = QSB.TimeLine.Data.TimeLineUniqueJobID;
    QSB.TimeLine.Data.TimeLineUniqueJobID = JobID +1;

    _description.Running = true;
    _description.StartTime = Logic.GetTime();
    _description.Iterator = 1;

    -- Check auf sinnvolle Zeitabstände
    local Last = 0;
    for i=1, #_description, 1 do
        if _description[i].Time < Last then
            _description[i].Time = Last+1;
            Last = _description[i].Time;
        end
    end

    QSB.TimeLine.Data.TimeLineJobs[JobID] = _description;
    if not QSB.TimeLine.Data.ControlerID then
        local Controler = StartSimpleJobEx(QSB.TimeLine.TimeLineControler);
        QSB.TimeLine.Data.ControlerID = Controler;
    end
    return JobID;
end
function API.TimeLineStart(_ID)
    return QSB.TimeLine:Start(_ID);
end

---
-- Startet einen Zeitstrahl erneut. Ist der Zeitstrahl noch nicht
-- beendet, beginnt er dennoch von vorn.
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @within Anwenderfunktionen
-- @local
--
-- @usage QSB.TimeLine:Restart(MyTimeLine);
--
function QSB.TimeLine:Restart(_ID)
    if not QSB.TimeLine.Data.TimeLineJobs[_ID] then
        return;
    end
    QSB.TimeLine.Data.TimeLineJobs[_ID].Running = true;
    QSB.TimeLine.Data.TimeLineJobs[_ID].StartTime = Logic.GetTime();
    QSB.TimeLine.Data.TimeLineJobs[_ID].Iterator = 1;
end
function API.TimeLineRestart(_ID)
    QSB.TimeLine:Restart(_ID);
end

---
-- Prüft, ob der Zeitstrahl noch nicht durchgelaufen ist.
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @return[type=boolean] Zeitstrahl ist aktiv
-- @within Anwenderfunktionen
-- @local
--
-- @usage local IsRunning = QSB.TimeLine:IsRunning(MyTimeLine);
--
function QSB.TimeLine:IsRunning(_ID)
    if QSB.TimeLine.Data.TimeLineJobs[_ID] then
        return QSB.TimeLine.Data.TimeLineJobs[_ID].Running == true;
    end
    return false;
end
function API.TimeLineIsRunning(_ID)
    QSB.TimeLine:IsRunning(_ID);
end

---
-- Hält einen Zeitstrahl an.
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @within Anwenderfunktionen
-- @local
--
-- @usage QSB.TimeLine:Yield(MyTimeLine);
--
function QSB.TimeLine:Yield(_ID)
    if not QSB.TimeLine.Data.TimeLineJobs[_ID] then
        return;
    end
    QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime = Logic.GetTime();
    QSB.TimeLine.Data.TimeLineJobs[_ID].Running = false;
end
function API.TimeLineYield(_ID)
    QSB.TimeLine:Yield(_ID);
end

---
-- Stößt einen angehaltenen Zeitstrahl wieder an.
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @within Anwenderfunktionen
-- @local
--
-- @usage QSB.TimeLine:Resume(MyTimeLine);
--
function QSB.TimeLine:Resume(_ID)
    if not QSB.TimeLine.Data.TimeLineJobs[_ID] then
        return;
    end
    if QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime then
        local OldStartTime = QSB.TimeLine.Data.TimeLineJobs[_ID].StartTime;
        local TimeYielded = Logic.GetTime() - QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime;
        QSB.TimeLine.Data.TimeLineJobs[_ID].StartTime = OldStartTime + TimeYielded;
        QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime = nil;
    end
    QSB.TimeLine.Data.TimeLineJobs[_ID].Running = true;
end
function API.TimeLineResume(_ID)
    QSB.TimeLine:Resume(_ID);
end

---
-- Steuert alle Zeitstrahlen.
-- @within QSB.TimeLine
-- @local
--
function QSB.TimeLine.TimeLineControler()
    for k,v in pairs(QSB.TimeLine.Data.TimeLineJobs) do
        if v.Iterator > #v then
            QSB.TimeLine.Data.TimeLineJobs[k].Running = false;
        end

        if v.Running then
            if (v[v.Iterator].Time + v.StartTime) <= Logic.GetTime() then
                v[v.Iterator].Action(unpack(v[v.Iterator]));
                QSB.TimeLine.Data.TimeLineJobs[k].Iterator = v.Iterator +1;
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleTimeLine = {
    Global = {
        Data = {}
    },
    Local = {
        Data = {}
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleTimeLine.Global:Install()
    TimeLine = QSB.TimeLine;
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleTimeLine.Local:Install()
    TimeLine = QSB.TimeLine;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleTimeLine");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleTravelingSalesman                                       # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle wird ein Fahrender Händler angeboten der periodisch den
-- Hafen mit einem Schiff anfährt. Dabei kann der Fahrtweg frei mit Wegpunkten
-- bestimmt werden. Es können auch mehrere Spieler zu Händlern gemacht werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleTravelingSalesman = {};

API = API or {};
QSB = QSB or {};

QSB.ShipWaypointDistance = 300;

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt einen fahrender Händler mit zufälligen Angeboten.
--
-- Soll immer das selbe angeboten werden, darf es nur genauso viele Angebote
-- geben, wie als Maximum gesetzt wird.
--
-- Es kann mehr als einen fahrender Händler auf der Map geben.
--
-- <h5>Angebote</h5>
-- Es können Waren, Soldaten oder Entertainer angeboten werden. Aus allen
-- definierten Angeboten werden zufällig Angebote in der angegebenen Mange
-- ausgesucht und gesetzt.
--
-- <h5>Routen</h5>
-- Um die Route anzugeben, wird ein Name eingegeben. Es werden alle fortlaufend
-- nummerierte Punkte mit diesem Namen gesucht. Alternativ kann auch eine
-- Liste von Punkten angegeben werden. Es muss mindestens 2 Punkte geben.
--
-- <b>Alias</b>: TravelingSalesmanActivate
--
-- @param[type=table]  _Description Definition des Händlers
-- @within Anwenderfunktionen
--
-- @usage local TraderDescription = {
--     PlayerID   = 2,       -- Partei des Hafen
--     Path       = "SH2WP", -- Pfad (auch als Table einzelner Punkte möglich)
--     Duration   = 150,     -- Ankerzeit in Sekunden (Standard: 360)
--     Interval   = 3,       -- Monate zwischen zwei Anfarten (Standard: 2)
--     OfferCount = 4,       -- Anzahl Angebote (1 bis 4) (Standard: 4)
--     NoIce      = true,    -- Schiff kommt nicht im Winter (Standard: false)
--     Offers = {
--         -- Angebot, Menge
--         {"G_Gems", 5},
--         {"G_Iron", 5},
--         {"G_Beer", 2},
--         {"G_Stone", 5},
--         {"G_Sheep", 1},
--         {"G_Cheese", 2},
--         {"G_Milk", 5},
--         {"G_Grain", 5},
--         {"G_Broom", 2},
--         {"U_CatapultCart", 1},
--         {"U_MilitarySword", 3},
--         {"U_MilitaryBow", 3}
--     },
-- };
-- API.TravelingSalesmanCreate(TraderDescription);
--
function API.TravelingSalesmanCreate(_TraderDescription)
    if GUI then
        return;
    end
    if type(_TraderDescription) ~= "table" then
        error("API.TravelingSalesmanCreate: _TraderDescription must be a table!");
        return;
    end
    if type(_TraderDescription.PlayerID) ~= "number" or _TraderDescription.PlayerID < 1 or _TraderDescription.PlayerID > 8 then
        error("API.TravelingSalesmanCreate: _TraderDescription.PlayerID (" ..tostring(_TraderDescription.PlayerID).. ") is wrong!");
        return;
    end
    if type(_TraderDescription.Duration) ~= "number" or _TraderDescription.Duration < 60 then
        error("API.TravelingSalesmanCreate: _TraderDescription.Duration (" ..tostring(_TraderDescription.Duration).. ") must be at least 60 seconds!");
        return;
    end
    if type(_TraderDescription.Interval) ~= "number" or _TraderDescription.Interval < 1 then
        error("API.TravelingSalesmanCreate: _TraderDescription.Interval (" ..tostring(_TraderDescription.Interval).. ") must be at least 1 month!");
        return;
    end
    if type(_TraderDescription.OfferCount) ~= "number" or _TraderDescription.OfferCount < 1 or _TraderDescription.OfferCount > 4 then
        error("API.TravelingSalesmanCreate: _TraderDescription.Duration (" ..tostring(_TraderDescription.OfferCount).. ") is wrong!");
        return;
    end
    if type(_TraderDescription.Offers) ~= "table" or #_TraderDescription.Offers < _TraderDescription.OfferCount then
        error("API.TravelingSalesmanCreate: _TraderDescription.Offers must have at least " .._TraderDescription.OfferCount.." entries!");
        return;
    end
    for i= 1, #_TraderDescription.Offers, 1 do
        if Goods[_TraderDescription.Offers[i][1]] == nil and Entities[_TraderDescription.Offers[i][1]] == nil then
            error("API.TravelingSalesmanCreate: _TraderDescription.Offers[" ..i.. "][1] is invalid good type!");
            return;
        end
        if type(_TraderDescription.Offers[i][2]) ~= "number" or _TraderDescription.Offers[i][2] < 1 then
            error("API.TravelingSalesmanCreate: _TraderDescription.Offers[" ..i.. "][2] amount must be at least 1!");
            return;
        end
    end

    API.TravelingSalesmanDispose(_TraderDescription.PlayerID);
    _TraderDescription.Offers = API.ConvertOldOfferFormat(_TraderDescription.Offers);
    _TraderDescription.Duration = _TraderDescription.Duration or (6 * 60);
    _TraderDescription.Interval = _TraderDescription.Interval or 2;
    _TraderDescription.OfferCount = _TraderDescription.OfferCount or 4;

    local Harbor = QSB.TradeShipHarbor:New(_TraderDescription.PlayerID)
        :SetPath(_TraderDescription.Path or _TraderDescription.Waypoints)
        :SetDuration(_TraderDescription.Duration)
        :SetInterval(_TraderDescription.Interval)
        :SetNoIce(_TraderDescription.NoIce == true)
        :SetOfferCount(_TraderDescription.OfferCount);

    local OffersString = "";
    for i= 1, #_TraderDescription.Offers, 1 do
        Harbor:AddOffer(_TraderDescription.Offers[i][1], _TraderDescription.Offers[i][2]);       
        OffersString = OffersString .. "(" ..tostring(_TraderDescription.Offers[i][1]).. ", " .._TraderDescription.Offers[i][2].. "){cr}";
    end
    Harbor:SetActive(true);
    BundleTravelingSalesman.Global:RegisterHarbor(Harbor);

    info("API.TravelingSalesmanCreate: creating habor for player " .._TraderDescription.PlayerID.. "{cr}"..
         "Duration: " .._TraderDescription.Duration.. "{cr}"..
         "Interval: " .._TraderDescription.Interval.. "{cr}"..
         "Offers per period: " .._TraderDescription.OfferCount.. "{cr}"..
         "Offer types:{cr}" ..OffersString);
end
TravelingSalesmanCreate = API.TravelingSalesmanCreate;

---
-- Konvertiert die Angebote, falls sie im alten Format angegeben wurden.
-- @param[type=table] _Offers Angebotsliste
-- @return Umgeformte Angebote
-- @within Anwenderfunktionen
-- @local
--
function API.ConvertOldOfferFormat(_Offers)
    if type(_Offers[1][1]) ~= "table" then
        return _Offers;
    end
    local Offers = {};
    for i= 1, #_Offers, 1 do
        for j= 1, #_Offers[i], 1 do
            local Found = false;
            for k= 1, #Offers, 1 do
                if Offers[k][1] == _Offers[i][j][1] then
                    Found = true;
                    break;
                end
            end
            if (not Found) then
                table.insert(Offers, _Offers[i][j]);
            end
        end
    end
    return Offers;
end
ConvertOldOfferFormat = API.ConvertOldOfferFormat;

---
-- Entfernt den fahrenden Händler von dem Spieler. Der Spieler bleibt
-- erhalten wird aber nicht mal als fahrender Händler fungieren.
--
-- <b>Hinweis</b>: Wenn gerade ein Schiff unterwegs ist oder im Hafen liegt,
-- wird es sofort gelöscht!
--
-- <b>Alias</b>: TravelingSalesmanDeactivate
--
-- @param[type=number] _PlayerID Spieler-ID des Händlers
-- @within Anwenderfunktionen
--
-- @usage API.TravelingSalesmanDispose(2);
--
function API.TravelingSalesmanDispose(_PlayerID)
    if GUI then
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.TravelingSalesmanDispose: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    local Harbor = BundleTravelingSalesman.Global.Data.Harbors[_PlayerID];
    if Harbor then
        info("API.TravelingSalesmanDispose: Deleting habor of player " .._PlayerID);
        Harbor:Dispose();
    end
    BundleTravelingSalesman.Global.Data.Harbors[_PlayerID] = nil;
end
TravelingSalesmanDeactivate = API.TravelingSalesmanDispose;

---
-- Deaktiviert einen fahrenden Händler. Der aktuelle Zyklus wird noch beendet,
-- aber danach kommt der Händler nicht mehr wieder.
--
-- <b>Alias</b>: TravelingSalesmanYield
--
-- @param[type=number] _PlayerID Spieler-ID des Händlers
-- @within Anwenderfunktionen
--
-- @usage API.TravelingSalesmanYield(2);
--
function API.TravelingSalesmanYield(_PlayerID)
    if GUI then
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.TravelingSalesmanYield: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    local Harbor = BundleTravelingSalesman.Global.Data.Harbors[_PlayerID];
    if Harbor then
        info("API.TravelingSalesmanYield: Suspending habor of player " .._PlayerID);
        Harbor:SetActive(false);
    end
end
API.TravelingSalesmanDeactivate = API.TravelingSalesmanYield;
TravelingSalesmanYield = API.TravelingSalesmanYield;

---
-- Aktiviert einen fahrenden Händler, der zuvor deaktiviert wurde.
--
-- <b>Alias</b>: TravelingSalesmanResume
--
-- @param[type=number] _PlayerID Spieler-ID des Händlers
-- @within Anwenderfunktionen
--
-- @usage API.TravelingSalesmanResume(2);
--
function API.TravelingSalesmanResume(_PlayerID)
    if GUI then
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.TravelingSalesmanResume: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    local Harbor = BundleTravelingSalesman.Global.Data.Harbors[_PlayerID];
    if Harbor then
        info("API.TravelingSalesmanResume: Resuming habor of player " .._PlayerID);
        Harbor:SetActive(true);
    end
end
API.TravelingSalesmanActivate = API.TravelingSalesmanResume;
TravelingSalesmanResume = API.TravelingSalesmanResume;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleTravelingSalesman = {
    Global = {
        Data = {
            Harbors = {},
            QuestInfoCounter = 0,
        },
    },
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleTravelingSalesman.Global:Install()
    -- End of Month Callback
    Core:AppendFunction("GameCallback_EndOfMonth", function()
        BundleTravelingSalesman.Global:TravelingSalesmanEndOfMonth();
    end);
    -- Controller
    StartSimpleJobEx(function()
        BundleTravelingSalesman.Global:TravelingSalesmanController()
    end);
end

---
-- Registiert einen Hafen. Kann benutzt werden um Häfen zu überschreiben.
-- @param[type=table] _Harbor Harbor Model
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:RegisterHarbor(_Harbor)
    if self.Data.Harbors[_Harbor.m_PlayerID] then
        info("BundleTravelingSalesman: harbor for player " .._Harbor.m_PlayerID.. " already exists and is purged.");
        self.Data.Harbors[_Harbor.m_PlayerID]:Dispose();
    end
    info("BundleTravelingSalesman: creating harbor for player " .._Harbor.m_PlayerID.. ".");
    self.Data.Harbors[_Harbor.m_PlayerID] = _Harbor;
end

---
-- Erzeugt das Schiff und lässt es zum Hafen fahren.
-- @param[type=table] _Harbor Harbor Model
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:SpawnShip(_Harbor)
    local SpawnPoint = _Harbor:GetPath():GetFirst();
    local Orientation = Logic.GetEntityOrientation(GetID(SpawnPoint));
    local x, y, z = Logic.EntityGetPos(GetID(SpawnPoint))
    local ID = Logic.CreateEntity(Entities.D_X_TradeShip, x, y, Orientation, 0);
    _Harbor:SetShipID(ID);
    _Harbor:GetPath():SetReversed(false);
    local OnArrival = function(_Data)
        BundleTravelingSalesman.Global:ShipAtDock(_Data.Entity);
    end
    info("BundleTravelingSalesman: Ship of player " .._Harbor:GetPlayerID().. " has spawns.");
    local Instance = Path:new(ID, _Harbor:GetPath():Get(), nil, nil, OnArrival, nil, true, nil, nil, QSB.ShipWaypointDistance);
    _Harbor:SetJobID(Instance.Job);
end

---
-- Lässt das Schiff aus dem Hafen abfahren.
-- @param[type=table] _Harbor Harbor Model
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:ShipLeave(_Harbor)
    Logic.RemoveAllOffers(Logic.GetStoreHouse(_Harbor:GetPlayerID()));
    self:TriggerShipIsLeavingDockMessage(_Harbor:GetPlayerID());
    _Harbor:GetPath():SetReversed(true);
    local OnArrival = function(_Data)
        BundleTravelingSalesman.Global:ShipHasLeft(_Data.Entity);
    end
    info("BundleTravelingSalesman: Ship of player " .._Harbor:GetPlayerID().. " is leaving the harbor.");
    local Instance = Path:new(_Harbor:GetShipID(), _Harbor:GetPath():Get(), nil, nil, OnArrival, nil, true, nil, nil, QSB.ShipWaypointDistance);
    _Harbor:SetJobID(Instance.Job);
    if GameCallback_TravelingSalesmanLeave then
        GameCallback_TravelingSalesmanLeave(_Harbor:GetPlayerID(), _Harbor:GetShipID());
    end
end

---
-- Entfernt die Angebote und setzt die Werte zurück, sobald das Schiff abfährt.
-- @param[type=number] _ShipID ID des Schiffes
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:ShipHasLeft(_ShipID)
    local Harbor = self:GetHarborByShipID(_ShipID);
    if (Harbor) then
        info("BundleTravelingSalesman: Ship of player " ..Harbor:GetPlayerID().. " has despawned.");
        Harbor:SetJobID(0);
        Harbor:SetShipID(0);
        Harbor:SetDuration(Harbor:GetDuration());
        Harbor:SetIntermission(Harbor:GetInterval() +1);
        DestroyEntity(_ShipID);
    end
end

---
-- Erzeugt die Angebote sobald das Schiff im Hafen anlegt.
-- @param[type=number] _ShipID ID des Schiffes
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:ShipAtDock(_ShipID)
    local Harbor = self:GetHarborByShipID(_ShipID);
    if (Harbor) then
        info("Ship of player " ..Harbor:GetPlayerID().. " is arriving at the harbor.");
        Harbor:SetJobID(0);
        local PlayerID = Harbor:GetPlayerID();
        MerchantSystem.TradeBlackList[PlayerID] = {};
        MerchantSystem.TradeBlackList[PlayerID][0] = 0;
        self:CreateOffers(Harbor:GetRandomOffers(), Logic.GetStoreHouse(PlayerID))
        self:TriggerShipAtDockMessage(PlayerID);
        if GameCallback_TravelingSalesmanArrive then
            GameCallback_TravelingSalesmanArrive(PlayerID, _ShipID);
        end
    end
end

---
-- Erzeugt die Angebote für das angegebene Lagerhaus.
-- @param[type=table] _Offers   Angebote
-- @param[type=number] _TraderID ID Lagerhaus
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:CreateOffers(_Offers, _TraderID)
    DeActivateMerchantForPlayer(_TraderID, QSB.HumanPlayerID);
    Logic.RemoveAllOffers(_TraderID);
    local LogInfo = "BundleTravelingSalesman: Creating offers for player " .._TraderID..":";
    if #_Offers > 0 then
        LogInfo = LogInfo.. "{cr}Offers:";
        local OfferString = "";
        for i=1,#_Offers,1 do
            if Goods[_Offers[i][1]] then
                AddOffer(_TraderID, _Offers[i][2], Goods[_Offers[i][1]], 9999);
            else
                if Logic.IsEntityTypeInCategory(Entities[_Offers[i][1]], EntityCategories.Military)== 0 then
                    AddEntertainerOffer(_TraderID, Entities[_Offers[i][1]]);
                else
                    AddMercenaryOffer(_TraderID, _Offers[i][2], Entities[_Offers[i][1]], 9999);
                end
            end
            OfferString = OfferString .. "{cr}(" .._Offers[i][1].. ", " ..((_Offers[i][2] ~= nil and _Offers[i][2]) or 1).. ")";
        end
        if GetDiplomacyState(QSB.HumanPlayerID, Logic.EntityGetPlayer(_TraderID)) > 0 then
            ActivateMerchantPermanentlyForPlayer(_TraderID, QSB.HumanPlayerID);
            Logic.ExecuteInLuaLocalState("g_Merchant.ActiveMerchantBuilding = nil");
        end
        LogInfo = LogInfo .. OfferString;
    end
    info(LogInfo);
end

---
-- Zeigt eine Quest Message an, dass das Schiff im Hafen vor Anker liegt.
-- @param[type=number] _PlayerID Player-ID
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:TriggerShipAtDockMessage(_PlayerID)
    self:DisplayQuestMessage(_PlayerID, {
        de = "Ein Schiff hat angelegt. Es bringt Güter von weit her.",
        en = "A ship is at the pier. It delivers goods from far away.",
    });
end

---
-- Zeigt eine Quest Message an, dass das Schiff den Hafen verlassen hat.
-- @param[type=number] _PlayerID Player-ID
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:TriggerShipIsLeavingDockMessage(_PlayerID)
    self:DisplayQuestMessage(_PlayerID, {
        de = "Das Schiff hat den Hafen wieder verlassen.",
        en = "Time has passed on and the ship has left.",
    });
end

---
-- Zeigt eine Quest Message an.
-- @param[type=number] _PlayerID Player-ID
-- @param              _Text (Table oder String)
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:DisplayQuestMessage(_PlayerID, _Text)
    self.Data.QuestInfoCounter = self.Data.QuestInfoCounter +1;
    QuestTemplate:New(
        "TravelingSalesman_Info_P" ..self.Data.QuestInfoCounter,
        _PlayerID,
        QSB.HumanPlayerID,
        {{Objective.Dummy,}},
        {{Triggers.Time, 0}},
        0,
        nil, nil, nil, nil, false, true,
        nil, nil,
        API.Localize(_Text),
        nil
    );
end

---
-- Ermitteld den Hafen des angegeben Schiffes.
-- @param[type=number] _ShipID ID des Schiffes
-- @return[type=table] Hafen Model
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:GetHarborByShipID(_ShipID)
    local Harbor;
    for i= 1, 8, 1 do
        Harbor = self.Data.Harbors[i];
        if (Harbor and Harbor:GetShipID() == _ShipID) then
            return Harbor;
        end
    end
    return nil;
end

---
-- Steuert die Anfahrt der Schiffe für alle Häfen.
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:TravelingSalesmanEndOfMonth()
    for i= 1, 8, 1 do
        local Harbor = self.Data.Harbors[i];
        if  (Harbor and Harbor:IsActive() and Harbor:GetShipID() == 0 and not Harbor:IsIceBlockingPath()) then
            if (Harbor:SetIntermission(Harbor:GetIntermission() -1):GetIntermission() == 0) then
                Harbor:SetIntermission(-100);
                BundleTravelingSalesman.Global:SpawnShip(Harbor);
            end
        end
    end
end

---
-- Steuert die Abfahrt der Schiffe für alle Häfen.
-- @Internal
-- @local
--
function BundleTravelingSalesman.Global:TravelingSalesmanController()
    for i= 1, 8, 1 do
        local Harbor = self.Data.Harbors[i];
        if  (Harbor and not Harbor:HasElapsed() and Harbor:GetShipID() ~= 0 and not Harbor:IsIceBlockingPath()
        and IsNear(Harbor:GetShipID(), Harbor:GetPath():GetLast(), QSB.ShipWaypointDistance)) then
            if (Harbor:Elapse():HasElapsed()) then
                self:ShipLeave(Harbor);
            end
        end
    end
end

-- Klassen ------------------------------------------------------------------ --

QSB.TradeShipPath = {
    m_Waypoints = {};
    m_Reversed = false;
}

function QSB.TradeShipPath:New(...)
    local Path = API.InstanceTable(self);
    if #arg == 1 and type(arg[1]) == "string" then
        local i = 1;
        while (IsExisting(arg[1] ..i)) do
            table.insert(Path.m_Waypoints, arg[1] ..i);
            i = i +1;
        end
    elseif #arg == 1 and type(arg[1]) == "table" then
        Path.m_Waypoints = API.InstanceTable(arg[1]);
    else
        Path.m_Waypoints = API.InstanceTable(arg);
    end
    return Path;
end

function QSB.TradeShipPath:GetFirst()
    return self.m_Waypoints[1];
end

function QSB.TradeShipPath:GetLast()
    return self.m_Waypoints[#self.m_Waypoints];
end

function QSB.TradeShipPath:Get()
    local Path = self.m_Waypoints;
    if (self.m_Reversed == true) then
        Path = {};
        for i= #self.m_Waypoints, 1, -1 do
            table.insert(Path, self.m_Waypoints[i]);
        end
    end
    return Path;
end

function QSB.TradeShipPath:IsReversed()
    return self.m_Reversed == true;
end

function QSB.TradeShipPath:SetReversed(_Reversed)
    self.m_Reversed = _Reversed == true;
    return;
end

-- -------------------------------------------------------------------------- --

QSB.TradeShipHarbor = {
    m_Path = {};
    m_OfferTypes = {};
    m_Active = false;
    m_NoIce = false;
    m_PlayerID = 1;
    m_Duration = 180;
    m_TimeLeft = 180;
    m_Interval = 2;
    m_BreakMonths = 1;
    m_OfferCount = 0;
    m_ShipID = 0;
    m_JobID = 0;
};

function QSB.TradeShipHarbor:New(_PlayerID)
    local Harbor = API.InstanceTable(self);
    Harbor.m_PlayerID = _PlayerID;
    return Harbor;
end

function QSB.TradeShipHarbor:Dispose()
    if self.m_ShipID ~= 0 then
        DestroyEntity(self.m_ShipID);
    end
    if (JobIsRunning(self.m_JobID)) then
        EndJob(self.m_JobID);
    end
    Logic.RemoveAllOffers(Logic.GetStoreHouse(self.m_PlayerID));
end

function QSB.TradeShipHarbor:GetDurationInMonths()
    return math.ceil(self.m_Duration / Logic.GetMonthDurationInSeconds());
end

function QSB.TradeShipHarbor:GetPlayerID()
    return self.m_PlayerID;
end

function QSB.TradeShipHarbor:GetShipID()
    return self.m_ShipID;
end

function QSB.TradeShipHarbor:SetShipID(_ID)
    self.m_ShipID = _ID;
    return self;
end

function QSB.TradeShipHarbor:SetJobID(_ID)
    self.m_JobID = _ID;
    return self;
end

function QSB.TradeShipHarbor:GetIntermission()
    return self.m_BreakMonths;
end

function QSB.TradeShipHarbor:SetIntermission(_Break)
    self.m_BreakMonths = _Break;
    return self;
end

function QSB.TradeShipHarbor:GetDuration()
    return self.m_Duration;
end

function QSB.TradeShipHarbor:SetDuration(_Duration)
    self.m_Duration = _Duration;
    self.m_TimeLeft = _Duration;
    return self;
end

function QSB.TradeShipHarbor:Elapse()
    self.m_TimeLeft = self.m_TimeLeft -1;
    return self;
end

function QSB.TradeShipHarbor:HasElapsed()
    return self.m_TimeLeft < 1;
end

function QSB.TradeShipHarbor:GetInterval()
    return self.m_Interval;
end

function QSB.TradeShipHarbor:SetInterval(_Interval)
    self.m_Interval = _Interval;
    self.m_BreakMonths = 1;
    return self;
end

function QSB.TradeShipHarbor:SetNoIce(_NoIce)
    self.m_NoIce = _NoIce == true;
    return self;
end

function QSB.TradeShipHarbor:IsNoIce()
    return self.m_NoIce == true;
end

function QSB.TradeShipHarbor:SetActive(_Active)
    self.m_Active = _Active == true;
    return self;
end

function QSB.TradeShipHarbor:IsActive()
    return self.m_Active == true;
end

function QSB.TradeShipHarbor:SetPath(...)
    self.m_Path = QSB.TradeShipPath:New(unpack(arg));
    return self;
end

function QSB.TradeShipHarbor:GetPath()
    return self.m_Path;
end

function QSB.TradeShipHarbor:SetOfferCount(_Count)
    self.m_OfferCount = _Count;
    return self;
end

function QSB.TradeShipHarbor:AddOffer(_Good, Amount)
    for i= 1, #self.m_OfferTypes, 1 do
        if (self.m_OfferTypes[i][1]) == _Good then
            return self;
        end
    end
    table.insert(self.m_OfferTypes, {_Good, Amount});
    return self;
end

function QSB.TradeShipHarbor:IsIceBlockingPath()
    return self:IsNoIce() and Logic.GetWeatherDoesWaterFreezeByMonth(Logic.GetCurrentMonth());
end

function QSB.TradeShipHarbor:GetRandomOffers()
    local Offers = {};
    if #self.m_OfferTypes >= self.m_OfferCount then
        local OffersToChoose = self.m_OfferCount;
        while (OffersToChoose > 0) do
            local RandomOffer = math.random(1, #self.m_OfferTypes);
            local Found = false;
            for i= 1, #Offers, 1 do
                if (Offers[i][1] == self.m_OfferTypes[RandomOffer][1]) then
                    Found = true;
                    break;
                end
            end
            if not Found then
                table.insert(Offers, {self.m_OfferTypes[RandomOffer][1], self.m_OfferTypes[RandomOffer][2]});
                OffersToChoose = OffersToChoose -1;
            end
        end
    end
    return Offers;
end

-- -------------------------------------------------------------------------- --

---
-- Erstellt einen fliegenden Händler für den angegebenen Spieler.
--
-- Der fliegende Händler kann bis zu 4 Angebote haben. Schiffe werden im
-- angegeben Interall anlegen und nach Ablauf der Aufenthaltsdauer wieder
-- abfahren.
--
-- @param _PlayerID      ID des Spielers
-- @param _Interval      Interval in Monaten
-- @param _Duration      Anlegezeit in Sekunden
-- @param _OfferCount1   Menge Angebot 1
-- @param _OfferType1    Typ Angebot 1
-- @param _OfferCount2   Menge Angebot 2
-- @param _OfferType2    Typ Angebot 2
-- @param _OfferCount3   Menge Angebot 3
-- @param _OfferType3    Typ Angebot 3
-- @param _OfferCount4   Menge Angebot 4
-- @param _OfferType4    Typ Angebot 4
-- @param _Path          Präfix der Path Entities
-- @param _YieldIce      Wenn Wasser gefriert pausieren
--
-- @within Reward
--
function Reward_TravelingSalesman(...)
    return b_Reward_TravelingSalesman:new(...)
end

b_Reward_TravelingSalesman = {
    Name = "Reward_TravelingSalesman",
    Description = {
        en = "Reward: Creates or overrides the player as traveling salesman with up to 4 offers. Ships will come in the defined interval and leave after the duration is up.",
        de = "Lohn: Erstellt oder überschreibt den Spieler als fahrenden Händler mit bis zu 4 Angeboten. Schiffe werden im angegeben Interall anlegen und nach Ablauf der Aufenthaltsdauer wieder abfahren.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "PlayerID", de = "PlayerID" },
        { ParameterType.Number, en = "Interval", de= "Interval" },
        { ParameterType.Number, en = "Duration", de= "Aufenthaltsdauer" },
        { ParameterType.Custom, en = "Amount 1", de = "Menge 1" },
        { ParameterType.Custom, en = "Offer 1", de = "Angebot 1" },
        { ParameterType.Custom, en = "Amount 2", de = "Menge 2" },
        { ParameterType.Custom, en = "Offer 2", de = "Angebot 2" },
        { ParameterType.Custom, en = "Amount 3", de = "Menge 3" },
        { ParameterType.Custom, en = "Offer 3", de = "Angebot 3" },
        { ParameterType.Custom, en = "Amount 4", de = "Menge 4" },
        { ParameterType.Custom, en = "Offer 4", de = "Angebot 4" },
        { ParameterType.Default, en = "Prefix of waypoints", de = "Präfix der Wegpunkte" },
        { ParameterType.Custom, en = "Not in winter", de = "Nicht im Winter" },
    },
}

function b_Reward_TravelingSalesman:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} };
end

function b_Reward_TravelingSalesman:AddParameter(_Index, _Parameter)
    if (_Index == 0) then 
        self.PlayerID = _Parameter*1;
    elseif (_Index == 1) then
        self.Interval = _Parameter*1;
    elseif (_Index == 2) then
        self.Duration = _Parameter*1;
    elseif (_Index == 3) then
        self.AmountOffer1 = _Parameter*1;
    elseif (_Index == 4) then
        self.Offer1 = _Parameter;
    elseif (_Index == 5) then
        self.AmountOffer2 = _Parameter*1;
    elseif (_Index == 6) then
        self.Offer2 = _Parameter;
    elseif (_Index == 7) then
        self.AmountOffer3 = _Parameter*1;
    elseif (_Index == 8) then
        self.Offer3 = _Parameter;
    elseif (_Index == 9) then
        self.AmountOffer4 = _Parameter*1;
    elseif (_Index == 10) then
        self.Offer4 = _Parameter;
    elseif (_Index == 11) then
        self.Path = _Parameter;
    elseif (_Index == 12) then
        self.NotInWinter = AcceptAlternativeBoolean(_Parameter);
    end
end

function b_Reward_TravelingSalesman:GetCustomData(_Index)
    local Boolean = { "No", "Yes" }
    local Offers = {
        "-",
        "G_Beer",
        "G_Bow",
        "G_Bread",
        "G_Broom",
        "G_Candle",
        "G_Carcass",
        "G_Cheese",
        "G_Clothes",
        "G_Cow",
        "G_Grain",
        "G_Herb",
        "G_Honeycomb",
        "G_Iron",
        "G_Leather",
        "G_Medicine",
        "G_Milk",
        "G_RawFish",
        "G_Sausage",
        "G_Sheep",
        "G_SmokedFish",
        "G_Soap",
        "G_Stone",
        "G_Sword",
        "G_Wood",
        "G_Wool",
        "G_Salt",
        "G_Dye",
        "U_MilitaryBandit_Melee_ME",
        "U_MilitaryBandit_Melee_SE",
        "U_MilitaryBandit_Melee_NA",
        "U_MilitaryBandit_Melee_NE",
        "U_MilitaryBandit_Ranged_ME",
        "U_MilitaryBandit_Ranged_NA",
        "U_MilitaryBandit_Ranged_NE",
        "U_MilitaryBandit_Ranged_SE",
        "U_Entertainer_NA_FireEater",
        "U_Entertainer_NA_StiltWalker",
        "U_Entertainer_NE_StrongestMan_Barrel",
        "U_Entertainer_NE_StrongestMan_Stone",
    };
    if g_GameExtraNo and g_GameExtraNo >= 1 then
        table.insert(Offers, "G_Gems");
        table.insert(Offers, "G_Olibanum");
        table.insert(Offers, "G_MusicalInstrument");
        table.insert(Offers, "G_MilitaryBandit_Ranged_AS");
        table.insert(Offers, "G_MilitaryBandit_Melee_AS");
    end
    if (_Index == 3 or _Index == 5 or _Index == 7 or _Index == 9) then
        return {0,1,2,3,4,5,6,7,8,9};
    elseif (_Index == 4 or _Index == 6 or _Index == 8 or _Index == 10) then
        return Offers;
    elseif (_Index == 12) then
        return {"false", "true"};
    end
end

function b_Reward_TravelingSalesman:CustomFunction(_Quest)
    local OfferData = self:GetOffers(_Quest);
    assert(#OfferData > 0 and #OfferData < 5);

    local TraderDescription = {
        PlayerID   = self.PlayerID,
        Path       = self.Path,
        Duration   = self.Duration,
        Interval   = self.Interval,
        OfferCount = #OfferData,
        NoIce      = self.NotInWinter,
        Offers     = OfferData,
    };
    API.TravelingSalesmanCreate(TraderDescription);
end

function b_Reward_TravelingSalesman:GetOffers(_Quest)
    local OfferData = {};
    if self.Offer1 and self.Offer1 ~= "-" and self.AmountOffer1 and self.AmountOffer1 > 0 then
        table.insert(OfferData, {self.Offer1, self.AmountOffer1});
    end
    if self.Offer2 and self.Offer2 ~= "-" and self.AmountOffer2 and self.AmountOffer2 > 0 then
        table.insert(OfferData, {self.Offer1, self.AmountOffer1});
    end
    if self.Offer3 and self.Offer3 ~= "-" and self.AmountOffer3 and self.AmountOffer3 > 0 then
        table.insert(OfferData, {self.Offer1, self.AmountOffer1});
    end
    if self.Offer4 and self.Offer4 ~= "-" and self.AmountOffer4 and self.AmountOffer4 > 0 then
        table.insert(OfferData, {self.Offer1, self.AmountOffer1});
    end
    return OfferData;
end

function b_Reward_TravelingSalesman:Debug(_Quest)
    local OfferData = self:GetOffers(_Quest);
    if (#OfferData > 0 and #OfferData < 5) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Too few or too many offers!");
        return true;
    end
    for i= 1, #OfferData, 1 do
        if not OfferData[i][1] or (OfferData[i][1] ~= "-" and (Goods[OfferData[i][1]] == nil or Entities[OfferData[i][1]] == nil)) then
            error(_Quest.Identifier.. ": " ..self.Name .. ": offer " ..i.. " is neither good nor entity type!");
            return true;
        end
        if type(OfferData[i][2]) ~= "number" or OfferData[i][2] < 0 then
            error(_Quest.Identifier.. ": " ..self.Name .. ": offer " ..i.. " has invalid amount!");
            return true;
        end
    end
    if type(self.PlayerID) ~= "number" or self.PlayerID < 1 or self.PlayerID > 8 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": player id must be between 1 and 8!");
        return true;
    end
    if type(self.Interval) ~= "number" or self.Interval < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": interval must be greater than 0!");
        return true;
    end
    if type(self.Duration) ~= "number" or self.Duration < 1 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": duration must be greater than 0!");
        return true;
    end
    if (self.Path == nil) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": missing the path!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_TravelingSalesman);

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleTravelingSalesman");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleWeatherManipulation                                    # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Modul ermöglicht das Ändern des Wetters.
--
-- Es können nun relativ einfach Wetterevents und Wetteranimationen kombiniert
-- gestartet werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleWeatherManipulation = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erzeugt ein neues Wetterevent und gibt es zurück.
--
-- Ein Event alleine ändert noch nicht das Wetter! Hier wird ein Event
-- definiert, welches an anderer Stelle benutzt werden kann. Das definierte
-- Event kann jedoch in einer Variable gespeichert und immer wieder neu
-- verwendet werden.
--
-- <b>Hinweis</b>: Es handelt sich um eine dynamische Wettersequenz. Dies muss
-- beachtet werden! Eine statische Sequenz wird nicht funktionieren!
--
-- @param[type=string]  _GFX        Verwendetes Display Set
-- @param[type=boolean] _Rain       Niederschlag aktivieren
-- @param[type=boolean] _Snow       Niederschlag ist Schnee
-- @param[type=boolean] _Ice        Wasser gefriert
-- @param[type=boolean] _Monsoon    Blockendes Monsunwasser aktivieren
-- @param[type=number]  _Temp       Temperatur während des Events
-- @param[type=table]   _NotGrowing Liste der nicht nachwachsenden Güter
-- @return[type=table]              Neues Wetterevent
-- @within WeatherEvent
--
-- @see API.WeatherEventRegister
-- @see API.WeatherEventRegisterLoop
--
-- @usage -- Erzeugt ein Winterevent
-- MyEvent = API.WeatherEventCreate(
--     "ne_winter_sequence.xml", false, true, true, false, -15,
--     {Goods.G_Grain, Goods.G_RawFish, Goods.G_Honeycomb}
-- )
--
function API.WeatherEventCreate(_GFX, _Rain, _Snow, _Ice, _Monsoon, _Temp, _NotGrowing)
    if GUI then
        return;
    end
    
    local Event = WeatherEvent:New();
    Event.GFX = _GFX or Event.GFX;
    Event.Rain = _Rain or Event.Rain;
    Event.Snow = _Snow or Event.Snow;
    Event.Ice = _Ice or Event.Ice;
    Event.Monsoon = _Monsoon or Event.Monsoon;
    Event.Temperature = _Temp or Event.Temperature;
    Event.NotGrowing = _NotGrowing or Event.NotGrowing;
    return Event;
end

---
-- Registiert ein Event für eine bestimmte Dauer. Das Event wird auf der
-- "Wartebank" eingereiht.
--
-- <b>Hinweis</b>: Ein wartendes Event wird gestartet, sobald kein anderes
-- Event mehr aktiv ist.
-- 
-- @param[type=table]  _Event     Event-Instanz
-- @param[type=number] _Duration  Name des Events
-- @within WeatherEvent
-- @see API.WeatherEventNext
-- @see API.WeatherEventAbort
-- @see API.WeatherEventRegisterLoop
--
-- @usage API.WeatherEventRegister(MyEvent, 300);
--
function API.WeatherEventRegister(_Event, _Duration)
    if GUI then
        return;
    end
    if type(_Event) ~= "table" or not _Event.GFX then
        log("API.WeatherEventStart: Invalid weather event!", LEVEL_ERROR);
        return;
    end
    BundleWeatherManipulation.Global:AddEvent(_Event, _Duration);
end

---
-- Registiert ein Event als Endlosschleife. Das Event wird immer wieder neu
-- starten, kurz bevor es eigentlich endet. Es darf keine anderen Events auf
-- der "Wartebank" geben.
-- @param[type=table]  _Event Event-Instanz
-- @within WeatherEvent
-- @see API.WeatherEventNext
-- @see API.WeatherEventAbort
-- @see API.WeatherEventRegister
--
-- @usage API.WeatherEventRegister(MyEvent);
--
function API.WeatherEventRegisterLoop(_Event)
    if GUI then
        return;
    end
    if type(_Event) ~= "table" or not _Event.GFX then
        log("API.WeatherEventStartLoop: Invalid weather event!", LEVEL_ERROR);
        return;
    end
    
    _Event.Loop = function(_Data)
        if _Data.Duration <= 36 then
            BundleWeatherManipulation.Global:AddEvent(_Event, _Data.Name, 120);
            BundleWeatherManipulation.Global:StopEvent();
            BundleWeatherManipulation.Global:ActivateEvent();
        end
    end
    BundleWeatherManipulation.Global:AddEvent(_Event, 120);
end

---
-- Startet das nächste Wetterevent auf der "Wartebank". Wenn bereits ein Event
-- aktiv ist, wird dieses gestoppt. Es erfolgt ein Übergang zum nächsten Event,
-- sofern möglich.
--
-- @within WeatherEvent
--
function API.WeatherEventNext()
    BundleWeatherManipulation.Global:StopEvent();
    BundleWeatherManipulation.Global:ActivateEvent();
end

---
-- Bricht das aktuelle Event inklusive der Animation sofort ab.
-- @within WeatherEvent
--
function API.WeatherEventAbort()
    if GUI then
        return;
    end
    Logic.ExecuteInLocalLuaState("Display.StopAllEnvironmentSettingsSequences()");
    BundleWeatherManipulation.Global:StopEvent();
end

---
-- Bricht das aktuelle Event ab und löscht alle eingereihten Events.
--
-- Mit dieser Funktion wird die komplette Warteschlange für Wettervents geleert.
-- Dies betrifft sowohl einzelne Events als auch sich wiederholende Events.
--
-- @within WeatherEvent
--
function API.WeatherEventPurge()
    if GUI then
        return;
    end
    BundleWeatherManipulation.Global:PurgeAllEvents();
    Logic.ExecuteInLocalLuaState("Display.StopAllEnvironmentSettingsSequences()");
    BundleWeatherManipulation.Global:StopEvent();
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleWeatherManipulation = {
    Global = {
        Data = {
            EventQueue = {},
            ActiveEvent = nil,
        },
    },
    Local = {
        Data = {
            ActiveEvent = nil,
        },
    },
}

-- Global Script ------------------------------------------------------------ --

---
-- Installiert das Bundle im globalen Skript.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:Install()
    API.AddSaveGameAction(self.OnSaveGameLoaded);
    StartSimpleJobEx(self.EventController);
end

---
-- Fügt ein Event zur Event Queue hinzu.
-- @param[type=table]  _Event    Wetterevent
-- @param[type=string] _Name     Name des Events
-- @param[type=string] _Duration Dauer des Ereignisses
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:AddEvent(_Event, _Duration)
    local Event = API.InstanceTable(_Event);
    Event.Duration = _Duration;
    table.insert(self.Data.EventQueue, Event);
end

---
-- Leer die Event Queue komplett.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:PurgeAllEvents()
    if #self.Data.EventQueue > 0 then
        for i= #self.Data.EventQueue, 1 -1 do
            self.Data.EventQueue:remove(i);
        end
    end
end

---
-- Startet das nächste Wetterevent in der Wetterwarteschlange, aber nur, wenn
-- kein Event aktiv ist.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:NextEvent()
    if not self:IsEventActive() then
        if #self.Data.EventQueue > 0 then
            self:ActivateEvent();
        end
    end
end

---
-- Startet das nächste Wetterevent in der Wetterwarteschlange.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:ActivateEvent()
    if #self.Data.EventQueue == 0 then
        return;
    end

    local Event = table.remove(self.Data.EventQueue, 1);
    self.Data.ActiveEvent = Event;
    Logic.ExecuteInLuaLocalState([[
        BundleWeatherManipulation.Local.Data.ActiveEvent = ]] ..API.ConvertTableToString(Event).. [[
        BundleWeatherManipulation.Local:DisplayEvent()
    ]]);

    Logic.WeatherEventClearGoodTypesNotGrowing();
    for i= 1, #Event.NotGrowing, 1 do
        Logic.WeatherEventAddGoodTypeNotGrowing(Event.NotGrowing[i]);
    end
    if Event.Rain then
        Logic.WeatherEventSetPrecipitationFalling(true);
        Logic.WeatherEventSetPrecipitationHeaviness(1);
        Logic.WeatherEventSetWaterRegenerationFactor(1);
        if Event.Snow then
            Logic.WeatherEventSetPrecipitationIsSnow(true);
        end
    end
    if Event.Ice then
        Logic.WeatherEventSetWaterFreezes(true);
    end
    if Event.Monsoon then
        Logic.WeatherEventSetShallowWaterFloods(true);
    end
    Logic.WeatherEventSetTemperature(Event.Temperature);
    Logic.ActivateWeatherEvent();
end

---
-- Stoppt das aktuelle Wettervent und die Wetteranimation.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:StopEvent()
    Logic.ExecuteInLuaLocalState("BundleWeatherManipulation.Local.Data.ActiveEvent = nil");
    BundleWeatherManipulation.Global.Data.ActiveEvent = nil;
    Logic.DeactivateWeatherEvent();
end

---
-- Gibt die verbleibende Dauer des aktuellen Wetterevnts zurück. Ist kein
-- Event aktiv, wird 0 zurückgegeben.
-- @return[type=number] Übrige Dauer des Events
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:GetEventRemainingTime()
    if not self:IsEventActive() then
        return 0;
    end
    return self.Data.ActiveEvent.Duration;
end

---
-- Prüft, ob ein Wetterevent aktiv ist.
-- @return[type=boolean] Event ist aktiv
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:IsEventActive()
    return self.Data.ActiveEvent ~= nil;
end

---
-- Startet nach dem Laden eines Spielstandes die Wetteranimation neu mit
-- der verbleibenden Zeit des Events.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global.OnSaveGameLoaded()
    if BundleWeatherManipulation.Global:IsEventActive() then
        Logic.ExecuteInLuaLocalState([[
            Display.StopAllEnvironmentSettingsSequences()
            BundleWeatherManipulation.Local:DisplayEvent(]] ..BundleWeatherManipulation.Global:GetEventRemainingTime().. [[)
        ]]);
    end
end

---
-- Steuert die Event Queue und startet das jeweils nächste Event.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global.EventController()
    if BundleWeatherManipulation.Global:IsEventActive() then
        BundleWeatherManipulation.Global.Data.ActiveEvent.Duration = BundleWeatherManipulation.Global.Data.ActiveEvent.Duration -1;
        if BundleWeatherManipulation.Global.Data.ActiveEvent.Loop then
            BundleWeatherManipulation.Global.Data.ActiveEvent:Loop();
        end
        
        if BundleWeatherManipulation.Global.Data.ActiveEvent.Duration == 0 then
            BundleWeatherManipulation.Global:StopEvent();
            BundleWeatherManipulation.Global:NextEvent();
        end
    end
end

-- Local Script ------------------------------------------------------------- --

---
-- Installiert das Bundle im globalen Skript.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Local:Install()
end

---
-- Startet die Wetteranimation mit der Duration des Events. Optional kann
-- eine andere Duration angegeben werden.
-- @param[type=number] Optionale Dauer der Animation
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Local:DisplayEvent(_Duration)
    if self:IsEventActive() then
        local SequenceID = Display.AddEnvironmentSettingsSequence(self.Data.ActiveEvent.GFX);
        Display.PlayEnvironmentSettingsSequence(SequenceID, _Duration or self.Data.ActiveEvent.Duration);
    end
end

---
-- Prüft, ob ein Wetterevent aktiv ist.
-- @return[type=boolean] Event ist aktiv
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Local:IsEventActive()
    return self.Data.ActiveEvent ~= nil;
end

--------------------------------------------------------------------------------

WeatherEvent = {
    GFX = "ne_winter_sequence.xml",
    NotGrowing = {},
    Rain = false,
    Snow = false,
    Ice = false,
    Monsoon = false,
    Temperature = 10,
}

---
-- Erstellt ein neues Wetterevent.
--
-- Ein Wetterevent ist standardmäßig eingestellt. Es gibt keinen Niederschlag,
-- und keinen Monsun, alle Güter wachsen, die Temperatur ist 10°C und als
-- GFX wird ne_winter_sequence.xml verwendet.
--
-- Um Werte anzupassen muss auf die Felder in einem neuen Wetterevent
-- zugegriffen werden. Ein Beispiel:
-- <pre>MyEvent.GFX = "as_winter_sequence.xml"</pre>
--
-- Um Güter, die nicht nachwachsen sollen, hinzuzufügen, muss auf das Table
-- NotGrowing zugegriffen werden. Ein Beispiel:
-- <pre>MyEvent.NotGrowing:insert(Goods.G_Grain)</pre>
--
-- Ein einmal erstelltes Event kann immer wieder verwendet werden! Speichere
-- es also in einer globalen Variable.
--
-- Ein Event hat folgende Felder:
-- <table border="1">
-- <tr>
-- <td><b>Feld</b></td>
-- <td><b>Erklärung</b></td>
-- </tr>
-- <tr>
-- <td>GFX</td>
-- <td>String: Die verwendete Display-Animation. Hierbei muss es sich im eine
-- dynamische Display-Animation handeln.</td>
-- </tr>
-- <tr>
-- <td>NotGrowing</td>
-- <td>Table: Liste aller nicht nachwachsender Güter während des Events.</td>
-- </tr>
-- <tr>
-- <td>Rain</td>
-- <td>Boolean: Niederschlag fällt während des Events.</td>
-- </tr>
-- <tr>
-- <td>Snow</td>
-- <td>Boolean: Der Niederschlag fällt als Schnee.</td>
-- </tr>
-- <tr>
-- <td>Ice</td>
-- <td>Boolean: Wasser gefriert während des Events.</td>
-- </tr>
-- <tr>
-- <td>Monsoon</td>
-- <td>Boolean: Monsunwasser ist während des Events aktiv.</td>
-- </tr>
-- <tr>
-- <td>Temperature</td>
-- <td>Number: Die Temperatur während des Events in °C.</td>
-- </tr>
-- </table>
--
-- @within WeatherEvent
-- @local
-- @usage MyEvent = WeatherEvent:New();
--
function WeatherEvent:New()
    return API.InstanceTable(self);
end

--------------------------------------------------------------------------------

Core:RegisterBundle("BundleWeatherManipulation");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnQuestDebug                                              # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Erweitert den mitgelieferten Debug des Spiels um eine Vielzahl nützlicher
-- neuer Möglichkeiten.
--
-- Die wichtigste Neuerung ist die Konsole, die es erlaubt Quests direkt über
-- die Eingabe von Befehlen zu steuern, einzelne Lua-Funktionen im Spiel
-- auszuführen und sogar komplette Skripte zu laden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnQuestDebug = {};

API = API or {};
QSB = QSB or {};

AddOnQuestDebug = {
    Global =  {
        Data = {},
    },
    Local = {
        Data = {},
    },
}

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert den Debug.
--
-- Der Developing Mode bietet viele Hotkeys und eine Konsole. Die Konsole ist
-- ein mächtiges Werkzeug. Es ist möglich tief in das Spiel einzugreifen und
-- sogar Funktionen während des Spiels zu überschreiben.
--
-- Die Konsole kann über <b>SHIFT + ^</b> geöffnet werden.
--
-- <p><b>Alias:</b> ActivateDebugMode</p>
--
-- <h3>Cheats</h3>
-- <table border="1">
-- <tr>
-- <td><b>Cheat</b></td>
-- <td><b>Beschreibung</b></td>
-- </tr>
-- <tr>
-- <td>SHIFT + ^</td>
-- <td>Konsole öffnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + C</td>
-- <td>Zeitanzeige an/aus</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + F</td>
-- <td>Nebel des Krieges abschalten</td>
-- </tr>
-- <tr>
-- <td>STRG + G</td>
-- <td>GUI ausschalten</td>
-- </tr>
-- <tr>
-- <td>ALT + F10</td>
-- <td>Selektiertes Gebäude anzünden</td>
-- </tr>
-- <tr>
-- <td>ALT + F11</td>
-- <td>Selektierte Einheit verwunden</td>
-- </tr>
-- <tr>
-- <td>ALT + F12</td>
-- <td>Alle Rechte freigeben / wieder sperren</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + 1</td>
-- <td>FPS-Anzeige</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 4</td>
-- <td>Bogenschützen unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 5</td>
-- <td>Schwertkämpfer unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 6</td>
-- <td>Katapultkarren unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 7</td>
-- <td>Ramme unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 8</td>
-- <td>Belagerungsturm unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 9</td>
-- <td>Katapult unter der Maus spawnen</td>
-- </tr>
-- <tr>
-- <td>(Num) +</td>
-- <td>Spiel beschleunigen</td>
-- </tr>
-- <tr>
-- <td>(Num) -</td>
-- <td>Spiel verlangsamen</td>
-- </tr>
-- <tr>
-- <td>(Num) *</td>
-- <td>Geschwindigkeit zurücksetzen</td>
-- </tr>
-- <tr>
-- <td>CTRL + F1</td>
-- <td>+ 50 Gold</td>
-- </tr>
-- <tr>
-- <td>CTRL + F2</td>
-- <td>+ 10 Holz</td>
-- </tr>
-- <tr>
-- <td>CTRL + F3</td>
-- <td>+ 10 Stein</td>
-- </tr>
-- <tr>
-- <td>CTRL + F4</td>
-- <td>+ 10 Getreide</td>
-- </tr>
-- <tr>
-- <td>CTRL + F5</td>
-- <td>+ 10 Milch</td>
-- </tr>
-- <tr>
-- <td>CTRL + F6</td>
-- <td>+ 10 Kräuter</td>
-- </tr>
-- <tr>
-- <td>CTRL + F7</td>
-- <td>+ 10 Wolle</td>
-- </tr>
-- <tr>
-- <td>CTRL + F8</td>
-- <td>+ 10 auf alle Waren</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F1</td>
-- <td>+ 10 Honig</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F2</td>
-- <td>+ 10 Eisen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F3</td>
-- <td>+ 10 Fisch</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F4</td>
-- <td>+ 10 Wild</td>
-- </tr>
-- <tr>
-- <td>CTRL + F9</td>
-- <td>Nahrung für selektiertes Gebäude erhöhen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F9</td>
-- <td>Nahrung für selektiertes Gebäude verringern</td>
-- </tr>
-- <tr>
-- <td>CTRL + F10</td>
-- <td>Kleidung für selektiertes Gebäude erhöhen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F10</td>
-- <td>Kleidung für selektiertes Gebäude verringern</td>
-- </tr>
-- <tr>
-- <td>CTRL + F11</td>
-- <td>Hygiene für selektiertes Gebäude erhöhen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F11</td>
-- <td>Hygiene für selektiertes Gebäude verringern</td>
-- </tr>
-- <tr>
-- <td>CTRL + F12</td>
-- <td>Unterhaltung für selektiertes Gebäude erhöhen</td>
-- </tr>
-- <tr>
-- <td>SHIFT + F12</td>
-- <td>Unterhaltung für selektiertes Gebäude verringern</td>
-- </tr>
-- <tr>
-- <td>ALT + CTRL + F10</td>
-- <td>Einnahmen des selektierten Gebäudes erhöhen</td>
-- </tr>
-- <tr>
-- <td>ALT + (Num) 1</td>
-- <td>Burg selektiert → Gold verringern, Werkstatt selektiert → Ware verringern</td>
-- </tr>
-- <tr>
-- <td>ALT + (Num) 2</td>
-- <td>Burg selektiert → Gold erhöhen, Werkstatt selektiert → Ware erhöhen</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 1</td>
-- <td>Kontrolle über Spieler 1</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 2</td>
-- <td>Kontrolle über Spieler 2</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 3</td>
-- <td>Kontrolle über Spieler 3</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 4</td>
-- <td>Kontrolle über Spieler 4</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 5</td>
-- <td>Kontrolle über Spieler 5</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 6</td>
-- <td>Kontrolle über Spieler 6</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 7</td>
-- <td>Kontrolle über Spieler 7</td>
-- </tr>
-- <tr>
-- <td>CTRL + ALT + 8</td>
-- <td>Kontrolle über Spieler 8</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 0</td>
-- <td>Kamera durchschalten</td>
-- </tr>
-- <tr>
-- <td>CTRL + (Num) 1</td>
-- <td>Kamerasprünge im RTS-Mode</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + V</td>
-- <td>Territorien anzeigen</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + B</td>
-- <td>Blocking anzeigen</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + N</td>
-- <td>Gitter verstecken</td>
-- </tr>
-- <tr>
-- <td>CTRL + SHIFT + F9</td>
-- <td>DEBUG-Ausgabe einschalten</td>
-- </tr>
-- <tr>
-- <td>ALT + F9</td>
-- <td>Zufälligen Arbeiter verheiraten</td>
-- </tr>
-- </table>
--
-- <h3>Konsolenbefehle</h3>
-- <table border=1>
-- <tr>
-- <th><b>Befehl</b></th>
-- <th><b>Parameter</b></th>
-- <th><b>Beschreibung</b></th>
-- </tr>
-- <tr>
-- <td>clear</td>
-- <td></td>
-- <td>Entfernt alle Textnachrichten im Debug-Window.</td>
-- </tr>
-- <tr>
-- <td>diplomacy</td>
-- <td>PlayerID1, PlayerID2, Diplomacy</td>
-- <td>Ändert die Doplomatischen Beziehungen zwischen zwei Parteien</td>
-- </tr>
-- <tr>
-- <td>restartmap</td>
-- <td></td>
-- <td>Startet die Map sofort neu.</td>
-- </tr>
-- <tr>
-- <td>reveal</td>
-- <td>PlayerID1, PlayerID2</td>
-- <td>Teilt die Sicht zweier Spieler.</td>
-- </tr>
-- <tr>
-- <td>conceal</td>
-- <td>PlayerID1, PlayerID2</td>
-- <td>Hebt die geteilte Sicht wieder auf.</td>
-- </tr>
-- <tr>
-- <td>setposition</td>
-- <td>Entity, Target</td>
-- <td>Versetzt ein Entity zu einer neuen Position.</td>
-- </tr>
-- <tr>
-- <td>version</td>
-- <td></td>
-- <td>Zeigt die Version der QSB an.</td>
-- </tr>
-- <tr>
-- <td>stop</td>
-- <td>QuestName</td>
-- <td>Unterbricht den angegebenen Quest.</td>
-- </tr>
-- <tr>
-- <td>start</td>
-- <td>QuestName</td>
-- <td>Startet den angegebenen Quest.</td>
-- </tr>
-- <tr>
-- <td>win</td>
-- <td>QuestName</td>
-- <td>Schließt den angegebenen Quest erfolgreich ab.</td>
-- </tr>
-- <tr>
-- <td>fail</td>
-- <td>QuestName</td>
-- <td>Lässt den angegebenen Quest fehlschlagen</td>
-- </tr>
-- <tr>
-- <td>restart</td>
-- <td>QuestName</td>
-- <td>Startet den angegebenen Quest neu.</td>
-- </tr>
-- <tr>
-- <td>stopped</td>
-- <td>Pattern</td>
-- <td>Gibt die Namen abgebrochener Quests zurück.</td>
-- </tr>
-- <tr>
-- <td>active</td>
-- <td>Pattern</td>
-- <td>Gibt die Namen aktiver Quests zurück.</td>
-- </tr>
-- <tr>
-- <td>won</td>
-- <td>Pattern</td>
-- <td>Gibt die Namen gewonnener Quests zurück.</td>
-- </tr>
-- <tr>
-- <td>failed</td>
-- <td>Pattern</td>
-- <td>Gibt die Namen fehlgeschlagener Quests zurück.</td>
-- </tr>
-- <tr>
-- <td>waiting</td>
-- <td>Pattern</td>
-- <td>Gibt die Namen nicht ausgelöster Quests zurück.</td>
-- </tr>
-- <tr>
-- <td>find</td>
-- <td>Pattern</td>
-- <td>Gibt die Namen von Quests mit ähnlichen Namen zurück.</td>
-- </tr>
-- <tr>
-- <td><</td>
-- <td>Path</td>
-- <td>Läd ein Skript zur Laufzeit ins globale Skript.</td>
-- </tr>
-- <tr>
-- <td><<</td>
-- <td>Path</td>
-- <td>Läd ein Skript zur Laufzeit ins lokale Skript.</td>
-- </tr>
-- <tr>
-- <td>></td>
-- <td>Command</td>
-- <td>Führt die Eingabe als Lua-Befahl im globalen Skript aus.</td>
-- </tr>
-- <tr>
-- <td>>></td>
-- <td>Command</td>
-- <td>Führt die Eingabe als Lua-Befahl im lokalen Skript aus.</td>
-- </tr>
-- </table>
--
-- @param[type=boolean] _CheckAtRun Prüfe Quests zur Laufzeit
-- @param[type=boolean] _TraceQuests Aktiviert Questverfolgung
-- @param[type=boolean] _DevelopingCheats Aktiviert Cheats
-- @param[type=boolean] _DevelopingShell Aktiviert Eingabe
-- @see Reward_DEBUG
-- @within Anwenderfunktionen
--
function API.ActivateDebugMode(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell)
    if GUI then
        return;
    end
    AddOnQuestDebug.Global:ActivateDebug(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell);
end
ActivateDebugMode = API.ActivateDebugMode;

---
-- Überspringt einen Quest.
--
-- Wird ein Quest übersprungen, wird er unterbrochen und nachträglich auf
-- erfolgreich gesetzt. Falls vorhanden, wird die Skip-Funktion aufgerufen.
-- Die Start- und Endnachricht wird deaktiviert.
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _NoMessage Nachricht nicht anzeigen
-- @within Anwenderfunktionen
-- @see API.SkipMultipleQuest
--
-- @usage API.SkipSingleQuest("MeinQuest", true)
--
function API.SkipSingleQuest(_QuestName, _NoMessage)
    if GUI then
        return;
    end
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest and Quest.Stage ~= QuestState.Over then
        AddOnQuestDebug.Global:MuteQuest(_QuestName);
        API.StopQuest(_QuestName, _NoMessage);
        Quest.Result = QuestResult.Over;
        if BundleClassicBehaviors then
            BundleClassicBehaviors.Global:OnQuestSkipped(Quest);
        end
        if AddOnRandomRequests then
            AddOnRandomRequests.Global:OnQuestSkipped(Quest);
        end
        if AddOnQuestStages then
            AddOnQuestStages.Global:OnQuestSkipped(Quest)
        end
        if Quest.SkipFunction then
            Quest:SkipFunction();
        end
        if not _NoMessage then
            API.Note("skipped quest " .._QuestName);
        end
        return;
    end
    error("API.SkipSingleQuest: Quest " .._QuestName.. " not found!");
end
SkipSingleQuest = API.SkipSingleQuest;

---
-- Überspringt alle Quests in der Liste in der angegebenen Reihenfolge.
--
-- @param[type=string] ... Liste mit Questnames
-- @within Anwenderfunktionen
-- @see API.SkipSingleQuest
--
-- @usage API.SkipMultipleQuest("MeinQuest1", "MeinQuest2", "MeinQuest3", false)
--
function API.SkipMultipleQuest(...)
    local QuestsToSkip = {};
    local NoMessage = false;
    for i=1, #arg, 1 do
        if type(arg[i]) == "string" then
            table.insert(QuestsToSkip, arg[i]);
        else
            NoMessage = arg[i] == true;
        end
    end
    for i=1, #QuestsToSkip, 1 do
        API.SkipSingleQuest(QuestsToSkip[i], NoMessage);
    end
end
SkipMultipleQuest = API.SkipMultipleQuest;

-- -------------------------------------------------------------------------- --
-- Rewards                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert den Debug.
--
-- @param[type=boolean] _CheckAtRun Prüfe Quests zur Laufzeit
-- @param[type=boolean] _TraceQuests Aktiviert Questverfolgung
-- @param[type=boolean] _DevelopingCheats Aktiviert Cheats
-- @param[type=boolean] _DevelopingShell Aktiviert Eingabe
-- @see API.ActivateDebugMode
--
-- @within Reward
--
function Reward_DEBUG(...)
    return b_Reward_DEBUG:new(...);
end

b_Reward_DEBUG = {
    Name = "Reward_DEBUG",
    Description = {
        en = "Reward: Start the debug mode. See documentation for more information.",
        de = "Lohn: Startet den Debug-Modus. Für mehr Informationen siehe Dokumentation.",
    },
    Parameter = {
        { ParameterType.Custom,     en = "Check quest while runtime", de = "Quests zur Laufzeit prüfen" },
        { ParameterType.Custom,     en = "Use quest trace", de = "Questverfolgung" },
        { ParameterType.Custom,     en = "Activate developing cheats", de = "Cheats aktivieren" },
        { ParameterType.Custom,     en = "Activate developing shell", de = "Eingabe aktivieren" },
    },
}

function b_Reward_DEBUG:GetRewardTable(__quest_)
    return { Reward.Custom, {self, self.CustomFunction} }
end

function b_Reward_DEBUG:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.CheckWhileRuntime = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 1) then
        self.UseQuestTrace = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 2) then
        self.DevelopingCheats = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 3) then
        self.DevelopingShell = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_DEBUG:CustomFunction(__quest_)
    API.ActivateDebugMode(self.CheckWhileRuntime, self.UseQuestTrace, self.DevelopingCheats, self.DevelopingShell);
end

function b_Reward_DEBUG:GetCustomData(_Index)
    return {"true","false"};
end

Core:RegisterBehavior(b_Reward_DEBUG);

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:Install()
    self.Data.DebugCommands = {
        -- groupless commands
        {"clear",       self.Clear,},
        {"diplomacy",   self.Diplomacy,},
        {"restartmap",  self.RestartMap,},
        {"reveal",      self.ShareView,                1},
        {"conceal",     self.ShareView,                0},
        {"setposition", self.SetPosition,},
        {"version",     self.ShowVersion,},
        -- quest control
        {"win",         self.SetQuestState,            1},
        {"fail",        self.SetQuestState,            2},
        {"stop",        self.SetQuestState,            3},
        {"start",       self.SetQuestState,            4},
        {"restart",     self.SetQuestState,            5},
        {"skip",        self.SetQuestState,            6},
        {"won",         self.FindQuestsByState,        1},
        {"failed",      self.FindQuestsByState,        2},
        {"stoped",      self.FindQuestsByState,        3},
        {"active",      self.FindQuestsByState,        4},
        {"waiting",     self.FindQuestsByState,        5},
        {"find",        self.FindQuestsByState,        6},
        -- loading scripts into running game and execute them
        {"<<",          self.LoadScript,               true},
        {"<",           self.LoadScript,               false},
        -- execute short lua commands
        {">>",          self.ExecuteLuaCommand,        true},
        {">",           self.ExecuteLuaCommand,        false},
        -- old shit -> "inoffical commands"
        {"shareview",   self.ShareView,                -1},
        {"printequal",  self.FindQuestsByState,        6},
        {"printactive", self.FindQuestsByState,        4},
        {"lexec",       self.ExecuteLuaCommand,        true},
        {"gexec",       self.ExecuteLuaCommand,        false},
        {"lload",       self.LoadScript,               true},
        {"gload",       self.LoadScript,               false},
    }

    for k,v in pairs(_G) do
        if type(v) == "table" and v.Name and k == "b_"..v.Name and v.CustomFunction and not v.CustomFunction2 then
            v.CustomFunction2 = v.CustomFunction;
            v.CustomFunction = function(self, __quest_)
                if AddOnQuestDebug.Global.Data.CheckAtRun then
                    if self.DEBUG and not self.FOUND_ERROR and self:Debug(__quest_) then
                        self.FOUND_ERROR = true;
                    end
                end
                if not self.FOUND_ERROR then
                    return self:CustomFunction2(__quest_);
                end
            end
        end
    end

    self:OverwriteCreateQuests();

    API.AddSaveGameAction(self.OnSaveGameLoad);
end

---
-- Aktiviert den Debug.
--
-- Der Developing Mode bietet viele Hotkeys und eine Konsole. Die Konsole ist
-- ein mächtiges Werkzeug. Es ist möglich tief in das Spiel einzugreifen und
-- sogar Funktionen während des Spiels zu überschreiben.
--
-- @param _CheckAtRun [boolean] Prüfe Quests zur Laufzeit
-- @param _TraceQuests [boolean] Aktiviert Questverfolgung
-- @param _Cheats [boolean] Aktiviert Cheats
-- @param _Shell [boolean] Aktiviert Konsole
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:ActivateDebug(_CheckAtRun, _TraceQuests, _Cheats, _Shell)
    if self.Data.DebugModeIsActive then
        return;
    end
    self.Data.DebugModeIsActive = true;

    self.Data.CheckAtRun       = _CheckAtRun == true;
    self.Data.TraceQuests      = _TraceQuests == true;
    self.Data.DevelopingCheats = _Cheats == true;
    self.Data.DevelopingShell  = _Shell == true;

    self:ActivateQuestTrace();
    self:ActivateDevelopingCheats();
    self:ActivateDevelopingShell();
end

---
-- Deaktiviert sämtlichen Output eines Quest.
--
-- Die Werte für Visible, ShowEndMessage, QuestStartMsg, QuestSuccessMsg und
-- QuestFailureMsg werden in einem Backup gesichert und dann überschrieben,
-- damit der Quest keine Meldungen mehr erzeugt.
--
-- Setzt man einen Quest zurück, werden die Werte wiederhergestellt. Handelt
-- es sich um einen Staged Quest, wird auch deren Output gleich behandelt.
--
-- @param[type=string] _QuestName Identifier des Quest
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:MuteQuest(_QuestName)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest then
        if Quest.Visible_OrigDebug == nil then
            Quest.Visible_OrigDebug = Quest.Visible;
            Quest.Visible = false;
        end
        if Quest.ShowEndMessage_OrigDebug == nil then
            Quest.ShowEndMessage_OrigDebug = Quest.ShowEndMessage;
            Quest.ShowEndMessage = false;
        end
        if Quest.QuestStartMsg_OrigDebug == nil then
            Quest.QuestStartMsg_OrigDebug = Quest.QuestStartMsg;
            Quest.QuestStartMsg = "KEY(NO_MESSAGE)";
        end
        if Quest.QuestSuccessMsg_OrigDebug == nil then
            Quest.QuestSuccessMsg_OrigDebug = Quest.QuestSuccessMsg;
            Quest.QuestSuccessMsg = "KEY(NO_MESSAGE)";
        end
        if Quest.QuestFailureMsg_OrigDebug == nil then
            Quest.QuestFailureMsg_OrigDebug = Quest.QuestFailureMsg;
            Quest.QuestFailureMsg = "KEY(NO_MESSAGE)";
        end
        if AddOnQuestStages then
            if AddOnQuestStages.Global.Data.StagesForQuest[_QuestName] then
                for k,v in pairs(AddOnQuestStages.Global.Data.StagesForQuest[_QuestName]) do
                    self:MuteQuest(v);
                end
            end
        end
    end
end

---
-- Aktiviert die Questverfolgung. Jede Statusänderung wird am Bildschirm
-- angezeigt.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:ActivateQuestTrace()
    if self.Data.TraceQuests then
        DEBUG_EnableQuestDebugKeys();
        DEBUG_QuestTrace(true);
    end
end

---
-- <p>Aktiviert die Cheats.</p>
-- <p>Es werden die Development-Cheats benutzt und um einige neue erweitert.</p>
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:ActivateDevelopingCheats()
    if self.Data.DevelopingCheats then
        Logic.ExecuteInLuaLocalState([[
            if not AddOnQuestDebug then
                StartSimpleJobEx(function()
                    if AddOnQuestDebug then
                        AddOnQuestDebug.Local:ActivateDevelopingCheats();
                        return true;
                    end
                end);
            else
                AddOnQuestDebug.Local:ActivateDevelopingCheats();
            end
        ]]);
    end
end

---
-- <p>Aktiviert die Shell.</p>
-- <p>Der Debug stellt einige zusätzliche Tastenkombinationen bereit:</p>
-- <p>Die Konsole des Debug wird mit SHIFT + ^ geöffnet.</p>
-- <p>Die Konsole bietet folgende Kommandos:</p>
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:ActivateDevelopingShell()
    if self.Data.DevelopingShell then
        Logic.ExecuteInLuaLocalState([[
            if not AddOnQuestDebug then
                StartSimpleJobEx(function()
                    if AddOnQuestDebug then
                        AddOnQuestDebug.Local:ActivateDevelopingShell();
                        return true;
                    end
                end);
            else
                AddOnQuestDebug.Local:ActivateDevelopingShell();
            end
        ]]);
    end
end

---
-- Ließt eingegebene Kommandos und führt entsprechende Funktionen aus.
--
-- Für die Zerlegung der Kommandizeile wird der Tokenizer benutzt.
--
-- Kommandos können auch im Skript oder im Lua Debugger genutzt werden. Dafür
-- muss eval() mit dem Befehl als Argument aufgerufen werden.
--
-- @within Internal
-- @local
-- @see AddOnQuestDebug.Global:Tokenize
--
function AddOnQuestDebug.Global:Parser(_Input)
    local Results = {};
    local Commands = self:Tokenize(_Input);
    for k, v in pairs(Commands) do
        local Action = string.lower(v[1]);
        for i= 1, #self.Data.DebugCommands, 1 do
            if v[1] == self.Data.DebugCommands[i][1] then
                local SelectedCommand = self.Data.DebugCommands[i];
                for j=2, #v, 1 do
                    local Number = tonumber(v[j]);
                    if Number then
                        v[j] = Number;
                    end
                end

                local CommandResult = SelectedCommand[2](v, SelectedCommand[3]);
                if CommandResult then
                    table.insert(Results, CommandResult);
                end
            end
        end
    end
    return Results;
end
function eval(_Input)
    return AddOnQuestDebug.Global:Parser(_Input);
end

---
-- Zerlegt den Eingabestring in einzelne Kommandos und gibt diese als Table
-- zurück. Unterschiedliche Kommandos werden mit && abgetrennt und entsprechend
-- als mehrere Einträge im Table angelegt. Mit dem Wiederholungszeichen &
-- wird das Komanndo für alle angegebenen Eingaben wiederholt.
--
-- Beispiel:
--
-- <pre>
-- Eingabe:
-- "win QuestA & QuestB && fail QuestC && stop QuestD & Quest E"
--
-- Ausgabe:
-- {
-- {"win", "QuestA"}
-- {"win", "QuestB"}
-- {"fail", "QuestC"}
-- {"stop", "QuestD"}
-- {"stop", "QuestE"}
-- }</pre>
--
-- @return Table mit Tokens
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:Tokenize(_Input)
    local Commands = {};
    local DAmberCommands = {_Input};
    local AmberCommands = {};

    -- parse & delimiter
    local s, e = string.find(_Input, "%s+&&%s+");
    if s then
        DAmberCommands = {};
        while (s) do
            local tmp = string.sub(_Input, 1, s-1);
            table.insert(DAmberCommands, tmp);
            _Input = string.sub(_Input, e+1);
            s, e = string.find(_Input, "%s+&&%s+");
        end
        if string.len(_Input) > 0 then 
            table.insert(DAmberCommands, _Input);
        end
    end

    -- parse & delimiter
    for i= 1, #DAmberCommands, 1 do
        local s, e = string.find(DAmberCommands[i], "%s+&%s+");
        if s then
            local LastCommand = "";
            while (s) do
                local tmp = string.sub(DAmberCommands[i], 1, s-1);
                table.insert(AmberCommands, LastCommand .. tmp);
                if string.find(tmp, " ") then
                    LastCommand = string.sub(tmp, 1, string.find(tmp, " ")-1) .. " ";
                end
                DAmberCommands[i] = string.sub(DAmberCommands[i], e+1);
                s, e = string.find(DAmberCommands[i], "%s+&%s+");
            end
            if string.len(DAmberCommands[i]) > 0 then 
                table.insert(AmberCommands, LastCommand .. DAmberCommands[i]);
            end
        else
            table.insert(AmberCommands, DAmberCommands[i]);
        end
    end

    -- parse spaces
    for i= 1, #AmberCommands, 1 do
        local CommandLine = {};
        local s, e = string.find(AmberCommands[i], "%s+");
        if s then
            while (s) do
                local tmp = string.sub(AmberCommands[i], 1, s-1);
                table.insert(CommandLine, tmp);
                AmberCommands[i] = string.sub(AmberCommands[i], e+1);
                s, e = string.find(AmberCommands[i], "%s+");
            end
            table.insert(CommandLine, AmberCommands[i]);
        else
            table.insert(CommandLine, AmberCommands[i]);
        end
        table.insert(Commands, CommandLine);
    end

    return Commands;
end

---
-- Läd ein Lua-Skript in das Enviorment.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.LoadScript(_Arguments, _Flags)
    if _Arguments[2] then
        if _Flags == true then
            Logic.ExecuteInLuaLocalState([[Script.Load("]].._Arguments[2]..[[")]]);
        elseif _Flags == false then
            Script.Load(_Arguments[2]);
        end
        API.Note("load script ".._Arguments[2]);
    end
end

---
-- Ruft eine Funktion (optional mit Parametern) im Enviorment auf.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.ExecuteCommand(_Arguments, _Flags)
    if _Arguments[2] then
        local args = "";
        for i=3,#_Arguments do
            args = args .. ((i>3 and ",") or "");
            args = args .. " " .. _Arguments[i];
        end

        if _Flags == true then
            Logic.ExecuteInLuaLocalState([[]].. _Arguments[2] .. [[(]] ..args..[[)]]);
        elseif _Flags == false then
            Logic.ExecuteInLuaLocalState([[GUI.SendScriptCommand("]].. _Arguments[2] .. [[(]]..args..[[)")]]);
        end
    end
end

---
-- Führt ein Lua-Command innerhalb des Strings aus.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.ExecuteLuaCommand(_Arguments, _Flags)
    if _Arguments[2] then
        local args = "";
        for i=2,#_Arguments do
            args = args .. " " .. _Arguments[i];
        end

        if _Flags == true then
            Logic.ExecuteInLuaLocalState([[]]..args..[[]]);
        elseif _Flags == false then
            Logic.ExecuteInLuaLocalState([[GUI.SendScriptCommand("]]..args..[[")]]);
        end
    end
end

---
-- Konsolenbefehl: Leert das Debug Window.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.Clear()
    Logic.ExecuteInLuaLocalState("GUI.ClearNotes()");
end

---
-- Konsolenbefehl: Ändert die Diplomatie zwischen zwei Spielern.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.Diplomacy(_Arguments)
    SetDiplomacyState(_Arguments[2], _Arguments[3], _Arguments[4]);
end

---
--  Konsolenbefehl: Startet die Map umgehend neu.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.RestartMap()
    Logic.ExecuteInLuaLocalState("Framework.RestartMap()");
end

---
-- Konsolenbefehl: Aktiviert/deaktiviert die geteilte Sicht zweier Spieler.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.ShareView(_Arguments, _Flag)
    if _Flag == -1 then
        Logic.SetShareExplorationWithPlayerFlag(_Arguments[2], _Arguments[3], _Arguments[4]);
    end
    Logic.SetShareExplorationWithPlayerFlag(_Arguments[2], _Arguments[3], _Flag);
end

---
-- Konsolenbefehl: Setzt die Position eines Entity.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.SetPosition(_Arguments)
    local entity = GetID(_Arguments[2]);
    local target = GetID(_Arguments[3]);
    local x,y,z  = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x,y = Logic.GetBuildingApproachPosition(target);
    end
    Logic.DEBUG_SetSettlerPosition(entity, x, y);
    if Logic.IsLeader(entity) == 1 then
        local Soldiers = {Logic.GetSoldiersAttachedToLeader(entity)};
        for i= 1, #Soldiers, 1 do
            if isExisting(Soldiers[i]) then
                Logic.DEBUG_SetSettlerPosition(Soldiers[i], x, y);
            end
        end
    end
end

---
-- Konsolenbefehl: Zeigt die Version der QSB an.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.ShowVersion()
    Logic.ExecuteInLuaLocalState("GUI.ClearNotes(); GUI.AddStaticNote(QSB.Version)");
    return QSB.Version;
end

---
-- Konsolenbefehl: Sucht nach allen Quests, auf die den angegebenen Namen
-- enthalten und gibt die Namen der gefundenen Quests zurück.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.FindQuestNames(_Pattern, _ExactName)
    local FoundQuests = FindQuestsByName(_Pattern, _ExactName);
    if #FoundQuests == 0 then
        return {};
    end
    local NamesOfFoundQuests = {};
    for i= 1, #FoundQuests, 1 do
        table.insert(NamesOfFoundQuests, FoundQuests[i].Identifier);
    end
    return NamesOfFoundQuests;
end

---
-- Konsolenbefehl: Gibt die Namen aller Quests mit dem Status zurück. Die
-- Suche kann mit einem Pattern eingeschränkt werden. Es werden maximal 12
-- Quests angezeigt.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.FindQuestsByState(_Data, _Flag)
    local QuestsOfState = {};
    for i= 1, Quests[0], 1 do
        if _Flag == 1 and Quests[i].Result == QuestResult.Success then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 2 and Quests[i].Result == QuestResult.Failure then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 3 and Quests[i].Result == QuestResult.Interrupted then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 4 and Quests[i].State == QuestState.Active then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 5 and Quests[i].State == QuestState.NotTriggered then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 6 and ((_Data[2] and string.find(Quests[i].Identifier, _Data[2])) or not _Data[2]) then
            table.insert(QuestsOfState, Quests[i]);
        end
    end

    local QuestNames = "";
    local Matching = 0;
    for i= 1, #QuestsOfState, 1 do
        if Matching < 15 then
            if _Data[2] then
                if string.find(QuestsOfState[i].Identifier, _Data[2]) then
                    QuestNames = QuestNames .. "- " .. QuestsOfState[i].Identifier .. "{cr}";
                    Matching = Matching +1;
                end
            else
                QuestNames = QuestNames .. "- " .. QuestsOfState[i].Identifier .. "{cr}";
                Matching = Matching +1;
            end
        else
            QuestNames = QuestNames .. "... (" .. (#QuestsOfState-Matching) .. " more)";
            break;
        end
    end

    Logic.ExecuteInLuaLocalState([[
        GUI.ClearNotes()
        GUI.AddStaticNote("Found quests:{cr}]]..QuestNames..[[")
    ]]);
    return "Found quests:{cr}"..QuestNames;
end

---
-- Konsolenbefehl: Setzt den Status eines Quests. Mit der Statusänderung wird
-- ggf. Fortschrit zurückgesetzt.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.SetQuestState(_Data, _Flag)
    local FoundQuests = AddOnQuestDebug.Global.FindQuestNames(_Data[2], true);
    if #FoundQuests ~= 1 then
        API.Note("Unable to find quest containing '" .._Data[2].. "'");
        return "Unable to find quest containing '" .._Data[2].. "'";
    end
    if _Flag == 1 then
        API.WinQuest(FoundQuests[1], true);
        API.Note("win quest '" ..FoundQuests[1].. "'");
        return "win quest '" ..FoundQuests[1].. "'"
    elseif _Flag == 2 then
        API.FailQuest(FoundQuests[1], true);
        API.Note("fail quest '" ..FoundQuests[1].. "'");
        return "fail quest '" ..FoundQuests[1].. "'"
    elseif _Flag == 3 then
        API.StopQuest(FoundQuests[1], true);
        API.Note("interrupt quest '" ..FoundQuests[1].. "'");
        return "interrupt quest '" ..FoundQuests[1].. "'";
    elseif _Flag == 4 then
        API.StartQuest(FoundQuests[1], true);
        API.Note("trigger quest '" ..FoundQuests[1].. "'");
        return "trigger quest '" ..FoundQuests[1].. "'";
    elseif _Flag == 5 then
        API.RestartQuest(FoundQuests[1], true);
        API.Note("restart quest '" ..FoundQuests[1].. "'");
        return "restart quest '" ..FoundQuests[1].. "'";
    else
        API.SkipSingleQuest(FoundQuests[1], true);
        API.Note("skip quest '" ..FoundQuests[1].. "'");
        return "skip quest '" ..FoundQuests[1].. "'";
    end
end

---
-- Überschreibt CreateQuests, sodass Assistentenquests über das Skript erzeugt
-- werden um diese sinnvoll überprüfen zu können.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.OverwriteCreateQuests()
    AddOnQuestDebug.Global.Data.CreateQuestsOriginal = CreateQuests;
    CreateQuests = function()
        local QuestNames = Logic.Quest_GetQuestNames()
        for i=1, #QuestNames, 1 do
            local QuestName = QuestNames[i]
            local QuestData = {Logic.Quest_GetQuestParamter(QuestName)};

            -- Behavior ermitteln
            local Behaviors = {};
            local Amount = Logic.Quest_GetQuestNumberOfBehaviors(QuestName);
            if Amount > 0 then
                for j=0, Amount-1, 1 do
                    local Name = Logic.Quest_GetQuestBehaviorName(QuestName, j);
                    local Template = GetBehaviorTemplateByName(Name);
                    assert(Template ~= nil);

                    local Parameters = Logic.Quest_GetQuestBehaviorParameter(QuestName, j);
                    table.insert(Behaviors, Template:new(unpack(Parameters)));
                end

                local SuggestionText;
                if (QuestData[6] and QuestData[6] ~= "" and QuestData[6] ~= "KEY(NO_MESSAGE)") then
                    SuggestionText = QuestData[6];
                end
                local SuccessText;
                if (QuestData[8] and QuestData[8] ~= "" and QuestData[8] ~= "KEY(NO_MESSAGE)") then
                    SuccessText = QuestData[8];
                end
                local FailureText;
                if (QuestData[7] and QuestData[7] ~= "" and QuestData[7] ~= "KEY(NO_MESSAGE)") then
                    FailureText = QuestData[7];
                end

                API.CreateQuest {
                    Name        = QuestName,
                    Sender      = QuestData[1],
                    Receiver    = QuestData[2],
                    Time        = QuestData[4],
                    Description = QuestData[5],
                    Suggestion  = SuggestionText,
                    Failure     = FailureText,
                    Success     = SuccessText,

                    unpack(Behaviors),
                };
            end
        end
    end
end

---
-- Stellt den Debug nach dem Laden eines Spielstandes wieder her.
--
-- @param _Arguments Argumente der überschriebenen Funktion
-- @param _Original  Referenz auf Save-Funktion
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.OnSaveGameLoad(_Arguments, _Original)
    AddOnQuestDebug.Global:ActivateDevelopingCheats();
    AddOnQuestDebug.Global:ActivateDevelopingShell();
    AddOnQuestDebug.Global:ActivateQuestTrace();
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Local:Install()
end

---
-- Aktiviert die Development Cheats des Spiels.
--
-- @see AddOnQuestDebug.Global:ActivateDevelopingCheats
-- @within Internal
-- @local
--
function AddOnQuestDebug.Local:ActivateDevelopingCheats()
    KeyBindings_EnableDebugMode(1);
    KeyBindings_EnableDebugMode(2);
    KeyBindings_EnableDebugMode(3);
    self.Data.GameClock = true;
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock",1);
end

---
-- Aktiviert die Kommandokonsole.
--
-- @see AddOnQuestDebug.Global:ActivateDevelopingShell
-- @within Internal
-- @local
--
function AddOnQuestDebug.Local:ActivateDevelopingShell()
    GUI_Chat.Abort = function() end

    GUI_Chat.Confirm = function()
        Input.GameMode();
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",0);
        AddOnQuestDebug.Local.Data.ChatBoxInput = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput");
        g_Chat.JustClosed = 1;
        Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 );
    end

    QSB_DEBUG_InputBoxJob = function()
        if not AddOnQuestDebug.Local.Data.BoxShown then
            Input.ChatMode();
            Game.GameTimeSetFactor( GUI.GetPlayerID(), 0 );
            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput", 1);
            XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "");
            XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput");
            AddOnQuestDebug.Local.Data.BoxShown = true
        elseif AddOnQuestDebug.Local.Data.ChatBoxInput then
            AddOnQuestDebug.Local.Data.ChatBoxInput = string.gsub(AddOnQuestDebug.Local.Data.ChatBoxInput,"'","\'");
            GUI.SendScriptCommand("AddOnQuestDebug.Global:Parser('"..AddOnQuestDebug.Local.Data.ChatBoxInput.."')");
            AddOnQuestDebug.Local.Data.BoxShown = nil;
            return true;
        end
    end

    Input.KeyBindDown(Keys.ModifierShift + Keys.OemPipe, "StartSimpleJob('QSB_DEBUG_InputBoxJob')", 2);
end

Core:RegisterBundle("AddOnQuestDebug");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnCastleStore                                             # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle stellt ein Burglager, oder Kellerlager, zur Verfügung, das
-- sich ähnlich wie das normale Lager verhält.
--
-- Das Burglager ist von der Ausbaustufe der Burg abhängig. Je weiter die Burg
-- ausgebaut wird, desto höher ist das Limit. Eine Ware wird dann im Burglager
-- eingelagert, wenn das eingestellte Limit der Ware im Lagerhaus erreicht wird.
--
-- Der Spieler kann das allgemeine Verhalten des Lagers für alle Waren wählen
-- und zusätzlich für einzelne Waren andere Verhalten bestimmen. Waren können
-- eingelagert und ausgelagert werden. Eingelagerte Waren können zusätzlich
-- gesperrt werden. Eine gesperrte Ware wird nicht wieder ausgelagert, auch
-- wenn Platz im Lager frei wird.
--
-- Muss ein Spieler einen Tribut aus dem Lagerhaus begleichen, eine bestimmte
-- Menge an Waren erreichen oder die Kosten zur Aktivierung eines interaktien
-- Objektes bezahlen, werden die Güter im Burglager automatisch mit einbezogen,
-- wenn sie nicht gesperrt wurden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnCastleStore = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt ein Burglager für den angegebenen Spieler.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=table] Burglager-Instanz
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreCreate(1);
--
function API.CastleStoreCreate(_PlayerID)
    if GUI then
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CastleStoreCreate: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    return QSB.CastleStore:New(_PlayerID);
end

---
-- Zerstört das Burglager des angegebenen Spielers.
--
-- Alle Waren im Burglager werden dabei unwiederuflich gelöscht!
--
-- @param[type=number] _PlayerID ID des Spielers
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreDestroy(1)
--
function API.CastleStoreDestroy(_PlayerID)
    if GUI then
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CastleStoreDestroy: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        Store:Dispose();
    end
end

---
-- Fügt dem Burglager des Spielers eine Menga an Waren hinzu.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Typ der Ware
-- @param[type=number] _Amount Menge der Ware
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreAddGood(1, Goods.G_Wood, 50);
--
function API.CastleStoreAddGood(_PlayerID, _Good, _Amount)
    if GUI then
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CastleStoreAddGood: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        if GetNameOfKeyInTable(Goods, _Good) == nil then
            error("API.CastleStoreAddGood: _Good (" ..tostring(_Good).. ") is wrong!");
            return;
        end
        if type(_Amount) ~= "number" or _Amount < 1 then
            error("API.CastleStoreAddGood: _Amount (" ..tostring(_Amount).. ") is wrong!");
            return;
        end
        Store:Add(_Good, _Amount);
    end
end

---
-- Entfernt eine Menge von Waren aus dem Burglager des Spielers.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Typ der Ware
-- @param[type=number] _Amount Menge der Ware
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreRemoveGood(1, Goods.G_Iron, 15);
--
function API.CastleStoreRemoveGood(_PlayerID, _Good, _Amount)
    if GUI then
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CastleStoreRemoveGood: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        if GetNameOfKeyInTable(Goods, _Good) == nil then
            error("API.CastleStoreRemoveGood: _Good (" ..tostring(_Good).. ") is wrong!");
            return;
        end
        if type(_Amount) ~= "number" or _Amount < 1 then
            error("API.CastleStoreRemoveGood: _Amount (" ..tostring(_Amount).. ") is wrong!");
            return;
        end
        Store:Remove(_Good, _Amount);
    end
end

---
-- Gibt die Menge an Waren des Typs im Burglager des Spielers zurück.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Typ der Ware
-- @return[type=number] Menge an Waren
-- @within Anwenderfunktionen
-- @usage
-- local Amount = API.CastleStoreCountGood(1, Goods.G_Milk);
--
function API.CastleStoreGetGoodAmount(_PlayerID, _Good)
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CastleStoreGetGoodAmount: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    if GetNameOfKeyInTable(Goods, _Good) == nil then
        error("API.CastleStoreGetGoodAmount: _Good (" ..tostring(_Good).. ") is wrong!");
        return;
    end
    if GUI then
        return QSB.CastleStore:GetAmount(_PlayerID, _Good);
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        return Store:GetAmount(_Good);
    end
    return 0;
end

---
-- Gibt die Gesamtmenge aller Waren im Burglager zurück.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=number] Menge an Waren
-- @within Anwenderfunktionen
-- @usage
-- local Amount = API.CastleStoreTotalAmount(1);
--
function API.CastleStoreGetTotalAmount(_PlayerID)
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CastleStoreGetTotalAmount: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    if GUI then
        return QSB.CastleStore:GetTotalAmount(_PlayerID);
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        return Store:GetTotalAmount();
    end
    return 0;
end

---
-- Gibt die maximale Kapazität des Burglagers zurück.
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=number] Große des Lagers
-- @within Anwenderfunktionen
-- @usage
-- local Size = API.CastleStoreGetSize(1);
--
function API.CastleStoreGetSize(_PlayerID)
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CastleStoreGetSize: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    if GUI then
        return QSB.CastleStore:GetLimit(_PlayerID);
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        return Store:GetLimit();
    end
    return 0;
end

---
-- Setzt die Basiskapazität des Burglagers.
--
-- Die Basiskapazität ist das Limit der ersten Stufe der Burg. Mit jedem
-- Ausbau wird dieser Wert verdoppelt.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Capacity Basisgröße des Lagers
-- @within Anwenderfunktionen
-- @usage
-- -- -> [150, 300, 600, 1200]
-- API.CastleStoreSetBaseCapacity(1, 150);
--
function API.CastleStoreSetBaseCapacity(_PlayerID, _Capacity)
    if GUI then
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CastleStoreSetBaseCapacity: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    if type(_Capacity) ~= "number" or _Capacity < 1 then
        error("API.CastleStoreSetBaseCapacity: _Capacity (" ..tostring(_Capacity).. ") is wrong!");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        Store:SetStorageLimit(_Capacity);
    end
end

---
-- Setzt die Obergrenze ab der ins Burglager ausgelagert wird.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good     Warentyp
-- @param[type=number] _Limit    Obergrenze
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreSetOutsourceBoundary(1, Goods.G_Milk, 50);
--
function API.CastleStoreSetOutsourceBoundary(_PlayerID, _Good, _Limit)
    if GUI then
        return;
    end
    if type(_PlayerID) ~= "number" or _PlayerID < 1 or _PlayerID > 8 then
        error("API.CastleStoreSetOutsourceBoundary: _PlayerID (" ..tostring(_PlayerID).. ") is wrong!");
        return;
    end
    if GetNameOfKeyInTable(Goods, _Good) == nil then
        error("API.CastleStoreSetOutsourceBoundary: _Good (" ..tostring(_Good).. ") is wrong!");
        return;
    end
    if type(_Limit) ~= "number" or _Limit < 1 then
        error("API.CastleStoreSetOutsourceBoundary: _Limit (" ..tostring(_Limit).. ") is wrong!");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        Store:SetUperLimitInStorehouseForGoodType(_Good, _Limit)
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnCastleStore = {
    Global = {
        Data = {
            UpdateCastleStoreInitalized = false,
            CastleStoreObjects = {},
            BackupGoods = {},
        },
        CastleStore = {
            Data = {
                UpdateCastleStore = true,
                CapacityBase = 75,
                Goods = {
                    -- [Ware] = {Menge, Einlager-Flag, Gesperrt-Flag, Untergrenze}
                    [Goods.G_Wood]      = {0, true, false, 35},
                    [Goods.G_Stone]     = {0, true, false, 35},
                    [Goods.G_Iron]      = {0, true, false, 35},
                    [Goods.G_Carcass]   = {0, true, false, 15},
                    [Goods.G_Grain]     = {0, true, false, 15},
                    [Goods.G_RawFish]   = {0, true, false, 15},
                    [Goods.G_Milk]      = {0, true, false, 15},
                    [Goods.G_Herb]      = {0, true, false, 15},
                    [Goods.G_Wool]      = {0, true, false, 15},
                    [Goods.G_Honeycomb] = {0, true, false, 15},
                }
            },
        },
    },
    Local = {
        Data = {},

        CastleStore = {
            Data = {}
        },

        Description = {
            ShowCastle = {
                Text = {
                    de = "Finanzansicht",
                    en = "Financial view",
                },
            },

            ShowCastleStore = {
                Text = {
                    de = "Lageransicht",
                    en = "Storeage view",
                },
            },

            GoodButtonDisabled = {
                Text = {
                    de = "Diese Ware wird nicht angenommen.",
                    en = "This good will not be stored.",
                },
            },

            CityTab = {
                Title = {
                    de = "Güter verwaren",
                    en = "Keep goods",
                },
                Text = {
                    de = "[UMSCHALT + N]{cr}- Lagert Waren im Burglager ein {cr}- Waren verbleiben auch im Lager, wenn Platz vorhanden ist",
                    en = "[SHIFT + N]{cr}- Stores goods inside the vault {cr}- Goods also remain in the warehouse when space is available",
                },
            },

            StorehouseTab = {
                Title = {
                    de = "Güter zwischenlagern",
                    en = "Store in vault",
                },
                Text = {
                    de = "[UMSCHALT + B]{cr}- Lagert Waren im Burglager ein {cr}- Lagert waren wieder aus, sobald Platz frei wird",
                    en = "[SHIFT + B]{cr}- Stores goods inside the vault {cr}- Allows to extrac goods as soon as space becomes available",
                },
            },

            MultiTab = {
                Title = {
                    de = "Lager räumen",
                    en = "Clear store",
                },
                Text = {
                    de = "[UMSCHALT + M]{cr}- Lagert alle Waren aus {cr}- Benötigt Platz im Lagerhaus",
                    en = "[Shift + M]{cr}- Removes all goods {cr}- Requires space in the storehouse",
                },
            },
        },
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Global:Install()
    QSB.CastleStore = self.CastleStore;
    self:OverwriteGameFunctions()
    API.AddSaveGameAction(self.OnSaveGameLoaded);
end

---
-- Erzeugt ein neues Burglager-Objekt und gibt es zurück.
--
-- <p><b>Alias</b>: QSB.CastleStore:New</p>
--
-- @param _PlayerID [number] PlayerID des Spielers
-- @return [table] QSB.CastleStore Instanz
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Erstellt ein Burglager für Spieler 1
-- local Store = QSB.CastleStore:new(1);
--
function AddOnCastleStore.Global.CastleStore:New(_PlayerID)
    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");
    local Store = API.InstanceTable(self);
    Store.Data.PlayerID = _PlayerID;
    AddOnCastleStore.Global.Data.CastleStoreObjects[_PlayerID] = Store;

    if not self.Data.UpdateCastleStoreInitalized then
        self.Data.UpdateCastleStoreInitalized = true;
        StartSimpleHiResJobEx(AddOnCastleStore.Global.CastleStore.UpdateStores);
    end
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore:CreateStore(]] ..Store.Data.PlayerID.. [[);
    ]])
    return Store;
end

---
-- Gibt die Burglagerinstanz für den Spieler zurück.
--
-- Wurde kein Burglager für den Spieler erstellt, wird nil zurückgegeben.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetInstance</p>
--
-- @param _PlayerID [number] PlayerID des Spielers
-- @return [table] QSB.CastleStore Instanz
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Ermittelt das Burglager von Spieler 1
-- local Store = QSB.CastleStore:GetInstance(1);
--
function AddOnCastleStore.Global.CastleStore:GetInstance(_PlayerID)
    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");
    return AddOnCastleStore.Global.Data.CastleStoreObjects[_PlayerID];
end

---
-- Gibt die Menge an Waren des Spielers zurück, eingeschlossen
-- der Waren im Burglager. Hat der Spieler kein Burglager, wird
-- nur die Menge im Lagerhaus zurückgegeben.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetGoodAmountWithCastleStore</p>
--
-- @param _Good [number] Warentyp
-- @param _PlayerIDvID des Spielers
-- @return [number] Warenmenge mit Menge in Burglager
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Menge an Holz in beiden Lagern
-- local WoodAmount = QSB.CastleStore:GetGoodAmountWithCastleStore(Goods.G_Wood, 1);
--
function AddOnCastleStore.Global.CastleStore:GetGoodAmountWithCastleStore(_Good, _PlayerID)
    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");
    local CastleStore = self:GetInstance(_PlayerID);
    local Amount = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);

    if CastleStore ~= nil and _Good ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource then
        Amount = Amount + CastleStore:GetAmount(_Good);
    end
    return Amount;
end

---
-- Zerstört das Burglager.
--
-- Die Burg wird dabei natürlich nicht zerstört.
--
-- <p><b>Alias</b>: QSB.CastleStore:Dispose</p>
--
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Löschen des Burglagers von Spieler 1 ohne Referenz
-- QSB.CastleStore:GetInstance(1):Dispose();
-- -- Loschen mit Referenzvariable (z.B. Store)
-- Store:Dispose();
--
function AddOnCastleStore.Global.CastleStore:Dispose()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore:DeleteStore(]] ..self.Data.PlayerID.. [[);
    ]])
    AddOnCastleStore.Global.Data.CastleStoreObjects[self.Data.PlayerID] = nil;
end

---
-- Setzt die Obergrenze für eine Ware, ab der ins Burglager
-- ausgelagert wird.
--
-- <p><b>Alias</b>: QSB.CastleStore:SetUperLimitInStorehouseForGoodType</p>
--
-- @param _Good [number] Warentyp
-- @param _Limit [number] Obergrenze
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:SetUperLimitInStorehouseForGoodType(_Good, _Limit)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    self.Data.Goods[_Good][4] = _Limit;
    Logic.ExecuteInLuaLocalState([[
        AddOnCastleStore.Local.CastleStore.Data[]] ..self.Data.PlayerID.. [[].Goods[]] .._Good.. [[][4] = ]] .._Limit.. [[
    ]])
    return self;
end

---
-- Setzt den Basiswert für die maximale Kapazität des Burglagers.
--
-- Der Basiswert dient zur Berechnung der Kapazität für die Ausbaustufen und
-- muss durch 2 teilbar sein.
--
-- Ist also der Basiswert 150, ergibt sich daraus:
-- <code>
-- 150, 300, 600, 1200
-- </code>
--
-- <p><b>Alias</b>: QSB.CastleStore:SetStorageLimit</p>
--
-- @param _Limit [number] Maximale Kapazität
-- @return self
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Basiswert auf 100 setzen.
-- -- -> [100, 200, 400, 800]
-- QSB.CastleStore:GetInstance(1):SetStorageLimit(100);
--
function AddOnCastleStore.Global.CastleStore:SetStorageLimit(_Limit)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    self.Data.CapacityBase = math.floor(_Limit/2);
    Logic.ExecuteInLuaLocalState([[
        AddOnCastleStore.Local.CastleStore.Data[]] ..self.Data.PlayerID.. [[].CapacityBase = ]] ..math.floor(_Limit/2).. [[
    ]])
    return self;
end

---
-- Gibt die Menge an Waren des Typs im Burglager zurück.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetAmount</p>
--
-- @param _Good [number] Warentyp
-- @return [number] Menge an Waren im Burglager
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:GetAmount(_Good)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    if self.Data.Goods[_Good] then
        return self.Data.Goods[_Good][1];
    end
    return 0;
end

---
-- Gibt die Gesamtmenge aller Waren im Burglager zurück.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetTotalAmount</p>
--
-- @return [number] Gesamtmenge aller Waren
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:GetTotalAmount()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    local TotalAmount = 0;
    for k, v in pairs(self.Data.Goods) do
        TotalAmount = TotalAmount + v[1];
    end
    return TotalAmount;
end

---
-- Gibt das aktuelle Lagerlimit zurück.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetLimit</p>
--
-- @return [number] Lagerlimt in der Burg
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:GetLimit()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    local Level = 0;
    local Headquarters = Logic.GetHeadquarters(self.Data.PlayerID);
    if Headquarters ~= 0 then
        Level = Logic.GetUpgradeLevel(Headquarters);
    end

    local Capacity = self.Data.CapacityBase;
    for i= 1, (Level+1), 1 do
        Capacity = Capacity * 2;
    end
    return Capacity;
end

---
-- Gibt zurück, ob die Ware akzeptiert wird.
--
-- <p><b>Alias</b>: QSB.CastleStore:IsGoodAccepted</p>
--
-- @param _Good [number] Warentyp
-- @return [boolean] Ware wird akzeptiert
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:IsGoodAccepted(_Good)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    return self.Data.Goods[_Good][2] == true;
end

---
-- Setzt, ob die Ware akzeptiert wird.
--
-- <p><b>Alias</b>: QSB.CastleStore:SetGoodAccepted</p>
--
-- @param _Good [number] Watentyp
-- @param _Flag [boolean] Akzeptanz-Flag
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:SetGoodAccepted(_Good, _Flag)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    self.Data.Goods[_Good][2] = _Flag == true;
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore:SetAccepted(
            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..tostring(_Flag == true).. [[
        )
    ]])
    return self;
end

---
-- Gibt zurück, ob die Ware gesperrt ist.
--
-- <p><b>Alias</b>: QSB.CastleStore:IsGoodLocked</p>
--
-- @param _Good [number] Warentyp
-- @return [boolean] Ware ist gesperrt
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:IsGoodLocked(_Good)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    return self.Data.Goods[_Good][3] == true;
end

---
-- Setzt ob die Ware gesperrt ist, also nicht ausgelagert wird.
--
-- <p><b>Alias</b>: QSB.CastleStore:SetGoodLocked</p>
--
-- @param _Good [number] Watentyp
-- @param _Flag [boolean] Akzeptanz-Flag
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:SetGoodLocked(_Good, _Flag)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    self.Data.Goods[_Good][3] = _Flag == true;
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore:SetLocked(
            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..tostring(_Flag == true).. [[
        )
    ]])
    return self;
end

---
-- Setzt den Modus "Zwischenlagerung", als ob der Tab geklickt wird.
--
-- <p><b>Alias</b>: QSB.CastleStore:ActivateTemporaryMode</p>
--
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:ActivateTemporaryMode()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore.OnStorehouseTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)
    ]])
    return self;
end

---
-- Setzt den Modus "Verwahrung", als ob der Tab geklickt wird.
--
-- <p><b>Alias</b>: QSB.CastleStore:ActivateStockMode</p>
--
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:ActivateStockMode()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore.OnCityTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)
    ]])
    return self;
end

---
-- Setzt den Modus "Auslagerung", als ob der Tab geklickt wird.
--
-- <p><b>Alias</b>: QSB.CastleStore:ActivateOutsourceMode</p>
--
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:ActivateOutsourceMode()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore.OnMultiTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)
    ]])
    return self;
end

---
-- Lagert eine Menge von Waren im Burglager ein.
-- <p>Die Ware wird eingelagert wenn die Ware angenommen wird und noch
-- Platz im Burglager vorhanden ist.</p>
--
-- <p><b>Alias</b>: QSB.CastleStore:Store</p>
--
-- @param _Good [number] Watentyp
-- @param _Amount [number] Menge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:Store(_Good, _Amount)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    if self:IsGoodAccepted(_Good) then
        if self:GetLimit() >= self:GetTotalAmount() + _Amount then
            local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(self.Data.PlayerID));
            if GetPlayerResources(_Good, self.Data.PlayerID) > (self.Data.Goods[_Good][4] * (Level+1)) then
                AddGood(_Good, _Amount * (-1), self.Data.PlayerID);
                self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] + _Amount;
                Logic.ExecuteInLuaLocalState([[
                    QSB.CastleStore:SetAmount(
                        ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[
                    )
                ]]);
            end
        end
    end
    return self;
end

---
-- Lagert eine Menge von Waren aus dem Burglager aus.
-- <p>Die Ware wird ausgelagert wenn noch Platz im Lagerhaus vorhanden ist.</p>
--
-- <p><b>Alias</b>: QSB.CastleStore:Outsource</p>
--
-- @param _Good [number] Watentyp
-- @param _Amount [number] Menge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:Outsource(_Good, _Amount)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(self.Data.PlayerID));
    if Logic.GetPlayerUnreservedStorehouseSpace(self.Data.PlayerID) >= _Amount then
        if self:GetAmount(_Good) >= _Amount then
            AddGood(_Good, _Amount, self.Data.PlayerID);
            self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] - _Amount;
            Logic.ExecuteInLuaLocalState([[
                QSB.CastleStore:SetAmount(
                    ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[
                )
            ]]);
        end
    end
    return self;
end

---
-- Fügt eine Menge an Waren dem Burglager hinzu, solange noch
-- Platz vorhanden ist.
--
-- <p><b>Alias</b>: QSB.CastleStore:Add</p>
--
-- @param _Good [number] Watentyp
-- @param _Amount [number] Menge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:Add(_Good, _Amount)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    if self.Data.Goods[_Good] then
        for i= 1, _Amount, 1 do
            if self:GetLimit() > self:GetTotalAmount() then
                self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] + 1;
            end
        end
        Logic.ExecuteInLuaLocalState([[
            QSB.CastleStore:SetAmount(
                ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[
            )
        ]]);
    end
    return self;
end

---
-- Entfernt eine Menge an Waren aus dem Burglager ohne sie ins
-- Lagerhaus zu legen.
--
-- <p><b>Alias</b>: QSB.CastleStore:Remove</p>
--
-- @param _Good [number] Watentyp
-- @param _Amount [number] Menge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:Remove(_Good, _Amount)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    if self.Data.Goods[_Good] then
        if self:GetAmount(_Good) > 0 then
            local ToRemove = (_Amount <= self:GetAmount(_Good) and _Amount) or self:GetAmount(_Good);
            self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] - ToRemove;
            Logic.ExecuteInLuaLocalState([[
                QSB.CastleStore:SetAmount(
                    ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[
                )
            ]]);
        end
    end
    return self;
end

---
-- Aktiviert oder deaktiviert das Lagermanagement des Castle Store.
--
-- <p><b>Alias</b>: QSB.CastleStore.EnableStore</p>
--
-- @param[type=boolean] _Flag Lagermengenaktualisierung einschalten
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:EnableStore(_Flag)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    self.Data.UpdateCastleStore = _Flag == true;
end

---
-- Aktualisiert die Waren im Lager und im Burglager.
--
-- <p><b>Alias</b>: QSB.CastleStore.UpdateStores</p>
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore.UpdateStores()
    for k, v in pairs(AddOnCastleStore.Global.Data.CastleStoreObjects) do
        if v ~= nil and v.Data.UpdateCastleStore and Logic.GetStoreHouse(k) ~= 0 then
            local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(v.Data.PlayerID));
            for kk, vv in pairs(v.Data.Goods) do
                if vv ~= nil then
                    -- Ware wird angenommen
                    if vv[2] == true then
                        local AmountInStore  = GetPlayerResources(kk, v.Data.PlayerID)
                        local AmountInCastle = v:GetAmount(kk)
                        -- Auslagern, wenn möglich
                        if AmountInStore < (v.Data.Goods[kk][4] * (Level+1)) then
                            if vv[3] == false then
                                v:Outsource(kk, 1);
                            end
                        -- Einlagern, falls möglich
                        else
                            v:Store(kk, 1);
                        end
                    -- Ware ist gebannt
                    else
                        v:Outsource(kk, 1);
                    end
                end
            end
        end
    end
end

---
-- Wirt ausgeführt, nachdem ein Spielstand geladen wurde. Diese Funktion Stellt
-- alle nicht persistenten Änderungen wieder her.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Global.OnSaveGameLoaded()
    Logic.ExecuteInLuaLocalState("AddOnCastleStore.Local:OverwriteGetStringTableText()")
    Logic.ExecuteInLuaLocalState("AddOnCastleStore.Local.CastleStore:ActivateHotkeys()")
end

---
-- Überschreibt die globalen Spielfunktionen, die mit dem Burglager in
-- Konfilckt stehen.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Global:OverwriteGameFunctions()
    QuestTemplate.IsObjectiveCompleted_Orig_QSB_CastleStore = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        local data = objective.Data;

        if objective.Completed ~= nil then
            return objective.Completed;
        end

        if objectiveType == Objective.Produce then
            local GoodAmount = GetPlayerGoodsInSettlement(data[1], self.ReceivingPlayer, true);
            local CastleStore = QSB.CastleStore:GetInstance(self.ReceivingPlayer);
            if CastleStore and Logic.GetGoodCategoryForGoodType(data[1]) == GoodCategories.GC_Resource then
                GoodAmount = GoodAmount + CastleStore:GetAmount(data[1]);
            end
            if (not data[3] and GoodAmount >= data[2]) or (data[3] and GoodAmount < data[2]) then
                objective.Completed = true;
            end
        else
            return QuestTemplate.IsObjectiveCompleted_Orig_QSB_CastleStore(self, objective);
        end
    end

    QuestTemplate.SendGoods = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Deliver then
                if self.Objectives[i].Data[3] == nil then
                    local goodType = self.Objectives[i].Data[1]
                    local goodQuantity = self.Objectives[i].Data[2]

                    local amount = QSB.CastleStore:GetGoodAmountWithCastleStore(goodType, self.ReceivingPlayer, true);
                    if amount >= goodQuantity then
                        local Sender = self.ReceivingPlayer
                        local Target = self.Objectives[i].Data[6] and self.Objectives[i].Data[6] or self.SendingPlayer

                        local expectedMerchant = {}
                        expectedMerchant.Good = goodType
                        expectedMerchant.Amount = goodQuantity
                        expectedMerchant.PlayerID = Target
                        expectedMerchant.ID = nil
                        self.Objectives[i].Data[5] = expectedMerchant
                        self.Objectives[i].Data[3] = 1
                        QuestMerchants[#QuestMerchants+1] = expectedMerchant

                        if goodType == Goods.G_Gold then
                            local BuildingID = Logic.GetHeadquarters(Sender)
                            if BuildingID == 0 then
                                BuildingID = Logic.GetStoreHouse(Sender)
                            end
                            self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_GoldCart, BuildingID, 0, Target)
                            Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer)
                            Logic.RemoveGoodFromStock(BuildingID,goodType,goodQuantity)
                            if MapCallback_DeliverCartSpawned then
                                MapCallback_DeliverCartSpawned( self, self.Objectives[i].Data[3], goodType )
                            end

                        elseif goodType == Goods.G_Water then
                            local BuildingID = Logic.GetMarketplace(Sender)

                            self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_Marketer, BuildingID, 0, Target)
                            Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer)
                            Logic.RemoveGoodFromStock(BuildingID,goodType,goodQuantity)
                            if MapCallback_DeliverCartSpawned then
                                MapCallback_DeliverCartSpawned( self, self.Objectives[i].Data[3], goodType )
                            end

                        else
                            if Logic.GetGoodCategoryForGoodType(goodType) == GoodCategories.GC_Resource then
                                local StorehouseID = Logic.GetStoreHouse(Target)
                                local NumberOfGoodTypes = Logic.GetNumberOfGoodTypesOnOutStock(StorehouseID)
                                if NumberOfGoodTypes ~= nil then
                                    for j = 0, NumberOfGoodTypes-1 do
                                        local StoreHouseGoodType = Logic.GetGoodTypeOnOutStockByIndex(StorehouseID,j)
                                        local Amount = Logic.GetAmountOnOutStockByIndex(StorehouseID, j)
                                        if Amount >= goodQuantity then
                                            Logic.RemoveGoodFromStock(StorehouseID, StoreHouseGoodType, goodQuantity, false)
                                        end
                                    end
                                end

                                local SenderStorehouse = Logic.GetStoreHouse(Sender);
                                local AmountInStorehouse = GetPlayerResources(goodType, Sender);
                                if AmountInStorehouse < goodQuantity then
                                    -- Entferne aus Lager
                                    local AmountDifference = goodQuantity - AmountInStorehouse;
                                    AddGood(goodType, AmountInStorehouse * (-1), Sender);
                                    -- Entferne aus Burg
                                    local StoreInstance = QSB.CastleStore:GetInstance(self.ReceivingPlayer);
                                    if StoreInstance then
                                        StoreInstance:Remove(goodType, AmountDifference);
                                    end
                                else
                                    -- Entferne aus Lager
                                    AddGood(goodType, goodQuantity * (-1), Sender);
                                end
                                self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_ResourceMerchant, SenderStorehouse, 0, Target);
                                Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer);
                            else
                                Logic.StartTradeGoodGathering(Sender, Target, goodType, goodQuantity, 0)
                            end
                        end
                    end
                end
            end
        end
    end
end

---
-- Überschriebene Bezahlung von interaktiven Objekten - Step 1.
--
-- Speichert die aktuelle Warenmenge zwischen und leert dann das Lagerhaus.
-- Dann werden die Kosten ins Lagerhaus gelegt. Anschließend wird Step 1 im 
-- lokalenSkript aufgerufen.
--
-- @param[type=string] _ScriptName Scriptname des Objektes
-- @within Internal
-- @local
--
function AddOnCastleStore.Global:InteractiveObjectPayStep1(_ScriptName)
    if _ScriptName == nil then
        return;
    end
    local ScriptName = _ScriptName;
    if IO_SlaveToMaster[ScriptName] then
        ScriptName = IO_SlaveToMaster[ScriptName];
    end
    -- Burglager abschalten
    QSB.CastleStore:GetInstance(QSB.HumanPlayerID):EnableStore(false);
    -- Alle Waren zwischenspeichern
    for k, v in pairs(self.CastleStore.Data.Goods) do
        local Amount = GetPlayerResources(k, QSB.HumanPlayerID);
        self.Data.BackupGoods[k] = Amount;
        AddGood(k, (-1) * Amount, QSB.HumanPlayerID);
    end
    -- Kosten ins Lagerhaus legen
    if IO[ScriptName].m_Costs and IO[ScriptName].m_Costs[1] then
        local Type = IO[ScriptName].m_Costs[1];
        if self.Data.BackupGoods[Type] then
            AddGood(Type, IO[ScriptName].m_Costs[2], QSB.HumanPlayerID);
            self.Data.BackupGoods[Type] = self.Data.BackupGoods[Type] - IO[ScriptName].m_Costs[2];
            if self.Data.BackupGoods[Type] < 0 then
                QSB.CastleStore:GetInstance(QSB.HumanPlayerID):Remove(Type, (-1) * self.Data.BackupGoods[Type]);
                self.Data.BackupGoods[Type] = 0;
            end
        end
    end
    if IO[ScriptName].m_Costs and IO[ScriptName].m_Costs[3] then
        local Type = IO[ScriptName].m_Costs[3];
        if self.Data.BackupGoods[Type] then
            AddGood(Type, IO[ScriptName].m_Costs[4], QSB.HumanPlayerID);
            self.Data.BackupGoods[Type] = self.Data.BackupGoods[Type] - IO[ScriptName].m_Costs[4];
            if self.Data.BackupGoods[Type] < 0 then
                QSB.CastleStore:GetInstance(QSB.HumanPlayerID):Remove(Type, (-1) * self.Data.BackupGoods[Type]);
                self.Data.BackupGoods[Type] = 0;
            end
        end
    end
    -- Objektinteraktion ausführen
    Logic.ExecuteInLuaLocalState(string.format("AddOnCastleStore.Local:InteractiveObjectPayStep2('%s')", _ScriptName));
end

---
-- Überschriebene Bezahlung von interaktiven Objekten - Step 3.
--
-- Die ursprunglichen Warenmengen werden wiederhergestellt.
--
-- @param[type=string] _ScriptName Scriptname des Objektes
-- @within Internal
-- @local
--
function AddOnCastleStore.Global:InteractiveObjectPayStep3(_ScriptName)
    if _ScriptName == nil then
        return;
    end
    -- Burglager einschalten
    QSB.CastleStore:GetInstance(QSB.HumanPlayerID):EnableStore(true);
    -- Lagerhaus zurücksetzen
    for k, v in pairs(self.CastleStore.Data.Goods) do
        local Amount = self.Data.BackupGoods[k];
        AddGood(k, Amount, QSB.HumanPlayerID);
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:Install()
    IO = Logic.CreateReferenceToTableInGlobaLuaState("IO");

    QSB.CastleStore = self.CastleStore;
    self:OverwriteGameFunctions();
    self:OverwriteGetStringTableText();
    self:OverwriteInteractiveObject();
end

---
-- Erzeugt eine neue lokale Referenz zum Burglager des Spielers.
--
-- <p><b>Alias</b>: QSB.CastleStore:CreateStore</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:CreateStore(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    local Store = {
        StoreMode = 1,
        CapacityBase = 75,
        Goods = {
            [Goods.G_Wood]      = {0, true, false, 35},
            [Goods.G_Stone]     = {0, true, false, 35},
            [Goods.G_Iron]      = {0, true, false, 35},
            [Goods.G_Carcass]   = {0, true, false, 15},
            [Goods.G_Grain]     = {0, true, false, 15},
            [Goods.G_RawFish]   = {0, true, false, 15},
            [Goods.G_Milk]      = {0, true, false, 15},
            [Goods.G_Herb]      = {0, true, false, 15},
            [Goods.G_Wool]      = {0, true, false, 15},
            [Goods.G_Honeycomb] = {0, true, false, 15},
        }
    }
    self.Data[_PlayerID] = Store;
    
    self:ActivateHotkeys();
    self:DescribeHotkeys();
end

---
-- Entfernt eine lokale Referenz auf ein Burglager des Spielers.
--
-- <p><b>Alias</b>: QSB.CastleStore:DeleteStore</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:DeleteStore(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    self.Data[_PlayerID] = nil;
end

---
-- Gibt die Menge an Waren des Typs zurück.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetAmount</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @return [number] Menge an Waren
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetAmount(_PlayerID, _Good)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then
        return 0;
    end
    return self.Data[_PlayerID].Goods[_Good][1];
end

---
-- Gibt die Menge an Waren des Spielers zurück, eingeschlossen
-- der Waren im Burglager. Hat der Spieler kein Burglager, wird
-- nur die Menge im Lagerhaus zurückgegeben.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetGoodAmountWithCastleStore</p>
--
-- @param _Good [number] Warentyp
-- @param _PlayerID [number] ID des Spielers
-- @return [number] Menge an Waren
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetGoodAmountWithCastleStore(_Good, _PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    local Amount = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);
    if self:HasCastleStore(_PlayerID) then
        if _Good ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource then
            Amount = Amount + self:GetAmount(_PlayerID, _Good);
        end
    end
    return Amount;
end

---
-- Gibt die Gesamtmenge aller Waren im Burglager zurück.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetTotalAmount</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @return [number] Absolute Menge im Burglager
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetTotalAmount(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) then
        return 0;
    end
    local TotalAmount = 0;
    for k, v in pairs(self.Data[_PlayerID].Goods) do
        TotalAmount = TotalAmount + v[1];
    end
    return TotalAmount;
end

---
-- Ändert die Menge an Waren des Typs.
--
-- <p><b>Alias</b>: QSB.CastleStore:SetAmount</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @param _Amount [number] Warenmenge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:SetAmount(_PlayerID, _Good, _Amount)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then
        return;
    end
    self.Data[_PlayerID].Goods[_Good][1] = _Amount;
    return self;
end

---
-- Gibt zurück, ob die Ware des Typs akzeptiert wird.
--
-- <p><b>Alias</b>: QSB.CastleStore:IsAccepted</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @return [boolean] Ware wird angenommen
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:IsAccepted(_PlayerID, _Good)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then
        return false;
    end
    return self.Data[_PlayerID].Goods[_Good][2] == true;
end

---
-- Setzt eine Ware als akzeptiert.
--
-- <p><b>Alias</b>: QSB.CastleStore:SetAccepted</p>
--
-- @param _PlayerIDvID des Spielers
-- @param _Good [number] Warentyp
-- @param _Flag [boolean] Akzeptanz-Flag
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:SetAccepted(_PlayerID, _Good, _Flag)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) and self.Data[_PlayerID].Goods[_Good] then
        self.Data[_PlayerID].Goods[_Good][2] = _Flag == true;
    end
    return self;
end

---
-- Gibt zurück, ob die Ware des Typs gesperrt ist.
--
-- <p><b>Alias</b>: QSB.CastleStore:IsLocked</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @return [boolean] Ware ist gesperrt
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:IsLocked(_PlayerID, _Good)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then
        return false;
    end
    return self.Data[_PlayerID].Goods[_Good][3] == true;
end

---
-- Setzt eine Ware als gesperrt.
--
-- <p><b>Alias</b>: QSB.CastleStore:SetLocked</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @param _Flag [boolean] Akzeptanz-Flag
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:SetLocked(_PlayerID, _Good, _Flag)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) and self.Data[_PlayerID].Goods[_Good] then
        self.Data[_PlayerID].Goods[_Good][3] = _Flag == true;
    end
    return self;
end

---
-- Gibt zurück, ob der Spieler ein Burglager hat.
--
-- <p><b>Alias</b>: QSB.CastleStore:HasCastleStore</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @return [boolean] Spieler hat ein Burglager
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:HasCastleStore(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    return self.Data[_PlayerID] ~= nil;
end

---
-- Gibt die Referenz des Burglagers des Spielers zurück.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetStore</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @return [table] Instanz des Burglagers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetStore(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    return self.Data[_PlayerID];
end

---
-- Gibt das aktuelle Lagerlimit des Burglagers zurück.
--
-- <p><b>Alias</b>: QSB.CastleStore:GetLimit</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetLimit(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    local Level = 0;
    local Headquarters = Logic.GetHeadquarters(_PlayerID);
    if Headquarters ~= 0 then
        Level = Logic.GetUpgradeLevel(Headquarters);
    end

    local Capacity = self.Data[_PlayerID].CapacityBase;
    for i= 1, (Level+1), 1 do
        Capacity = Capacity * 2;
    end
    return Capacity;
end

---
-- "Waren einlagern" wurde geklickt.
--
-- <p><b>Alias</b>: QSB.CastleStore:OnStorehouseTabClicked</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:OnStorehouseTabClicked(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    self.Data[_PlayerID].StoreMode = 1;
    self:UpdateBehaviorTabs(_PlayerID);
    GUI.SendScriptCommand([[
        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);
        for k, v in pairs(Store.Data.Goods) do
            Store:SetGoodAccepted(k, true);
            Store:SetGoodLocked(k, false);
        end
    ]]);
end

---
-- "Waren verwahren" wurde gedrückt.
--
-- <p><b>Alias</b>: QSB.CastleStore:OnCityTabClicked</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:OnCityTabClicked(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    self.Data[_PlayerID].StoreMode = 2;
    self:UpdateBehaviorTabs(_PlayerID);
    GUI.SendScriptCommand([[
        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);
        for k, v in pairs(Store.Data.Goods) do
            Store:SetGoodAccepted(k, true);
            Store:SetGoodLocked(k, true);
        end
    ]]);
end

---
-- "Lager räumen" wurde gedrückt.
--
-- <p><b>Alias</b>: QSB.CastleStore:OnMultiTabClicked</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:OnMultiTabClicked(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    self.Data[_PlayerID].StoreMode = 3;
    self:UpdateBehaviorTabs(_PlayerID);
    GUI.SendScriptCommand([[
        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);
        for k, v in pairs(Store.Data.Goods) do
            Store:SetGoodLocked(k, false);
            Store:SetGoodAccepted(k, false);
        end
    ]]);
end

---
-- Ein GoodType-Button wurde geklickt.
--
-- <p><b>Alias</b>: QSB.CastleStore:GoodClicked</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @param _GoodType [number] Warentyp
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GoodClicked(_PlayerID, _GoodType)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) then
        local CurrentWirgetID = XGUIEng.GetCurrentWidgetID();
        GUI.SendScriptCommand([[
            local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);
            local Accepted = Store:IsGoodAccepted(]] .._GoodType.. [[)
            local Locked   = Store:IsGoodLocked(]] .._GoodType.. [[)
            
            if Accepted and not Locked then
                Store:SetGoodLocked(]] .._GoodType.. [[, true);
                Store:SetGoodAccepted(]] .._GoodType.. [[, true);
            elseif Accepted and Locked then
                Store:SetGoodLocked(]] .._GoodType.. [[, false);
                Store:SetGoodAccepted(]] .._GoodType.. [[, false);
            elseif not Accepted and not Locked then
                Store:SetGoodAccepted(]] .._GoodType.. [[, true);
            else
                Store:SetGoodLocked(]] .._GoodType.. [[, false);
                Store:SetGoodAccepted(]] .._GoodType.. [[, true);
            end
        ]]);
    end
end

---
-- Der Spieler wechselt zwischen den Ansichten in der Burg.
--
-- <p><b>Alias</b>: QSB.CastleStore:DestroyGoodsClicked</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:DestroyGoodsClicked(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) then
        QSB.CastleStore.ToggleStore();
    end
end

---
-- Aktualisiert das Burgmenü, sobald sich die Selektion ändert.
--
-- <p><b>Alias</b>: QSB.CastleStore:SelectionChanged</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:SelectionChanged(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) then
        local SelectedID = GUI.GetSelectedEntity();
        if Logic.GetHeadquarters(_PlayerID) == SelectedID then
            self:ShowCastleMenu();
        else
            self:RestoreStorehouseMenu();
        end
    end
end

---
-- Aktualisiert die Burglager-Tabs.
--
-- <p><b>Alias</b>: QSB.CastleStore:UpdateBehaviorTabs</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:UpdateBehaviorTabs(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not QSB.CastleStore:HasCastleStore(GUI.GetPlayerID()) then
        return;
    end
    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons", 0);
    if self.Data[_PlayerID].StoreMode == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonUp", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonDown", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Down", 1);
    elseif self.Data[_PlayerID].StoreMode == 2 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonDown", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonUp", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Down", 1);
    else
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonDown", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonDown", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Up", 1);
    end
end

---
-- Aktualisiert die Mengenanzeige der Waren im Burglager.
--
-- <p><b>Alias</b>: QSB.CastleStore:UpdateGoodsDisplay</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:UpdateGoodsDisplay(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) then
        return;
    end

    local MotherContainer  = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InStorehouse/Goods";
    local WarningColor = "";
    if self:GetLimit(_PlayerID) == self:GetTotalAmount(_PlayerID) then
        WarningColor = "{@color:255,32,32,255}";
    end
    for k, v in pairs(self.Data[_PlayerID].Goods) do
        local GoodTypeName = Logic.GetGoodTypeName(k);
        local AmountWidget = MotherContainer.. "/" ..GoodTypeName.. "/Amount";
        local ButtonWidget = MotherContainer.. "/" ..GoodTypeName.. "/Button";
        local BGWidget = MotherContainer.. "/" ..GoodTypeName.. "/BG";
        XGUIEng.SetText(AmountWidget, "{center}" .. WarningColor .. v[1]);
        XGUIEng.DisableButton(ButtonWidget, 0)

        -- Ware ist gesperrt
        if self:IsAccepted(_PlayerID, k) and self:IsLocked(_PlayerID, k) then
            XGUIEng.SetMaterialColor(ButtonWidget, 0, 230, 180, 120, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 1, 230, 180, 120, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 7, 230, 180, 120, 255);
        -- Ware wird nicht angenommen
        elseif not self:IsAccepted(_PlayerID, k) and not self:IsLocked(_PlayerID, k) then
            XGUIEng.SetMaterialColor(ButtonWidget, 0, 190, 90, 90, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 1, 190, 90, 90, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 7, 190, 90, 90, 255);
        -- Ware wird eingelagert
        else
            XGUIEng.SetMaterialColor(ButtonWidget, 0, 255, 255, 255, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 1, 255, 255, 255, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 7, 255, 255, 255, 255);
        end
    end
end

---
-- Aktualisiert die Lagerauslastungsanzeige des Burglagers.
--
-- <p><b>Alias</b>: QSB.CastleStore:UpdateStorageLimit</p>
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:UpdateStorageLimit(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) then
        return;
    end
    local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
    local PlayerID = GUI.GetPlayerID();
    local StorageUsed = QSB.CastleStore:GetTotalAmount(PlayerID);
    local StorageLimit = QSB.CastleStore:GetLimit(PlayerID);
    local StorageLimitText = XGUIEng.GetStringTableText("UI_Texts/StorageLimit_colon");
    local Text = "{center}" ..StorageLimitText.. " " ..StorageUsed.. "/" ..StorageLimit;
    XGUIEng.SetText(CurrentWidgetID, Text);
end

---
-- Wechselt zwischen der Finanzansicht und dem Burglager.
--
-- <p><b>Alias</b>: QSB.CastleStore:ToggleStore</p>
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:ToggleStore()
    assert(self == nil, "This function is procedural!");
    if QSB.CastleStore:HasCastleStore(GUI.GetPlayerID()) then
        if Logic.GetHeadquarters(GUI.GetPlayerID()) == GUI.GetSelectedEntity() then
            if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignBottomRight/Selection/Castle") == 1 then
                QSB.CastleStore.ShowCastleStoreMenu(QSB.CastleStore);
            else
                QSB.CastleStore.ShowCastleMenu(QSB.CastleStore);
            end
        end
    end
end

---
-- Stellt das normale Lagerhausmenü wieder her.
--
-- <p><b>Alias</b>: QSB.CastleStore:RestoreStorehouseMenu</p>
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:RestoreStorehouseMenu()
    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons", 1);
    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InCity/Goods", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InCity", 0);
    SetIcon("/InGame/Root/Normal/AlignBottomRight/DialogButtons/PlayerButtons/DestroyGoods", {16, 8});

    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/";
    SetIcon(MotherPath.. "StorehouseTabButtonUp/up/B_StoreHouse", {3, 13});
    SetIcon(MotherPath.. "StorehouseTabButtonDown/down/B_StoreHouse", {3, 13});
    SetIcon(MotherPath.. "CityTabButtonUp/up/CityBuildingsNumber", {8, 1});
    SetIcon(MotherPath.. "TabButtons/CityTabButtonDown/down/CityBuildingsNumber", {8, 1});
    SetIcon(MotherPath.. "TabButtons/Tab03Up/up/B_Castle_ME", {3, 14});
    SetIcon(MotherPath.. "Tab03Down/down/B_Castle_ME", {3, 14});

    for k, v in ipairs {"G_Carcass", "G_Grain", "G_Milk", "G_RawFish", "G_Iron","G_Wood", "G_Stone", "G_Honeycomb", "G_Herb", "G_Wool"} do
        local MotherPath = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InStorehouse/Goods/";
        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 0, 255, 255, 255, 255);
        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 1, 255, 255, 255, 255);
        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 7, 255, 255, 255, 255);
    end
end

---
-- Das normale Burgmenü wird angezeigt.
--
-- <p><b>Alias</b>: QSB.CastleStore:ShowCastleMenu</p>
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:ShowCastleMenu()
    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/";
    XGUIEng.ShowWidget(MotherPath.. "Selection/BGBig", 0)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse", 0)
    XGUIEng.ShowWidget(MotherPath.. "Selection/BGSmall", 1)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Castle", 1)

    if g_HideSoldierPayment ~= nil then
        XGUIEng.ShowWidget(MotherPath.. "Selection/Castle/Treasury/Payment", 0)
        XGUIEng.ShowWidget(MotherPath.. "Selection/Castle/LimitSoldiers", 0)
    end
    GUI_BuildingInfo.PaymentLevelSliderUpdate()
    GUI_BuildingInfo.TaxationLevelSliderUpdate()
    GUI_Trade.StorehouseSelected()
    local AnchorInfoForSmallX, AnchorInfoForSmallY = XGUIEng.GetWidgetLocalPosition(MotherPath.. "Selection/AnchorInfoForSmall")
    XGUIEng.SetWidgetLocalPosition(MotherPath.. "Selection/Info", AnchorInfoForSmallX, AnchorInfoForSmallY)

    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons", 1)
    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 1)
    XGUIEng.DisableButton(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 0)
    SetIcon(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", {10, 9})
end

---
-- Das Burglager wird angezeigt.
--
-- <p><b>Alias</b>: QSB.CastleStore:ShowCastleStoreMenu</p>
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:ShowCastleStoreMenu()
    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/";
    XGUIEng.ShowWidget(MotherPath.. "Selection/Selection/BGSmall", 0);
    XGUIEng.ShowWidget(MotherPath.. "Selection/Castle", 0);
    XGUIEng.ShowWidget(MotherPath.. "Selection/BGSmall", 0);
    XGUIEng.ShowWidget(MotherPath.. "Selection/BGBig", 1);
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse", 1);
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/AmountContainer", 0);
    XGUIEng.ShowAllSubWidgets(MotherPath.. "Selection/Storehouse/TabButtons", 1);
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/TabButtons", 0);

    GUI_Trade.StorehouseSelected()
    local AnchorInfoForBigX, AnchorInfoForBigY = XGUIEng.GetWidgetLocalPosition(MotherPath.. "Selection/AnchorInfoForBig")
    XGUIEng.SetWidgetLocalPosition(MotherPath.. "Selection/Info", AnchorInfoForBigX, AnchorInfoForBigY)

    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons", 1)
    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 1)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InStorehouse", 1)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InMulti", 0)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InCity", 1)
    XGUIEng.ShowAllSubWidgets(MotherPath.. "Selection/Storehouse/InCity/Goods", 0);
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InCity/Goods/G_Beer", 1)

    XGUIEng.DisableButton(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 0)

    local MotherPathDialog = MotherPath.. "DialogButtons/PlayerButtons/";
    local MotherPathTabs = MotherPath.. "Selection/Storehouse/TabButtons/";
    SetIcon(MotherPathDialog.. "DestroyGoods", {3, 14});
    SetIcon(MotherPathTabs.. "StorehouseTabButtonUp/up/B_StoreHouse", {10, 9});
    SetIcon(MotherPathTabs.. "StorehouseTabButtonDown/down/B_StoreHouse", {10, 9});
    SetIcon(MotherPathTabs.. "CityTabButtonUp/up/CityBuildingsNumber", {15, 6});
    SetIcon(MotherPathTabs.. "CityTabButtonDown/down/CityBuildingsNumber", {15, 6});
    SetIcon(MotherPathTabs.. "Tab03Up/up/B_Castle_ME", {7, 1});
    SetIcon(MotherPathTabs.. "Tab03Down/down/B_Castle_ME", {7, 1});

    self:UpdateBehaviorTabs(GUI.GetPlayerID());
end

---
-- Überschreibt den Bezahlvorgang der Kosten eines interaktiven Objektes.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:OverwriteInteractiveObject()
    GUI_Interaction.InteractiveObjectClicked_Orig_CastleStore = GUI_Interaction.InteractiveObjectClicked;
    GUI_Interaction.InteractiveObjectClicked = function()
        local i = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local EntityID = g_Interaction.ActiveObjectsOnScreen[i];
        local PlayerID = GUI.GetPlayerID()
        if not EntityID then
            return;
        end
        if not QSB.CastleStore:HasCastleStore(PlayerID) then
            GUI_Interaction.InteractiveObjectClicked_Orig_CastleStore();
            return;
        end
        local ScriptName = Logic.GetEntityName(EntityID);
        if IO_SlaveToMaster[ScriptName] then
            ScriptName = IO_SlaveToMaster[ScriptName];
        end
        local ObjectID = GetID(ScriptName);
        -- Kosten
        local Costs = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)}
        local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs, false);
        if IO[ScriptName] then
            if not self:OnObjectClicked_CanPlayerPayCosts(IO[ScriptName]) then
                return;
            end
        end
        if not CanBuyBoolean then
            Message(CanNotBuyString);
            return;
        end
        -- Bedingung
        if IO[ScriptName] and not IO[ScriptName].m_Fullfilled then
            Message(XGUIEng.GetStringTableText("UI_ButtonDisabled/PromoteKnight"));
            return;
        end
        -- Normale Aktion wenn nicht IO oder kostenlos
        if not IO[ScriptName] or (IO[ScriptName] and not IO[ScriptName].m_Costs) then
            GUI_Interaction.InteractiveObjectClicked_Orig_CastleStore();
            return;
        end
        -- Sound Aktivierung
        if not GUI_Interaction.InteractionClickOverride  or not GUI_Interaction.InteractionClickOverride(ObjectID) then
            Sound.FXPlay2DSound( "ui\\menu_click");
        end
        if Costs[1] and not GUI_Interaction.InteractionSpeechFeedbackOverride or not GUI_Interaction.InteractionSpeechFeedbackOverride(ObjectID) then                
            GUI_FeedbackSpeech.Add("SpeechOnly_CartsSent", g_FeedbackSpeech.Categories.CartsUnderway, nil, nil);
        end
        -- Aktion
        Costs = IO[ScriptName].m_Costs;
        if not Mission_Callback_OverrideObjectInteraction or not Mission_Callback_OverrideObjectInteraction(ObjectID, PlayerID, Costs) then
            local ScriptName = Logic.GetEntityName(ObjectID);
            -- Es muss geprüft werden, ob die Kosten wirklich bezahlt werden
            -- können oder ob das Burglager mit einbezogen wird.
            local CanBuyBoolean = true;
            if Costs and Costs[1] then
                CanBuyBoolean = CanBuyBoolean and GetPlayerResources(Costs[1], PlayerID) >= Costs[2];
                if Costs[3] then
                    CanBuyBoolean = CanBuyBoolean and GetPlayerResources(Costs[3], PlayerID) >= Costs[4];
                end
            end
            if CanBuyBoolean then
                GUI_Interaction.InteractiveObjectClicked_Orig_CastleStore();
            else
                GUI.SendScriptCommand(string.format("AddOnCastleStore.Global:InteractiveObjectPayStep1('%s')", ScriptName));
            end
        end
    end
end

---
-- Prüft, ob der Spieler die Kosten des interaktiven Objektes begleichen kann
-- und zeigt eine Meldung an, wenn das nicht der Fall ist.
--
-- @param[type=table]    _IO Table des IO
-- @return[type=boolean] Kosten können bezahlt werden
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:OnObjectClicked_CanPlayerPayCosts(_IO)
    local PlayerID = GUI.GetPlayerID();
    local CanBuyBoolean = true;
    if not _IO.m_Costs or type(_IO.m_Costs[1]) ~= "number" then
        return CanBuyBoolean;
    end
    if _IO.m_Costs[1] then
        local Amount = GetPlayerResources(_IO.m_Costs[1], GUI.GetPlayerID());
        if not QSB.CastleStore:IsLocked(PlayerID, _IO.m_Costs[1]) then
            Amount = QSB.CastleStore:GetGoodAmountWithCastleStore(_IO.m_Costs[1], GUI.GetPlayerID());
        end
        CanBuyBoolean = CanBuyBoolean and (Amount >= _IO.m_Costs[2]);
    end
    if _IO.m_Costs[3] then
        local Amount = GetPlayerResources(_IO.m_Costs[3], GUI.GetPlayerID());
        if not QSB.CastleStore:IsLocked(PlayerID, _IO.m_Costs[3]) then
            Amount = QSB.CastleStore:GetGoodAmountWithCastleStore(_IO.m_Costs[3], GUI.GetPlayerID());
        end
        CanBuyBoolean = CanBuyBoolean and (Amount >= _IO.m_Costs[4]);
    end
    if not CanBuyBoolean then
        local CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");
        Message(CanNotBuyString);
    end
    return CanBuyBoolean;
end

---
-- Hotkey-Callback für den Modus "Waren einlagern".
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:HotkeyStoreGoods()
    local PlayerID = GUI.GetPlayerID();
    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then 
        return;
    end
    AddOnCastleStore.Local.CastleStore:OnStorehouseTabClicked(PlayerID);
end

---
-- Hotkey-Callback für den Modus "Waren sperren".
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:HotkeyLockGoods()
    local PlayerID = GUI.GetPlayerID();
    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then 
        return;
    end
    AddOnCastleStore.Local.CastleStore:OnCityTabClicked(PlayerID);
end

---
-- Hotkey-Callback für den Modus "Lager räumen".
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:HotkeyEmptyStore()
    local PlayerID = GUI.GetPlayerID();
    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then 
        return;
    end
    AddOnCastleStore.Local.CastleStore:OnMultiTabClicked(PlayerID);
end

---
-- Versieht die Hotkeys des Burglagers mit ihren Funktionen.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:ActivateHotkeys()
    -- Waren einlagern
    Input.KeyBindDown(
        Keys.ModifierShift + Keys.B,
        "AddOnCastleStore.Local.CastleStore:HotkeyStoreGoods()",
        2,
        false
    );

    -- Waren verwahren
    Input.KeyBindDown(
        Keys.ModifierShift + Keys.N,
        "AddOnCastleStore.Local.CastleStore:HotkeyLockGoods()",
        2,
        false
    );
    
    -- Lager räumen
    Input.KeyBindDown(
        Keys.ModifierShift + Keys.M,
        "AddOnCastleStore.Local.CastleStore:HotkeyEmptyStore()",
        2,
        false
    );
end

---
-- Fügt die Beschreibung der Hotkeys der Hotkey-Tabelle hinzu.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:DescribeHotkeys()
    if not self.HotkeysAddToList then
        API.AddHotKey(
            {de = "Umschalt + B", en = "Shift + B"},
            {de = "Burglager: Waren einlagern", en = "Vault: Store goods"}
        );
        API.AddHotKey(
            {de = "Umschalt + N", en = "Shift + N"},
            {de = "Burglager: Waren sperren", en = "Vault: Lock goods"}
        );
        API.AddHotKey(
            {de = "Umschalt + M", en = "Shift + M"},
            {de = "Burglager: Lager räumen", en = "Vault: Empty store"}
        );
        self.HotkeysAddToList = true;
    end
end

---
-- Überschreibt die Textausgabe mit den eigenen Texten.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:OverwriteGetStringTableText()
    GetStringTableText_Orig_QSB_CatsleStore = XGUIEng.GetStringTableText;
    XGUIEng.GetStringTableText = function(_key)
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID = GUI.GetPlayerID();
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();

        if _key == "UI_ObjectNames/DestroyGoods" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignBottomRight/Selection/Castle") == 1 then
                    return API.Localize(AddOnCastleStore.Local.Description.ShowCastleStore.Text);
                else
                    return API.Localize(AddOnCastleStore.Local.Description.ShowCastle.Text);
                end
            end
        end
        if _key == "UI_ObjectDescription/DestroyGoods" then
            return "";
        end

        if _key == "UI_ObjectNames/CityBuildingsNumber" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return API.Localize(AddOnCastleStore.Local.Description.CityTab.Title);
            end
        end
        if _key == "UI_ObjectDescription/CityBuildingsNumber" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return API.Localize(AddOnCastleStore.Local.Description.CityTab.Text);
            end
        end

        if _key == "UI_ObjectNames/B_StoreHouse" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return API.Localize(AddOnCastleStore.Local.Description.StorehouseTab.Title);
            end
        end
        if _key == "UI_ObjectDescription/B_StoreHouse" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return API.Localize(AddOnCastleStore.Local.Description.StorehouseTab.Text);
            end
        end

        if _key == "UI_ObjectNames/B_Castle_ME" then
            local WidgetMotherName = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/";
            local WidgetDownButton = WidgetMotherName.. "Tab03Down/down/B_Castle_ME";
            local WidgetUpButton = WidgetMotherName.. "Tab03Up/up/B_Castle_ME";
            if XGUIEng.GetWidgetPathByID(CurrentWidgetID) == WidgetDownButton or XGUIEng.GetWidgetPathByID(CurrentWidgetID) == WidgetUpButton then
                if Logic.GetHeadquarters(PlayerID) == SelectedID then
                    return API.Localize(AddOnCastleStore.Local.Description.MultiTab.Title);
                end
            end
        end
        if _key == "UI_ObjectDescription/B_Castle_ME" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return API.Localize(AddOnCastleStore.Local.Description.MultiTab.Text);
            end
        end

        if _key == "UI_ButtonDisabled/NotEnoughGoods" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return API.Localize(AddOnCastleStore.Local.Description.GoodButtonDisabled.Text);
            end
        end

        return GetStringTableText_Orig_QSB_CatsleStore(_key);
    end
end

---
-- Überschreibt die lokalen Spielfunktionen, die benötigt werden, damit das
-- Burglager funktioniert.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:OverwriteGameFunctions()
    GameCallback_GUI_SelectionChanged_Orig_QSB_CastleStore = GameCallback_GUI_SelectionChanged;
    GameCallback_GUI_SelectionChanged = function(_Source)
        GameCallback_GUI_SelectionChanged_Orig_QSB_CastleStore(_Source);
        QSB.CastleStore:SelectionChanged(GUI.GetPlayerID());
    end

    GUI_Trade.GoodClicked_Orig_QSB_CastleStore = GUI_Trade.GoodClicked;
    GUI_Trade.GoodClicked = function()
        local GoodType = Goods[XGUIEng.GetWidgetNameByID(XGUIEng.GetWidgetsMotherID(XGUIEng.GetCurrentWidgetID()))];
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.GoodClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:GoodClicked(PlayerID, GoodType);
    end

    GUI_Trade.DestroyGoodsClicked_Orig_QSB_CastleStore = GUI_Trade.DestroyGoodsClicked;
    GUI_Trade.DestroyGoodsClicked = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.DestroyGoodsClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:DestroyGoodsClicked(PlayerID);
    end

    GUI_Trade.SellUpdate_Orig_QSB_CastleStore = GUI_Trade.SellUpdate;
    GUI_Trade.SellUpdate = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.SellUpdate_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:UpdateGoodsDisplay(PlayerID);
    end

    GUI_Trade.CityTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.CityTabButtonClicked;
    GUI_Trade.CityTabButtonClicked = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.CityTabButtonClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:OnCityTabClicked(PlayerID);
    end

    GUI_Trade.StorehouseTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.StorehouseTabButtonClicked;
    GUI_Trade.StorehouseTabButtonClicked = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.StorehouseTabButtonClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:OnStorehouseTabClicked(PlayerID);
    end

    GUI_Trade.MultiTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.MultiTabButtonClicked;
    GUI_Trade.MultiTabButtonClicked = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.MultiTabButtonClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:OnMultiTabClicked(PlayerID);
    end

    GUI_BuildingInfo.StorageLimitUpdate_Orig_QSB_CastleStore = GUI_BuildingInfo.StorageLimitUpdate;
    GUI_BuildingInfo.StorageLimitUpdate = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_BuildingInfo.StorageLimitUpdate_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:UpdateStorageLimit(PlayerID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_Interaction.SendGoodsClicked = function()
        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(g_Interaction.CurrentMessageQuestIndex);
        if not Quest then
            return;
        end
        local QuestIndex = GUI_Interaction.GetPotentialSubQuestIndex(g_Interaction.CurrentMessageQuestIndex);
        local GoodType = Quest.Objectives[1].Data[1];
        local GoodAmount = Quest.Objectives[1].Data[2];
        local Costs = {GoodType, GoodAmount};
        local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs, true);

        local PlayerID = GUI.GetPlayerID();
        if Logic.GetGoodCategoryForGoodType(GoodType) == GoodCategories.GC_Resource then
            CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");
            CanBuyBoolean = false;
            if QSB.CastleStore:IsLocked(PlayerID, GoodType) then
                CanBuyBoolean = GetPlayerResources(GoodType, PlayerID) >= GoodAmount;
            else
                CanBuyBoolean = (GetPlayerResources(GoodType, PlayerID) + QSB.CastleStore:GetAmount(PlayerID, GoodType)) >= GoodAmount;
            end
        end

        local TargetPlayerID = Quest.Objectives[1].Data[6] and Quest.Objectives[1].Data[6] or Quest.SendingPlayer;
        local PlayerSectorType = PlayerSectorTypes.Thief;
        local IsReachable = CanEntityReachTarget(TargetPlayerID, Logic.GetStoreHouse(GUI.GetPlayerID()), Logic.GetStoreHouse(TargetPlayerID), nil, PlayerSectorType);
        if IsReachable == false then
            local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_GenericUnreachable");
            Message(MessageText);
            return
        end

        if CanBuyBoolean == true then
            Sound.FXPlay2DSound( "ui\\menu_click");
            GUI.QuestTemplate_SendGoods(QuestIndex);
            GUI_FeedbackSpeech.Add("SpeechOnly_CartsSent", g_FeedbackSpeech.Categories.CartsUnderway, nil, nil);
        else
            Message(CanNotBuyString);
        end
    end

    GUI_Tooltip.SetCosts = function(_TooltipCostsContainer, _Costs, _GoodsInSettlementBoolean)
        local TooltipCostsContainerPath = XGUIEng.GetWidgetPathByID(_TooltipCostsContainer);
        local Good1ContainerPath = TooltipCostsContainerPath .. "/1Good";
        local Goods2ContainerPath = TooltipCostsContainerPath .. "/2Goods";
        local NumberOfValidAmounts = 0;
        local Good1Path;
        local Good2Path;

        for i = 2, #_Costs, 2 do
            if _Costs[i] ~= 0 then
                NumberOfValidAmounts = NumberOfValidAmounts + 1;
            end
        end
        if NumberOfValidAmounts == 0 then
            XGUIEng.ShowWidget(Good1ContainerPath, 0);
            XGUIEng.ShowWidget(Goods2ContainerPath, 0);
            return
        elseif NumberOfValidAmounts == 1 then
            XGUIEng.ShowWidget(Good1ContainerPath, 1);
            XGUIEng.ShowWidget(Goods2ContainerPath, 0);
            Good1Path = Good1ContainerPath .. "/Good1Of1";
        elseif NumberOfValidAmounts == 2 then
            XGUIEng.ShowWidget(Good1ContainerPath, 0);
            XGUIEng.ShowWidget(Goods2ContainerPath, 1);
            Good1Path = Goods2ContainerPath .. "/Good1Of2";
            Good2Path = Goods2ContainerPath .. "/Good2Of2";
        elseif NumberOfValidAmounts > 2 then
            GUI.AddNote("Debug: Invalid Costs table. Not more than 2 GoodTypes allowed.");
        end

        local ContainerIndex = 1;
        for i = 1, #_Costs, 2 do
            if _Costs[i + 1] ~= 0 then
                local CostsGoodType = _Costs[i];
                local CostsGoodAmount = _Costs[i + 1];
                local IconWidget;
                local AmountWidget;
                if ContainerIndex == 1 then
                    IconWidget = Good1Path .. "/Icon";
                    AmountWidget = Good1Path .. "/Amount";
                else
                    IconWidget = Good2Path .. "/Icon";
                    AmountWidget = Good2Path .. "/Amount";
                end
                SetIcon(IconWidget, g_TexturePositions.Goods[CostsGoodType], 44);
                local PlayerID = GUI.GetPlayerID();
                local PlayersGoodAmount = GetPlayerGoodsInSettlement(CostsGoodType, PlayerID, _GoodsInSettlementBoolean);
                if Logic.GetGoodCategoryForGoodType(CostsGoodType) == GoodCategories.GC_Resource and CostsGoodType ~= Goods.G_Gold then
                    if not QSB.CastleStore:IsLocked(PlayerID, CostsGoodType) then
                        PlayersGoodAmount = PlayersGoodAmount + QSB.CastleStore:GetAmount(PlayerID, CostsGoodType);
                    end
                end
                local Color = "";
                if PlayersGoodAmount < CostsGoodAmount then
                    Color = "{@script:ColorRed}";
                end
                if CostsGoodAmount > 0 then
                    XGUIEng.SetText(AmountWidget, "{center}" .. Color .. CostsGoodAmount);
                else
                    XGUIEng.SetText(AmountWidget, "");
                end
                ContainerIndex = ContainerIndex + 1;
            end
        end
    end
end

---
-- Überschriebene Bezahlung von interaktiven Objekten - Step 2.
--
-- Führt die Interaktion aus und ruft danach Step 3 auf.
--
-- @param[type=string] _ScriptName Scriptname des Objektes
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:InteractiveObjectPayStep2(_ScriptName)
    if _ScriptName == nil then
        return;
    end
    GUI.ExecuteObjectInteraction(GetID(_ScriptName), GUI.GetPlayerID())
    GUI.SendScriptCommand(string.format("AddOnCastleStore.Global:InteractiveObjectPayStep3('%s')", _ScriptName));
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("AddOnCastleStore");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnCutsceneSystem                                          # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht es Kameraflüge, also Cutscenes, zu erstellen.
--
-- Cutscenes sind als CS-Datei vordefinierte Kameraflüge. Mit diesem Modul
-- können diese Kameraflüge gruppiert werden. Diese Gruppierung ist das, was
-- die Cutscene ausmacht.
--
-- Pro Flug können Titel und Text eingeblendet werden und eine Lua-Funktion
-- aufgerufen werden.
--
-- Flights können entweder im Internal-Mode des Mapeditors oder über externe
-- Tools erzeugt werden. Sie müssen jedoch immer in das Hauptverzeichnis der
-- Map kopiert werden.
-- <pre>maps/externalmap/.../myCutscene.cs</pre>
-- Gibt Deinen Flights passende Namen, um die Zuordnung zu erleichtern.
-- <pre>cs01_flight1.cs
--cs01_flight2.cs
--...</pre>
--
-- Während der Mapentwicklung können die CS-Dateien nicht in der Map liegen,
-- da sie bei jedem Speichern gelöscht werden. Wenn die Datei nicht vorhanden
-- ist, wird der Flight übersprungen. Sind also keine Flights da, gilt die
-- Cutscene trotzdem als abgespielt, sobald sie beendet ist. Das erleichtert
-- das Testen. Du siehst nur nix.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnCutsceneSystem = {};

API = API or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Startet eine Cutscene.
--
-- Die einzelnen Flights einer Cutscene werden als CS-Dateien definiert.
--
-- Eine Cutscene besteht aus den einzelnen Kameraflügen, also Flights, und
-- speziellen Feldern, mit denen weitere Einstellungen gemacht werden können.
-- Siehe dazu auch das Briefing System für einen Vergleich.
--
-- Die Funktion gibt die ID der Cutscene zurück, mit der geprüft werden kann,
-- ob die Cutscene beendet ist.
-- 
-- <b>Alias</b>: StartCutscene
--
-- @param[type=table]   _Cutscene Cutscene table
-- @return[type=number] ID der Cutscene
-- @within Anwenderfunktionen
-- @usage function MyCutscene()
--     local Cutscene = {
--        CameraLookAt = {X, Y},   -- Kameraposition am Ende setzen
--        RestoreGameSpeed = true, -- Spielgeschwindigkeit wiederherstellen
--        BarOpacity = 0.39,       -- Durchsichtige Bars verwenden (Opacity = 39%)
--        BigBars = false,         -- Breite Bars verwenden (Default false)
--        HideBorderPins = true,   -- Grenzsteine ausblenden
--        FastForward = false,     -- Beschleunigt abspielen erlauben
--     };
--     local AF = API.AddFlights(Cutscene);
--
--     -- Hier erfolgt die Auflistung der Flights mit AF()
--
--     Cutscene.Starting = function(_Data)
--        -- Hier werden Aktionen vor dem Start ausgeführt.
--     end
--     Cutscene.Finished = function(_Data)
--        -- Hier kann eine abschließende Aktion ausgeführt werden.
--     end
--     return API.StartCutscene(Cutscene);
-- end
--
function API.CutsceneStart(_Cutscene)
    if GUI then
        warn("API.CutsceneStart: Cannot start cutscene from local script!");
        return;
    end

    -- Lokalisierung Texte
    for i= 1, #_Cutscene, 1 do
        if type(_Cutscene[i]) == "table" then
            if _Cutscene[i].Title and type(_Cutscene[i].Title) == "table" then
                _Cutscene[i].Title = API.Localize(_Cutscene[i].Title);
            end
            _Cutscene[i].Title = API.ConvertPlaceholders(_Cutscene[i].Title);

            if _Cutscene[i].Text and type(_Cutscene[i].Text) == "table" then
                _Cutscene[i].Text = API.Localize(_Cutscene[i].Text);
            end
            _Cutscene[i].Text = API.ConvertPlaceholders(_Cutscene[i].Text);

            if _Cutscene[i].Lines then
                for j= 1, #_Cutscene[i].Lines, 1 do
                    if _Cutscene[i].Lines[j].Title and type(_Cutscene[i].Lines[j].Title) == "table" then
                        _Cutscene[i].Lines[j].Title = API.Localize(_Cutscene[i].Lines[j].Title);
                    end
                    _Cutscene[i].Lines[j].Title = API.ConvertPlaceholders(_Cutscene[i].Lines[j].Title);
            
                    if _Cutscene[i].Lines[j].Text and type(_Cutscene[i].Lines[j].Text) == "table" then
                        _Cutscene[i].Lines[j].Text = API.Localize(_Cutscene[i].Lines[j].Text);
                    end
                    _Cutscene[i].Lines[j].Text = API.ConvertPlaceholders(_Cutscene[i].Lines[j].Text);
                end
            end
        end
    end

    return AddOnCutsceneSystem.Global:StartCutscene(_Cutscene);
end
StartCutscene = API.CutsceneStart;

---
-- Prüft, ob zur Zeit eine Cutscene aktiv ist.
-- 
-- <b>Alias</b>: IsCutsceneActive
-- 
-- @return[type=boolean] Kameraflug ist aktiv
-- @within Anwenderfunktionen
--
function API.CutsceneIsActive()
    if GUI then
        return AddOnCutsceneSystem.Local:IsCutsceneActive();
    end
    return AddOnCutsceneSystem.Global:IsCutsceneActive();
end
IsCutsceneActive = API.CutsceneIsActive;

---
-- Ändert den Titel des aktuellen Flight.
-- @param[type=string] _Text Anzeigetext
-- @within Anwenderfunktionen
-- @usage API.PrintCutsceneHeadline("Das ist der neue Titel");
--
function API.PrintCutsceneHeadline(_Text)
    if not API.CutsceneIsActive() then
        return;
    end
    if type(_Text) == "table" then
        _Text = API.Localize(_Text);
    end
    if not GUI then
        Logic.ExecuteInLuaLocalState([[API.PrintCutsceneHeadline("]].._Text..[[")]]);
        return;
    end
    AddOnCutsceneSystem.Local:PrintCutsceneHeadline(_Text);
end

---
-- Ändert den Text des aktuellen Flight.
-- @param[type=string] _Text Anzeigetext
-- @within Anwenderfunktionen
-- @usage API.PrintCutsceneText("Schaut mal, neuer Text! Wie wunderbar!");
--
function API.PrintCutsceneText(_Text)
    if not API.CutsceneIsActive() then
        return;
    end
    if type(_Text) == "table" then
        _Text = API.Localize(_Text);
    end
    if not GUI then
        Logic.ExecuteInLuaLocalState([[API.PrintCutsceneText("]].._Text..[[")]]);
        return;
    end
    AddOnCutsceneSystem.Local:PrintCutsceneText(_Text);
end

---
-- Setzt die Geschwindigkeit für den schnellen Vorlauf für alle Cutscenes.
--
-- Beim schnellen Vorlauf wird der Kameraflug beschleunigt ausgeführt. Die
-- Spielgeschwindigkeit wird dabei auch beschleunigt!
--
-- <b>Alias</b>: SetCutsceneFastForwardSpeed
-- 
-- @param[type=number] _Speed Geschwindigkeit
-- @within Anwenderfunktionen
-- @usage API.CutsceneSetFastForwardSpeed(6);
--
function API.CutsceneSetFastForwardSpeed(_Speed)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.CutsceneSetFastForwardSpeed(" .._Speed.. ")");
        return;
    end
    if type(_Speed) ~= "number" or _Speed < 1 then
        error("API.CutsceneSetFastForwardSpeed: _Speed (" ..tostring(_Speed).. ") is wrong!");
        return;
    end
    AddOnCutsceneSystem.Local.Data.FastForward.Speed = _Speed;
end
SetCutsceneFastForwardSpeed = API.CutsceneSetFastForwardSpeed;

---
-- Erzeugt die Funktionen zur Erstellung von Flights in einer Cutsceme und
-- bindet sie an die Cutscene. Diese Funktion muss vor dem Start einer
-- Cutscene aufgerufen werden um Flights hinzuzufügen.
-- <ul>
-- <li><a href="#AF">AF</a></li>
-- </ul>
--
-- <b>Alias</b>: AddFlights
--
-- @param[type=table] _Cutscene Cutscene Definition
-- @return[type=function] <a href="#AF">AF</a>
-- @within Anwenderfunktionen
--
-- @usage local AF = API.AddFlights(Briefing);
--
function API.AddFlights(_Cutscene)
    if GUI then
        return;
    end
    _Cutscene.GetFlight = function(self, _NameOrID)
        local ID = AddOnCutsceneSystem.Global:GetPageIDByName(_NameOrID);
        return BundleBriefingSystem.Global.Data.CurrentCutscene[ID];
    end
    
    local AF = function(_Flight)
        _Cutscene.Length = (_Cutscene.Length or 0) +1;
        _Flight.__Legit = true;
        table.insert(_Cutscene, _Flight);
        return _Flight;
    end
    return AF;
end
AddFlights = API.AddFlights;

---
-- Erstellt einen Flight für eine Cutscene.
--
-- @param[type=table] _Flight Spezifikation des Flight
-- @return[type=table] Refernez auf den Flight
-- @within Cutscene
-- @usage AF {
--     Flight = "some_file", -- .cs wird nicht mit angegeben!
--     Title  = "Angezeigter Titel",
--     Text   = "Angezeigter Text",
--     Action = function(_Data)
--         -- Aktion für den Flight ausführen
--     end,
-- }
--
function AF(_Flight)
    API.Note("Please use the method provided by API.AddFlights!");
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnCutsceneSystem = {
    Global = {
        Data = {
            CurrentCutscene = {},
            CutsceneQueue = {},
            CutsceneActive = false,
        },
    },
    Local = {
        Data = {
            CurrentCutscene = {},
            CurrentFlight = 1,
            CutsceneActive = false,
            CinematicActive = false,
            FastForward = {
                Active = false,
                Indent = 1,
                Speed = 15,
            },
            Fader = {
                Animation = {},
                From = 1.0,
                To = 0.0,
                TimeStamp = 0,
                Duration = 0,
                Callback = nil,
                Widget = "/InGame/Fader/Element",      
                Page = "/InGame/Fader" 
            }
        },
    },

    Text = {
        FastForwardActivate   = {de = "Beschleunigen", en = "Fast Forward"},
        FastForwardDeactivate = {de = "Zurücksetzen",  en = "Normal Speed"},
        FastFormardMessage    = {de = "SCHNELLER VORLAUF",  en = "FAST FORWARD"},
    }
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global:Install()
end

---
-- Startet die Cutscene im globalen Skript. Es wird eine neue ID für die
-- Cutscene erzeugt und zurückgegeben. Die Cutscehe wird als CurrentCutscene
-- gespeichert und in das lokale Skript kopiert.
--
-- Damit keine Briefings starten, wird die entsprechende Variable im
-- Briefingsystem true gesetzt.
--
-- @param[type=table]   _Cutscene Cutscene table
-- @return[type=number] ID der Cutscene
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global:StartCutscene(_Cutscene, _ID)
    if not _ID then
        BundleBriefingSystem.Global.Data.BriefingID = BundleBriefingSystem.Global.Data.BriefingID +1;
        _ID = BundleBriefingSystem.Global.Data.BriefingID;
    end

    if API.IsLoadscreenVisible() or self:IsCutsceneActive() then
        table.insert(self.Data.CutsceneQueue, {_Cutscene, _ID});
        if not self.Data.CutsceneQueueJobID then
            self.Data.CutsceneQueueJobID = StartSimpleHiResJobEx(AddOnCutsceneSystem.Global.CutsceneQueueController);
        end
        return _ID;
    end
    if _Cutscene.Starting then
        _Cutscene:Starting();
    end
    if not self:AreAllFlightsLegit(_Cutscene) then
        error("API.StartCutscene: Discovered illegaly added flights inside the cutscene!");
        return _ID;
    end

    self.Data.CurrentCutscene = _Cutscene;
    self.Data.CurrentCutscene.ID = BundleBriefingSystem.Global.Data.BriefingID;
    self.Data.CurrentCutscene.BarOpacity = self.Data.CurrentCutscene.BarOpacity or 1;
    self.Data.CurrentCutscene.Length = self.Data.CurrentCutscene.Length or #_Cutscene;
    if self.Data.CurrentCutscene.BigBars == nil then
        self.Data.CurrentCutscene.BigBars = false;
    end
    local Cutscene = API.ConvertTableToString(self.Data.CurrentCutscene);
    Logic.ExecuteInLuaLocalState("AddOnCutsceneSystem.Local:StartCutscene(" ..Cutscene.. ")");
    self.Data.CutsceneActive = true;
    BundleBriefingSystem.Global.Data.BriefingActive = true;
    BundleBriefingSystem.Global.Data.DisplayIngameCutscene = true;

    return BundleBriefingSystem.Global.Data.BriefingID;
end

---
-- Stoppt die Cutscene im globalen Skript. Falls eine Finished-Funktion für
-- die Cutscene definiert ist, wird diese ausgeführt. Wenn weitere Cutscenes
-- in der Warteschlange stehen, wird die nächste Cutscene gestartet. Die
-- aktuelle Cutscene wird als beendet vermerkt.
--
-- Das Starten von Briefings wird wieder erlaubt.
--
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global:StopCutscene()
    BundleBriefingSystem.Global.Data.BriefingActive = false;
    BundleBriefingSystem.Global.Data.DisplayIngameCutscene = false;

    local CutsceneID = self.Data.CurrentCutscene.ID;
    BundleBriefingSystem.Global.Data.FinishedBriefings[CutsceneID] = true;
    Logic.ExecuteInLuaLocalState("AddOnCutsceneSystem.Local:StopCutscene()");

    if self.Data.CurrentCutscene.Finished then
        self.Data.CurrentCutscene:Finished();
    end
    self.Data.CutsceneActive = false;
end

---
-- Gibt die Flight-ID zum angegebenen Flight-Namen zurück.
--
-- Wenn kein Flight gefunden wird, der den angegebenen Namen hat, wird 0
-- zurückgegeben. Wenn eine Flight-ID angegeben wird, wird diese zurückgegeben.
--
-- @param[type=string] _FlightName Name des Flight
-- @return[type=number] ID des Flight
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global:GetPageIDByName(_FlightName)
    if self.Data.CurrentCutscene then
        if type(_FlightName) == "number" then
            return _FlightName;
        end
        for i= 1, self.Data.CurrentCutscene.Length, 1 do
            local Flight = self.Data.CurrentCutscene[i];
            if Flight and type(Flight) == "table" and Flight.Flight == _FlightName then
                return i;
            end
        end
    end
    return 0;
end

function AddOnCutsceneSystem.Global:AreAllFlightsLegit(_Cutscene)
    for i= 1, #_Cutscene, 1 do
        if type(_Cutscene[i]) == "table" then
            if not _Cutscene[i].__Legit then
                return false;
            end
        end
    end
    return true;
end

---
-- Prüft, ob eine Cutscene aktiv ist.
-- @param[type=boolean] Cutscene ist aktiv
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global:IsCutsceneActive()
    return IsBriefingActive() == true or self.Data.CutsceneActive == true;
end

---
-- Steuert die Cutscene-Warteschlange.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global.CutsceneQueueController()
    if #AddOnCutsceneSystem.Global.Data.CutsceneQueue == 0 then
        AddOnCutsceneSystem.Global.Data.CutsceneQueueJobID = nil;
        return true;
    end
    
    if not API.IsLoadscreenVisible() and not AddOnCutsceneSystem.Global:IsCutsceneActive() then
        local Next = table.remove(AddOnCutsceneSystem.Global.Data.CutsceneQueue, 1);
        AddOnCutsceneSystem.Global:StartCutscene(Next[1], Next[2]);
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:Install()
    StartSimpleHiResJobEx(AddOnCutsceneSystem.Local.DisplayFastForwardMessage);

    self:OverrideGameCallbackEscape();
    self:OverrideUpdateFader();
end

---
-- Startet die Cutscene im lokalen Skript. Die Spielansicht wird versteckt
-- und der Cinematic Mode aktiviert.
--
-- @param[type=table] _Cutscene Cutscene table
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:StartCutscene(_Cutscene)
    BundleBriefingSystem.Local.Data.DisplayIngameCutscene = true;

    self.Data.CurrentFlight = 1;
    self.Data.CurrentCutscene = _Cutscene;
    self.Data.CutsceneActive = true;
    
    Display.SetRenderSky(1);
    if self.Data.CurrentCutscene.HideBorderPins then
        Display.SetRenderBorderPins(0);
    end
    if Game.GameTimeGetFactor() ~= 0 then
        if self.Data.CurrentCutscene.RestoreGameSpeed and not self.Data.GaneSpeedBackup then
            self.Data.GaneSpeedBackup = Game.GameTimeGetFactor();
            if self.Data.GaneSpeedBackup < 1 then
                self.Data.GaneSpeedBackup = 1;
            end
        end
        Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
    end
    
    if not self.Data.CinematicActive then
        self:ActivateCinematicMode();
    end

    self:NextFlight();
end

---
-- Stoppt die Cutscene im lokalen Skript. Hier wird der Cinematic Mode
-- deaktiviert und die Spielansicht wiederhergestellt.
--
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:StopCutscene()
    if self.Data.CurrentCutscene.CameraLookAt then 
        Camera.RTS_SetLookAtPosition(unpack(self.Data.CurrentCutscene.CameraLookAt));
    end
    Display.SetRenderBorderPins(1);
    Display.SetRenderSky(0);

    local GameSpeed = (self.Data.GaneSpeedBackup or 1);
    Game.GameTimeSetFactor(GUI.GetPlayerID(), GameSpeed);
    self.Data.GaneSpeedBackup = nil;

    BundleBriefingSystem.Local.Data.DisplayIngameCutscene = false;
    self:DeactivateCinematicMode();
    self.Data.CutsceneActive = false;
    self.Data.FastForward.Active = false;
end

---
-- Prüft, ob eine Cutscene aktiv ist.
--
-- @param[type=boolean] Cutscene ist aktiv
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:IsCutsceneActive()
    return IsBriefingActive() == true or self.Data.CutsceneActive == true;
end

---
-- Springt zum angegebenen Flight der Cutscene.
--
-- @param _NameOrID Flight Name oder ID
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:JumpToFlight(_NameOrID)
    if self.Data.CurrentCutscene then
        if type(_NameOrID) == "string" then
            for i= 1, #self.Data.CurrentCutscene, 1 do
                if self.Data.CurrentCutscene[i] and self.Data.CurrentCutscene[i].Flight == _NameOrID then
                    self.Data.CurrentFlight = i -1;
                    self:FlightFinished();
                    return;
                end
            end
        else
            if self.Data.CurrentCutscene[_NameOrID] then
                self.Data.CurrentFlight = _NameOrID -1;
                self:FlightFinished();
                return;
            end
        end
    end
    -- Im Falle einer Fehleingabe, muss es trotzdem weiter gehen. Darum wird
    -- hier noch mal :FlightFinished aufgerufen.
    self:FlightFinished();
end

---
-- Startet den nächsten Flight.
--
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:NextFlight()
    local FlightIndex = self.Data.CurrentFlight;
    local CurrentFlight = self.Data.CurrentCutscene[FlightIndex];
    if not CurrentFlight then
        return;
    end
    if type(CurrentFlight) ~= "table" then
        self:JumpToFlight(CurrentFlight);
    else
        if Camera.IsValidCutscene(CurrentFlight.Flight) then
            Camera.StartCutscene(CurrentFlight.Flight);
        else
            self:FlightFinished();
        end
    end
end

---
-- Script Event: Flight wurde gestartet.
-- @param[type=number] _Duration Dauer in Turns
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:FlightStarted(_Duration)
    if self:IsCutsceneActive() then
        local FlightIndex = self.Data.CurrentFlight;
        local CurrentFlight = self.Data.CurrentCutscene[FlightIndex];
        if not CurrentFlight then
            return;
        end

        local Flight  = CurrentFlight.Flight;
        local Title   = CurrentFlight.Title or "";
        local Text    = CurrentFlight.Text or "";
        local Action  = CurrentFlight.Action;

        -- Setze Title
        self:PrintCutsceneHeadline(Title);
        -- Setze Text
        self:PrintCutsceneText(Text);
        -- Führe Action aus
        if Action then
            GUI.SendScriptCommand("AddOnCutsceneSystem.Global.Data.CurrentCutscene[" ..FlightIndex.. "]:Action()");
        end

        -- Wechselnder Text eines Flights
        if CurrentFlight.Lines then
            local TextDurationMs = (_Duration *100) / #CurrentFlight.Lines;
            local SwitchTime = 1;
            for i= 1, #CurrentFlight.Lines, 1 do
                StartSimpleHiResJobEx(
                    function(_StartTime, _ExchangeTime, _Title, _Text)
                        if Logic.GetTimeMs() >= _StartTime + _ExchangeTime then
                            AddOnCutsceneSystem.Local:PrintCutsceneHeadline(_Title);
                            AddOnCutsceneSystem.Local:PrintCutsceneText(_Text);
                            return true;
                        end
                    end,
                    Logic.GetTimeMs(),
                    SwitchTime,
                    CurrentFlight.Lines[i].Title or "",
                    CurrentFlight.Lines[i].Text or ""
                );
                SwitchTime = SwitchTime + TextDurationMs;
            end
        end

        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", (self.Data.CurrentCutscene.FastForward and 1) or 0);

        -- Handle fader
        if CurrentFlight.FadeIn then
            self:FadeIn(CurrentFlight.FadeIn);
        end
        if CurrentFlight.FadeOut then
            StartSimpleHiResJobEx(function(_Time, _FadeOut)
                if Logic.GetTimeMs() > _Time - (_FadeOut * 1000) then
                    self:FadeOut(_FadeOut);
                    return true;
                end
            end, Logic.GetTimeMs() + (_Duration*100), CurrentFlight.FadeOut);
        end
    end
end
CutsceneFlightStarted = function(_Duration)
    AddOnCutsceneSystem.Local:FlightStarted(_Duration);
end

---
-- Script Event: Flight ist beendet.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:FlightFinished()
    if self:IsCutsceneActive() then
        local FlightIndex = self.Data.CurrentFlight;
        if FlightIndex == #self.Data.CurrentCutscene then
            GUI.SendScriptCommand("AddOnCutsceneSystem.Global:StopCutscene()");
            return true;
        end
        self.Data.CurrentFlight = self.Data.CurrentFlight +1;
        self:SetFaderAlpha(1);
        self:NextFlight();
    end
end
CutsceneFlightFinished = function()
    AddOnCutsceneSystem.Local:FlightFinished();
end

---
-- Setzt den Titel des aktuellen Flight.
-- @param[type=string] _Text Anzeigetext
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:PrintCutsceneHeadline(_Text)
    _Text = API.ConvertPlaceholders(_Text);
    if string.sub(_Text, 1, 1) ~= "{" then
        _Text = "{@color:255,250,0,255}{center}{darkshadow}" .. _Text;
    end
    XGUIEng.SetText("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", _Text);
end

---
-- Setzt den Text des aktuellen Flight.
-- @param[type=string] _Text Anzeigetext
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:PrintCutsceneText(_Text)
    _Text = API.ConvertPlaceholders(_Text);
    if string.sub(_Text, 1, 1) ~= "{" then
        _Text = "{center}" .. _Text;
    end
    if not self.Data.CurrentCutscene.BigBars then
        _Text = "{cr}{cr}{cr}" .. _Text;
    end
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", _Text);
end

---
-- Steuert die Wiedergabe der Cutscenes.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:ThroneRoomCameraControl()
    if self:IsCutsceneActive() then
        if self.Data.FastForward.Active == false then
            XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..API.Localize(AddOnCutsceneSystem.Text.FastForwardActivate));
        else 
            XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..API.Localize(AddOnCutsceneSystem.Text.FastForwardDeactivate));
        end
    end
end

---
-- Steuert Reaktionen auf Klicks des Spielers.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:ThroneRoomLeftClick()
    if self:IsCutsceneActive() then
        if self.Data.CurrentCutscene.LeftClick then
            self.Data.CurrentCutscene:LeftClick();
        end
    end
end

---
-- Startet oder beendet den schnellen Vorlauf, wenn der Spieler den Skip-Button
-- klickt. Außerdem wird der Text des Skip-Button gesetzt und ein Flag gesetzt.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:NextButtonPressed()
    if self:IsCutsceneActive() then
        if Game.GameTimeGetFactor() > 1 then
            Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
            self.Data.FastForward.Active = false;
        else
            Game.GameTimeSetFactor(GUI.GetPlayerID(), self.Data.FastForward.Speed);
            self.Data.FastForward.Active = true;
        end
    end
end

---
-- Initialisiert den Fader. Bei diesem Fader handelt es sich um eine leicht
-- abgewandelte Version des normalen Fader. Dieser Fader verhält sich relativ
-- zur Spielgeschwindigkeit.
-- @return[type=boolean] Fading läuft gerade
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:InitializeFader()
    self.Data.Fader.Animation = {};
    XGUIEng.PushPage(self.Data.Fader.Page, false);
end

---
-- Prüft, ob gerade ein Fading-Prozess läuft.
-- @return[type=boolean] Fading läuft gerade
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:IsFading()
	return self.Data.CutsceneActive and #self.Data.Fader.Animation > 0;
end

---
-- Blendet zur Fader-Maske aus. Callback wird am Ende ausgeführt.
-- @param[type=number] _Duration Dauer in Sekunden
-- @param[type=number] _Callback (optional) Callback-Funktion
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:FadeOut(_Duration, _Callback)
    table.insert(self.Data.Fader.Animation, {
        From = 0,
        To = 1,
        TimeStamp = Logic.GetTimeMs(),
        Duration = _Duration,
        Callback = _Callback,
    });
end

---
-- Blendet von der Fader-Maske ein. Callback wird am Ende ausgeführt.
-- @param[type=number] _Duration Dauer in Sekunden
-- @param[type=number] _Callback (optional) Callback-Funktion
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:FadeIn(_Duration, _Callback)
    table.insert(self.Data.Fader.Animation, {
        From = 1,
        To = 0,
        TimeStamp = Logic.GetTimeMs(),
        Duration = _Duration,
        Callback = _Callback,
    });
end

---
-- Setzt den Alpha-Wert der Fader-Maske auf den angegebenen Wert.
-- @param[type=number] _Alpha Alpha-Wert
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:SetFaderAlpha(_Alpha)
	if XGUIEng.IsWidgetExisting(self.Data.Fader.Widget) == 0 then
		return;
	end
	XGUIEng.SetMaterialColor(self.Data.Fader.Widget,0,0,0,0,255 * _Alpha);
	XGUIEng.SetMaterialColor(self.Data.Fader.Widget,1,0,0,0,255 * _Alpha);
end

---
-- Berechnet die lineare Interpolation des Alpha der Fader-Maske.
-- @param[type=number] _A Startwert
-- @param[type=number] _B Endwert
-- @param[type=number] _T Zeitfaktor
-- @return[number] Interpolationsfaktor
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:LERP(_A, _B, _T)
    return _A + ((_B - _A) * _T);
end

---
-- Überschreibt das Game Callback Escape, sodass während einer Cutscene nicht
-- abgebrochen werden kann..
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:OverrideGameCallbackEscape()
    AddOnCutsceneSystem.Local.GameCallback_Escape = GameCallback_Escape;
    GameCallback_Escape = function()
        if not AddOnCutsceneSystem.Local:IsCutsceneActive() then
            AddOnCutsceneSystem.Local.GameCallback_Escape();
        end
    end
end

---
-- Überschreibt die Update-Funktion des normalen Fader, sodass während einer
-- Cutscene Spielzeit statt Realzeit verwendet wird.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:OverrideUpdateFader()
    UpdateFader_Orig_CutsceneSystem = UpdateFader;
    UpdateFader = function()
        if AddOnCutsceneSystem.Local.Data.CutsceneActive then
            AddOnCutsceneSystem.Local:UpdateFader();
        else
            UpdateFader_Orig_CutsceneSystem();
        end
    end
end

---
-- Aktualisiert den Alpha-Wert der Fader-Maske, wenn eine Cutscene aktiv ist.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:UpdateFader()
    if self.Data.CutsceneActive == true then
        local Animation = self.Data.Fader.Animation[1];
        if Animation then
            local Time = Logic.GetTimeMs();
            local Progress = (Time - Animation.TimeStamp) / (Animation.Duration * 1000);
            local Alpha = self:LERP(Animation.From, Animation.To, Progress);
            self:SetFaderAlpha(Alpha);
            if Time >= Animation.TimeStamp + (Animation.Duration * 1000)  then
                if Animation.Callback ~= nil then
                    Animation:Callback();
                end
                table.remove(self.Data.Fader.Animation, 1);
            end
        else
            self:SetFaderAlpha(0);
        end
    end
end

---
-- Aktiviert den Cinematic Mode. Alle selektierten Entities werden gespeichert
-- und anschließend deselektiert. Optional wird die Kameraposition und die
-- Spielgeschwindigkeit ebenfalls gespeichert.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:ActivateCinematicMode()
    self.Data.CinematicActive = true;
    
    local LoadScreenVisible = API.IsLoadscreenVisible();
    if LoadScreenVisible then
        XGUIEng.PopPage();
    end

    Core:InterfaceDeactivateNormalInterface();
    Core:InterfaceDeactivateBlackBackground();

    local ScreenX, ScreenY = GUI.GetScreenSize();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);

    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65 * (ScreenY/1080));

    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Objectives", 2, 0, 2000, 20);
    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false);
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/Text", 1);
    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", " ");
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Text", 200, 300, 1000, 10);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame", 1);
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo/LeftFrame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/KnightBG", 1);
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 6000, 400, 600);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 0);

    BundleBriefingSystem.Local:SetBarStyle(self.Data.CurrentCutscene.BarOpacity, self.Data.CurrentCutscene.BigBars);

    if not self.Data.SkipButtonTextBackup then
        self.Data.SkipButtonTextBackup = XGUIEng.GetText("/InGame/ThroneRoom/Main/Skip");
    end

    GUI.ClearSelection();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    Display.SetRenderFogOfWar(0);
    Display.SetUserOptionOcclusionEffect(0);
    Camera.SwitchCameraBehaviour(0);

    self:InitializeFader();
    self:SetFaderAlpha(0);

    if LoadScreenVisible then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
end

---
-- Stoppt den Cinematic Mode. Die Selektion wird wiederhergestellt. Falls
-- aktiviert, werden auch Kameraposition und Spielgeschwindigkeit auf ihre
-- alten Werte zurückgesetzt.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:DeactivateCinematicMode()
    self.Data.CinematicActive = false;

    if not self.Data.SkipButtonTextBackup then
        XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", self.Data.SkipButtonTextBackup);
        self.Data.SkipButtonTextBackup =  nil;
    end

    self.Data.Fader.To = 0;
    self:SetFaderAlpha(0);

    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    Display.SetRenderFogOfWar(1);
    if Options.GetIntValue("Display", "Occlusion", 0) > 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    Core:InterfaceActivateNormalInterface();
    Core:InterfaceDeactivateBlackBackground();
end

---
-- Steuert die Nachricht bei aktiven schnellen Vorlauf von Cutscenes.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local.DisplayFastForwardMessage()
    if AddOnCutsceneSystem.Local.Data.CutsceneActive == true then
        if AddOnCutsceneSystem.Local.Data.FastForward.Active then
            -- Realzeit ermitteln
            local RealTime = API.RealTimeGetSecondsPassedSinceGameStart();
            if not AddOnCutsceneSystem.Local.Data.FastForward.RealTime then
                AddOnCutsceneSystem.Local.Data.FastForward.RealTime = RealTime;
            end
            -- Einrückung anpassen
            if AddOnCutsceneSystem.Local.Data.FastForward.RealTime < RealTime then
                AddOnCutsceneSystem.Local.Data.FastForward.Indent = AddOnCutsceneSystem.Local.Data.FastForward.Indent +1;
                if AddOnCutsceneSystem.Local.Data.FastForward.Indent > 4 then
                    AddOnCutsceneSystem.Local.Data.FastForward.Indent = 1;
                end
                AddOnCutsceneSystem.Local.Data.FastForward.RealTime = RealTime;
            end
            -- Message anzeigen
            local Text = "{cr}{cr}" ..API.Localize(AddOnCutsceneSystem.Text.FastFormardMessage);
            local Indent = string.rep("  ", AddOnCutsceneSystem.Local.Data.FastForward.Indent);
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", Text..Indent.. ". . .");
        else
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("AddOnCutsceneSystem");
 
-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnGraphVizIntegration                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht es die erstellten Quests als Diagramm darzustellen.
--
-- Das Diagramm wird in einer bestimmten Notation ins Log geschrieben. Diese
-- Notation heißt DOT. Um daraus ein Diagramm zu generieren, musst du
-- GraphViz installieren.
--
-- <h4>Installation von GraphViz</h4>
-- Befolge folgende Schritte, um GraphViz zu installieren:
-- <ol>
-- <li>
-- Lade die Release-Version von GraphViz für Windows 10 herunter.<br/>
-- <a target="_blank" href="https://www2.graphviz.org/Packages/stable/windows/10/msbuild/Release/Win32/">Download</a>
-- </li>
-- <li>
-- Entpacke den Ordner im Archiv in das Programmverzeichnis. Es existiert
-- dann folgendes Verzeichnis:
-- <pre>C:/Programme/GraphViz</pre>
-- </li>
-- <li>
-- Erweitere die PATH Variable um Folgenden Eintrag:
-- <pre>C:/Programme/GraphViz/bin</pre>
-- Starte deinen Rechner neu. Das ist nötig, damit die Änderung an PATH
-- wirksam wird.
-- </li>
-- <li>
-- Teste die Installation in der Eingabeaufforderung.
-- <pre>dot -v</pre>
-- Du solltes u.a. eine Version angezeigt bekommen.
-- <pre>dot - graphviz version 2.44.1 (20200629.0800)
--...</pre>
-- Drücke STRG + C um das Programm zu beenden.
-- </li>
-- </ol>
--
-- <h4>Diagramm mit GraphViz erzeugen</h4>
-- <ol>
-- <li>
-- Lasse zu einen beliebigen Zeitpunkt die Quests umwandeln.<br/>Siehe dazu
-- <a href="#API.ExportQuestsForGraphViz">API.ExportQuestsForGraphViz</a>.
-- </li>
-- <li>
-- Öffne nun die Log-Datei. Die Logs befinden sich in folgendem Verzeichnis:
-- <pre>C:\Users\BENUTZERNAME\Documents\DIE SIEDLER - Aufstieg eines Königreichs\Temp\Logs</pre>
-- </li>
-- <li>
-- Suche im Log nach GraphViz Export. Kopiere den "kryptischen Buchstabensalat"
-- innerhalb des markierten Bereichs in eine Datei (z.B. quests.dot).
-- Ein Log-Eintrag kann so aussehen:
-- <pre>==== GraphViz Export Start ====
--
-- digraph G { graph [    fontname = &quot;Helvetica-Oblique&quot;, fontsize = 30, label = &quot;total_awesome_map&quot; ] 
-- node [ fontname = &quot;Courier-Bold&quot; shape = &quot;box&quot; ] 
--     &quot;TestQuest_0&quot; [  label = &quot;TestQuest_0\n=== 2  -&gt;  1 ===\n\nGoal_InstantSuccess()\nTrigger_Time(5)&quot; ] 
--     &quot;TestQuest_0&quot; -&gt; &quot;TestQuest_1&quot; [color=&quot;#00ff00&quot;] 
--     &quot;TestQuest_1&quot; [  label = &quot;TestQuest_1\n=== 2  -&gt;  1 ===\n\nGoal_InstantSuccess()\nTrigger_OnQuestSuccessWait('TestQuest_0', 5)&quot; ] 
--     &quot;TestQuest_1&quot; -&gt; &quot;TestQuest_2&quot; [color=&quot;#00ff00&quot;] 
--     &quot;TestQuest_2&quot; [  label = &quot;TestQuest_2\n=== 2  -&gt;  1 ===\n\nGoal_InstantSuccess()\nTrigger_OnQuestSuccessWait('TestQuest_1', 5)&quot; ] 
--     &quot;TestQuest_2&quot; -&gt; &quot;TestQuest_3&quot; [color=&quot;#00ff00&quot;] 
--     &quot;TestQuest_3&quot; [  label = &quot;TestQuest_3\n=== 2  -&gt;  1 ===\n\nGoal_InstantSuccess()\nTrigger_OnQuestSuccessWait('TestQuest_2', 5)&quot; ] 
--     &quot;TestQuest_3&quot; -&gt; &quot;TestQuest_4&quot; [color=&quot;#00ff00&quot;] 
--     &quot;TestQuest_4&quot; [  label = &quot;TestQuest_4\n=== 2  -&gt;  1 ===\n\nGoal_InstantSuccess()\nTrigger_OnQuestSuccessWait('TestQuest_3', 5)&quot; ] 
--     &quot;TestQuest_4&quot; -&gt; &quot;TestQuest_5&quot; [color=&quot;#00ff00&quot;] 
--     &quot;TestQuest_5&quot; [  label = &quot;TestQuest_5\n=== 2  -&gt;  1 ===\n\nGoal_InstantSuccess()\nTrigger_OnQuestSuccessWait('TestQuest_4', 5)&quot; ]
-- } 
--
-- ==== GraphViz Export Ende ====</pre>
-- </li>
-- <li>
-- Führe folgenden Befehl zur Erzeugung des Diagrams in der Eingabeaufforderung
-- aus:
-- <pre>dot -Tjpg quests.dot > quests.jpg</pre>
-- Du solltest nun ein JPG im gleichen Verzeichnis vorfinden.
-- </li>
-- </ol>
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnGraphVizIntegration = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erzeugt aus allen Quests die DOT-Notation und schreibt sie ins Log. Aus
-- dem erzeugten Code können mit GraphViz Diagramme erstellt werden.
--
-- @param[type=boolean] _UseBreak Break in LuaDebugger auslösen
--
function API.ExportQuestsForGraphViz(_UseBreak)
    local DOT = AddOnGraphVizIntegration.Global:ExecuteGraphVizExport();
    -- Im LuaDebugger kann man das Diagramm dann aus der Variable kopieren.
    -- Alle anderen müssen ins Log gucken.
    if LuaDebugger and _UseBreak then
        LuaDebugger.Break();
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnGraphVizIntegration = {
    Global =  {
        Data = {},
    },
    Local =  {
        Data = {},
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function AddOnGraphVizIntegration.Global:Install()
    QSB.GraphViz:Init();
end

---
-- Erstellt ein Diagramm und speichert es im Log File.
--
-- <b>Hinweis</b>: Das Diagramm ist in DOT geschrieben. Um daraus ein Diagramm
-- zu erzeugen, wird eine GraphViz installation benötigt.
-- 
-- @return[type=string] DOT-Notation
-- @within Internal
-- @local
--
function AddOnGraphVizIntegration.Global:ExecuteGraphVizExport()
    Framework.WriteToLog("\n\n\n==== GraphViz Export Start ====\n\n\n");
    local DOT = QSB.GraphViz:ConvertQuests();
    AddOnGraphVizIntegration.Global:WriteLinewiseToLog(DOT);
    Framework.WriteToLog("\n\n\n==== GraphViz Export Ende ====\n\n\n");
    return DOT;
end

---
-- Schreibt den übergebenen String zeilenweise ins Log. Eine Zeile wird durch
-- \n abgeschlossen.
-- 
-- @param[type=string] _String Log-Eintrag
-- @within Internal
-- @local
--
function AddOnGraphVizIntegration.Global:WriteLinewiseToLog(_String)
    local Slices = self:SplitString(_String);
    for i= 1, #Slices, 1 do
        Framework.WriteToLog(Slices[i]);
    end
end

---
-- Teilt einen String in Zeilen ein. Eine Zeile wird durch \n abgeschlossen.
-- 
-- @param[type=string] _String Log-Eintrag
-- @return[type=table] In Zeilen geteilter String
-- @within Internal
-- @local
--
function AddOnGraphVizIntegration.Global:SplitString(_String)
    local Table = {};
    local s, e = _String:find("\n");
    while e do
        table.insert(Table, _String:sub(1, e-1));
        _String = _String:sub(e+1);
        s, e = _String:find("\n");
    end
    table.insert(Table, _String);
    return Table;
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function AddOnGraphVizIntegration.Local:Install()
    -- Im lokalen Skript invalidieren, um Speicher zu sparen.
    QSB.GraphViz = nil;
end

-- -------------------------------------------------------------------------- --

QSB.GraphViz = {
    SourceFile = "",
    Quests = {}
}

---
-- Initialisiert den DOT-Parser. 
--
-- @within Internal
-- @local
--
function QSB.GraphViz:Init()
    API = API or {};
    CreateQuest_Orig_AddOnGraphVizIntegration = API.CreateQuest;
    API.CreateQuest = function(_Data)
        local QuestName, QuestAmount = CreateQuest_Orig_AddOnGraphVizIntegration(_Data);
        local Data = QSB.GraphViz:AddQuestDefaults(API.InstanceTable(_Data));
        QSB.GraphViz.Quests[#QSB.GraphViz.Quests+1] = Data;
        return QuestName, QuestAmount;
    end
    AddQuest = API.CreateQuest;
end

---
-- Ergänzt die Questdaten um Defaultwerte.
--
-- @param[type=table] _Data Questdaten
-- @return[type=table] Questdaten um Defaults ergänzt
-- @within Internal
-- @local
--
function QSB.GraphViz:AddQuestDefaults(_Data)
    _Data.Sender        = _Data.Sender or 1;
    _Data.Receiver      = _Data.Receiver or 1;
    _Data.Time          = _Data.Time or 0;
    _Data.Visible       = (_Data.Visible == true or _Data.Suggestion ~= nil);
    _Data.EndMessage    = _Data.EndMessage == true or (_Data.Failure ~= nil or _Data.Success ~= nil);
    if _Data.Suggestion then
        _Data.Suggestion = API.Localize(_Data.Suggestion);
    end
    if _Data.Success then
        _Data.Success = API.Localize(_Data.Success);
    end
    if _Data.Failure then
        _Data.Failure = API.Localize(_Data.Failure);
    end
    if _Data.Description then
        _Data.Description = API.Localize(_Data.Description);
    end
    return _Data;
end

---
-- Erzeugt einen Graph aus allen vorhandenen Quests.
--
-- @return[type=string] GraphViz Output
-- @within Internal
-- @local
--
function QSB.GraphViz:ConvertQuests()
    local MapName = Framework.GetCurrentMapName();
    local DOT = "";
    DOT = DOT .. '\ndigraph G { graph [    fontname = "Helvetica-Oblique", fontsize = 30, label = "'..MapName.. '" ] \nnode [ fontname = "Courier-Bold" shape = "box" ] \n';
    for i= 1, #QSB.GraphViz.Quests, 1 do
        for k, v in pairs(QSB.GraphViz:ConvertQuest(QSB.GraphViz.Quests[i])) do 
            DOT = DOT .. "    " .. v .. " \n";
        end
    end
    DOT = DOT .. '} \n';
    return DOT;
end

---
-- Erzeug DOT-Notation zum übergebenen Quest.
--
-- <b>TODO</b>: Diese Methode ist absolut grottiger Code aus tiefster
-- Siedler-6-Urzeit. Das muss unbedingt mal auseinander gezogen und in
-- guter Code Qualität neu geschrieben werden!
--
-- @param[type=table] _Quest Zu visualisierender Quest
-- @return[type=string] GraphViz Output
-- @within Internal
-- @local
--
function QSB.GraphViz:ConvertQuest(_Quest)
    local result = {};
    local ArrowColorTable = {
        Succeed = 'color="#00ff00"',
        Fail = 'color="#ff0000"',
        Interrupt = 'color="#999999"',
        Default = 'color="#0000ff"'
    };
    local function EscapeString( _String )
        return string.match( string.format( "%q", tostring(_String) ), '^"(.*)"$' ) or "nil";
    end
    local function LimitString( _String, _Limit )
        assert( _String );
        assert( _Limit > 3 );
        if string.len( _String ) <= _Limit then
            return _String;
        else
            return string.sub( _String, 1, _Limit - 3 ) .. "...";
        end
    end

    local fontColor = ""
    local BehaviorList = {}
    local bTableCounter = 0    
    for i= 1, #_Quest, 1 do
        local BehaviorName = _Quest[i].Name;
        local ArrowColor = (string.find( BehaviorName, "Succe" ) and ArrowColorTable.Succeed)
                or (string.find( BehaviorName, "Fail" )and ArrowColorTable.Fail)
                or (string.find( BehaviorName, "Interrupt" )and ArrowColorTable.Interrupt)
                or ArrowColorTable.Default;
        local fontColor = (string.find( BehaviorName, "Wait" ) and 'fontcolor="red"') or "";
        local BDependsOn = string.find(BehaviorName, "Goal") ~= nil or string.find(BehaviorName, "Trigger") ~= nil;

        local BehaviorData = _Quest[i].Name .. "(";
        if _Quest[i].Parameter then
            for j= 1, #_Quest[i].Parameter do
                if (j > 1) then
                    BehaviorData = BehaviorData .. ", ";
                end
                local Parameter = "nil";
                if _Quest[i].v12ya_gg56h_al125[j] then
                    Parameter =_Quest[i].v12ya_gg56h_al125[j];
                    if type(Parameter) == "string" then
                        Parameter = "'" ..Parameter.. "'";
                    end
                end
                BehaviorData = BehaviorData .. tostring(Parameter);
                
                if (_Quest[i].Parameter[j][1] == ParameterType.QuestName) then
                    table.insert(
                        result,
                        (BDependsOn and string.format(
                            '%q -> %q [%s]',
                            _Quest[i].v12ya_gg56h_al125[j],
                            _Quest.Name,
                            ArrowColor
                        )) or 
                        string.format(
                            '%q -> %q [%s, arrowhead = "odot", arrowtail = "invempty" style="dashed"]',
                            _Quest.Name,
                            _Quest[i].QuestName,
                            ArrowColor
                        )
                    );
                end
            end
        end
        BehaviorData = BehaviorData .. ")";
        table.insert(BehaviorList, BehaviorData);
    end

    local Desc = EscapeString(LimitString(_Quest.Description or "", 80));
    Desc = (Desc ~= "" and "\\nDescription: '" ..Desc.. "'") or "";
    local Sugg = EscapeString(LimitString(_Quest.Suggestion or "", 80));
    Sugg = (Sugg ~= "" and "\\nSuggestion: '" ..Sugg.. "'") or "";
    local Fail = EscapeString(LimitString(_Quest.Failure or "", 80));
    Fail = (Fail ~= "" and "\\nFailure: '" ..Fail.. "'") or "";
    local Succ = EscapeString(LimitString(_Quest.Success or "", 80));
    Succ = (Succ ~= "" and "\\nSuccess: '" ..Succ.. "'") or "";

    local SenderReceiver = "\\n=== " .._Quest.Sender.."  ->  " .._Quest.Receiver.. " ===";
    table.sort(BehaviorList);
    table.insert(result, string.format(
        '%q [ %s label = "%s%s%s%s%s%s%s\\n\\n%s" %s%s]',
        _Quest.Name,
        fontColor,
        EscapeString(_Quest.Name),
        SenderReceiver,
        Sugg,
        Fail,
        Succ,
        Desc,
        _Quest.Time ~= 0 and ('\\nTime: ' .. _Quest.Time) or '',
        table.concat(BehaviorList, "\\n"),
        _Quest.Time ~= 0 and 'shape="octagon" ' or '',
        not _Quest.Visible and 'style="filled" fillcolor="#dddddd" ' or '' )
    );
    return result;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("AddOnGraphVizIntegration");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnInteractiveChests                                       # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Es werden Schatztruhen mit zufälligem Inhalt erzeugt. Diese Truhen werden
-- aktiviert und der Inhalt wird in einem Karren abtransportiert.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnInteractiveChests = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Waren
-- des angegebenen Typs.
--
-- Die Menge der Ware ist dabei zufällig und liegt zwischen dem Minimalwert
-- und dem Maximalwert. Optional kann eine Funktion angegeben werden, die
-- ausgeführt wird, wenn die Truhe geöffnet wird. Diese Funktion verhält sich
-- wie das Callback eines interaktiven Objektes.
--
-- <p><b>Alias</b>: CreateRandomChest</p>
--
-- @param[type=string]   _Name Name der zu ersetzenden Script Entity
-- @param[type=number]   _Good Warentyp
-- @param[type=number]   _Min Mindestmenge
-- @param[type=number]   _Max Maximalmenge
-- @param[type=function] _Callback Callback-Funktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateRandomChest("chest", Goods.G_Gems, 100, 300, OnChestOpened)
--
function API.CreateRandomChest(_Name, _Good, _Min, _Max, _Callback)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateRandomChest: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    if GetNameOfKeyInTable(Goods, _Good) == nil then
        error("API.CreateRandomChest: _Good (" ..tostring(_Good).. ") is wrong!");
        return;
    end
    if type(_Min) ~= "number" or _Min < 1 then
        error("API.CreateRandomChest: _Min (" ..tostring(_Min).. ") is wrong!");
        return;
    end

    if type(_Max) ~= "number" then
        if not _Callback and type(_Max) == "function" then
            _Callback = _Max;
        end
        _Max = _Min;
    else
        if type(_Max) ~= "number" or _Max < 1 then
            error("API.CreateRandomChest: _Max (" ..tostring(_Max).. ") is wrong!");
            return;
        end
        if _Max < _Min then
            error("API.CreateRandomChest: _Max (" ..tostring(_Max).. ") must be greather then _Min (" ..tostring(_Min).. ")!");
            return;
        end
    end
    AddOnInteractiveChests.Global:CreateRandomChest(_Name, _Good, _Min, _Max, _Callback);
end
CreateRandomChest = API.CreateRandomChest;

---
-- Erstellt ein beliebiges IO mit einer zufälligen Menge an Waren
-- des angegebenen Typs.
--
-- Die Menge der Ware ist dabei zufällig und liegt zwischen dem Minimalwert
-- und dem Maximalwert. Optional kann eine Funktion angegeben werden, die
-- ausgeführt wird, wenn der Schatz gefunden wird. Diese Funktion verhält sich
-- wie das Callback eines interaktiven Objektes.
--
-- <p><b>Alias</b>: CreateRandomTreasure</p>
--
-- @param[type=string]   _Name Name des Script Entity
-- @param[type=number]   _Good Warentyp
-- @param[type=number]   _Min Mindestmenge
-- @param[type=number]   _Max Maximalmenge
-- @param[type=function] _Callback Callback-Funktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateRandomTreasure("well1", Goods.G_Gems, 100, 300, OnTreasureDiscovered)
--
function API.CreateRandomTreasure(_Name, _Good, _Min, _Max, _Callback)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateRandomTreasure: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    if GetNameOfKeyInTable(Goods, _Good) == nil then
        error("API.CreateRandomTreasure: _Good (" ..tostring(_Good).. ") is wrong!");
        return;
    end
    if type(_Min) ~= "number" or _Min < 1 then
        error("API.CreateRandomTreasure: _Min (" ..tostring(_Min).. ") is wrong!");
        return;
    end

    if type(_Max) ~= "number" then
        if not _Callback and type(_Max) == "function" then
            _Callback = _Max;
        end
        _Max = _Min;
    else
        if type(_Max) ~= "number" or _Max < 1 then
            error("API.CreateRandomTreasure: _Max (" ..tostring(_Max).. ") is wrong!");
            return;
        end
        if _Max < _Min then
            error("API.CreateRandomTreasure: _Max (" ..tostring(_Max).. ") must be greather then _Min (" ..tostring(_Min).. ")!");
            return;
        end
    end
    AddOnInteractiveChests.Global:CreateRandomChest(_Name, _Good, _Min, _Max, _Callback, true);
end
CreateRandomTreasure = API.CreateRandomTreasure;

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge Gold.
--
-- <p><b>Alias</b>: CreateRandomGoldChest</p>
--
-- @param[type=string] _Name Name der zu ersetzenden Script Entity
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateRandomGoldChest("chest")
--
function API.CreateRandomGoldChest(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateRandomGoldChest: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    AddOnInteractiveChests.Global:CreateRandomChest(_Name, Goods.G_Gold, 300, 600);
end
CreateRandomGoldChest = API.CreateRandomGoldChest;

---
-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge
-- an Gütern.
--
-- Güter können seien: Eisen, Fisch, Fleisch, Getreide, Holz,
-- Honig, Kräuter, Milch, Stein, Wolle.
--
-- <p><b>Alias</b>: CreateRandomResourceChest</p>
--
-- @param[type=string] _Name Name der zu ersetzenden Script Entity
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateRandomResourceChest("chest")
--
function API.CreateRandomResourceChest(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateRandomResourceChest: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    AddOnInteractiveChests.Global:CreateRandomResourceChest(_Name);
end
CreateRandomResourceChest = API.CreateRandomResourceChest;

---
-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge
-- an Luxusgütern.
--
-- Luxusgüter können seien: Edelsteine, Farben, Musikinstrumente
-- Salz oder Weihrauch.
--
-- <p><b>Alias</b>: CreateRandomLuxuryChest</p>
--
-- @param[type=string] _Name Name der zu ersetzenden Script Entity
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateRandomLuxuryChest("chest")
--
function API.CreateRandomLuxuryChest(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateRandomLuxuryChest: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    AddOnInteractiveChests.Global:CreateRandomLuxuryChest(_Name);
end
CreateRandomLuxuryChest = API.CreateRandomLuxuryChest;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnInteractiveChests = {
    Global = {
        Data = {
            Chests = {},
        }
    },

    Text = {
        Chest = {
            Title = {
                de = "Schatztruhe",
                en = "Treasure Chest",
            },
            Text = {
                de = "Diese Truhe enthält einen geheimen Schatz. Öffnet sie um den Schatz zu bergen.",
                en = "This chest contains a secred treasure. Open it to salvage the treasure.",
            },
        },
        Treasure = {
            Title = {
                de = "Versteckter Schatz",
                en = "Hidden treasure",
            },
            Text = {
                de = "Ihr habt einen geheimen Schatz entdeckt. Beeilt Euch und beansprucht ihn für Euch!",
                en = "You have discovered a secred treasure. Be quick to claim it, before it is to late!",
            },
        }
    }
}

-- Global ----------------------------------------------------------------------

---
-- Initalisiert das AddOn.
-- @within Internal
-- @local
--
function AddOnInteractiveChests.Global:Install()
end

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Waren
-- des angegebenen Typs.
--
-- Optional kann die automatische Umwandlung in eine Schatztruhe abgeschaltet
-- werden. Vorsichtig mit überbaubaren Entities!
--
-- @param _Name [string] Name der zu ersetzenden Script Entity
-- @param _Good [number] Warentyp
-- @param _Min [number] Mindestmenge
-- @param _Max [number] Maximalmenge
-- @param _Callback [function] Callback-Funktion
-- @param _NoModelChange [boolean] Kein Truhenmodel setzen
-- @within Internal
-- @local
--
function AddOnInteractiveChests.Global:CreateRandomChest(_Name, _Good, _Min, _Max, _Callback, _NoModelChange)
    _Min = math.floor((_Min ~= nil and _Min > 0 and _Min) or 1);
    _Max = math.floor((_Max ~= nil and _Max > 1 and _Max) or 2);
    if not _Callback then
        _Callback = function(t) end
    end
    assert(_Good ~= nil, "CreateRandomChest: Good does not exist!");
    assert(_Min <= _Max, "CreateRandomChest: min amount must be smaller or equal than max amount!");

    -- Debug Informationen schreiben
    debug(string.format(
        "AddOnInteractiveChests: Creating chest (%s, %s, %d, %d, %s, %s)",
        _Name,
        Logic.GetGoodTypeName(_Good),
        _Min,
        _Max,
        tostring(_Callback),
        tostring(_NoModelChange)
    ))

    -- Texte und Model setzen
    local Title = AddOnInteractiveChests.Text.Treasure.Title;
    local Text  = AddOnInteractiveChests.Text.Treasure.Text;
    if not _NoModelChange then
        Title = AddOnInteractiveChests.Text.Chest.Title;
        Text  = AddOnInteractiveChests.Text.Chest.Text;

        local eID = ReplaceEntity(_Name, Entities.XD_ScriptEntity, 0);
        Logic.SetModel(eID, Models.Doodads_D_X_ChestClose);
        Logic.SetVisible(eID, true);
    end

    -- Menge an Gütern ermitteln
    local GoodAmount = _Min;
    if _Min < _Max then
        GoodAmount = math.random(_Min, _Max);
    end

    CreateObject {
        Name                    = _Name,
        Title                   = Title,
        Text                    = Text,
        Reward                  = {_Good, GoodAmount},
        Texture                 = {1, 6},
        Distance                = (_NoModelChange and 1200) or 650,
        Waittime                = 0,
        State                   = 0,
        DoNotChangeModel        = _NoModelChange == true,
        CallbackOpened          = _Callback,
        Callback                = function(_IO, _PlayerID, _Data)
            if not _Data.DoNotChangeModel then
                Logic.SetModel(GetID(_Data.Name), Models.Doodads_D_X_ChestOpenEmpty);
            end
            _Data.CallbackOpened(_Data);
        end,
    };
end

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Gold
-- des angegebenen Typs.
--
-- @param _Name [string] Name der zu ersetzenden Script Entity
-- @within Internal
-- @local
--
function AddOnInteractiveChests.Global:CreateRandomGoldChest(_Name)
    AddOnInteractiveChests.Global:CreateRandomChest(_Name, Goods.G_Gold, 300, 600);
end

---
-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge
-- an Gütern.
-- Güter können seien: Eisen, Fisch, Fleisch, Getreide, Holz,
-- Honig, Kräuter, Milch, Stein, Wolle.
--
-- @param _Name [string] Name der zu ersetzenden Script Entity
-- @within Internal
-- @local
--
function AddOnInteractiveChests.Global:CreateRandomResourceChest(_Name)
    local PossibleGoods = {
        Goods.G_Iron, Goods.G_Stone, Goods.G_Wood, Goods.G_Wool,
        Goods.G_Carcass, Goods.G_Herb, Goods.G_Honeycomb,
        Goods.G_Milk, Goods.G_RawFish, Goods.G_Grain
    };
    local Good = PossibleGoods[math.random(1, #PossibleGoods)];
    AddOnInteractiveChests.Global:CreateRandomChest(_Name, Good, 30, 60);
end

---
-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge
-- an Luxusgütern.
-- Luxusgüter können seien: Edelsteine, Farben, Musikinstrumente
-- Salz oder Weihrauch.
--
-- @param _Name [string] Name der zu ersetzenden Script Entity
-- @within Internal
-- @local
--
function AddOnInteractiveChests.Global:CreateRandomLuxuryChest(_Name)
    local Luxury = {Goods.G_Salt, Goods.G_Dye};
    if g_GameExtraNo >= 1 then
        table.insert(Luxury, Goods.G_Gems);
        table.insert(Luxury, Goods.G_MusicalInstrument);
        table.insert(Luxury, Goods.G_Olibanum);
    end
    local Good = Luxury[math.random(1, #Luxury)];
    AddOnInteractiveChests.Global:CreateRandomChest(_Name, Good, 50, 100);
end

-- -------------------------------------------------------------------------- --

Core:RegisterAddOn("AddOnInteractiveChests");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnInteractiveMines                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Der Spieler kann eine Stein- oder Eisenmine erzeugen, die zuerst durch
-- Begleichen der Kosten aufgebaut werden muss, bevor sie genutzt werden kann.
-- <br>Optional kann die Mine einstürzen, wenn sie erschöpft wurde.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnInteractiveMines = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstelle eine verschüttete Mine eines bestimmten Typs. Es können zudem eine
-- Bedingung und zwei verschiedene Callbacks vereinbart werden.
--
-- Minen können als "nicht auffüllbar" markiert werden. In diesem Fall werden
-- sie zusammenstützen, sobald die Rohstoffe verbraucht sind.
--
-- Verschüttete Minen können durch einen Helden in normale Minen umgewandelt
-- werden. FÜr diese Umwandlung können Kosten anfallen, müssen aber nicht. Es
-- dürfen immer maximal 2 Waren als Kosten verwendet werden.
--
-- Es können weitere Funktionen hinzugefügt werden, um die Mine anzupassen:
-- <ul>
-- <li><u>Bedingung:</u> Eine Funktion, die true oder false zurückgeben muss.
-- Mit dieser Funktion wird bestimmt, ob die Mine gebaut werden darf.</li>
-- <li><u>Callback Aktivierung:</u> Eine Funktion, die ausgeführt wird, wenn
-- die Mine erfolgreich aktiviert wurde (evtl. Kosten bezahlt und/oder
-- Bedingung erfüllt).</li>
-- <li><u>Callback Erschöpft:</u> Eine Funktion, die ausgeführt wird, sobald
-- die Rohstoffe der Mine erschöpft sind.</li>
-- </ul>
--
-- <p><b>Alias</b>: CreateIOMine</p>
--
-- @param[type=string]   _Position         Script Entity, die mit Mine ersetzt wird
-- @param[type=number]   _Type             Typ der Mine
-- @param[type=table]    _Costs            (optional) Kostentabelle
-- @param[type=boolean]  _NotRefillable    (optional) Die Mine wird weiterhin überwacht
-- @param[type=function] _Condition        (optional) Bedingungsfunktion
-- @param[type=function] _CreationCallback (optional) Funktion nach Kauf ausführen
-- @param[type=function] _CallbackDepleted (optional) Funktion nach Ausbeutung ausführen
-- @within Anwenderfunktionen
--
-- @usage
-- -- Beispiel für eine Mine
-- API.CreateIOMine("mine", Entities.B_IronMine, {Goods.G_Wood, 20}, true)
-- -- Die Mine kann für 20 Holz erschlossen werden. Sobald die Rohstoffe
-- -- erschöpft sind, stürzt die Mine zusammen.
--
function API.CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted)
    if GUI then
        return;
    end
    if not IsExisting(_Position) then
        error("API.CreateIOMine: _Position (" ..tostring(_Position).. ") does not exist!");
        return;
    end
    if GetNameOfKeyInTable(Entities, _Type) == nil then
        error("API.CreateIOMine: _Type (" ..tostring(_Type).. ") is wrong!");
        return;
    end
    if _Costs and (type(_Costs) ~= "table" or #_Costs %2 ~= 0) then
        error("API.CreateIOMine: _Costs has the wrong format!");
        return;
    end
    if _Condition and type(_Condition) ~= "function" then
        error("API.CreateIOMine: _Condition must be a function!");
        return;
    end
    if _CreationCallback and type(_CreationCallback) ~= "function" then
        error("API.CreateIOMine: _CreationCallback must be a function!");
        return;
    end
    if _CallbackDepleted and type(_CallbackDepleted) ~= "function" then
        error("API.CreateIOMine: _CallbackDepleted must be a function!");
        return;
    end
    AddOnInteractiveMines.Global:CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted);
end
CreateIOMine = API.CreateIOMine;

---
-- Erstelle eine verschüttete Eisenmine.
--
-- <p><b>Alias</b>: CreateIOIronMine</p>
--
-- @param[type=string]  _Position      Script Entity, die mit Mine ersetzt wird
-- @param[type=number]  _Cost1Type     (optional) Kostenware 1
-- @param[type=number]  _Cost1Amount   (optional) Kostenmenge 1
-- @param[type=number]  _Cost2Type     (optional) Kostenware 2
-- @param[type=number]  _Cost2Amount   (optional) Kostenmenge 2
-- @param[type=boolean] _NotRefillable (optional) Mine wird nach Ausbeutung zerstört
-- @within Anwenderfunktionen
-- @see API.CreateIOMine
--
-- @usage
-- -- Beispiel für eine Mine
-- API.CreateIOMine("mine", Goods.G_Wood, 20)
--
function API.CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)
    if GUI then
        return;
    end
    if not IsExisting(_Position) then
        error("API.CreateIOIronMine: _Position (" ..tostring(_Position).. ") does not exist!");
        return;
    end
    if _Cost1Type then
        if GetNameOfKeyInTable(Goods, _Cost1Type) == nil then
            error("API.CreateIOIronMine: _Cost1Type (" ..tostring(_Cost1Type).. ") is wrong!");
            return;
        end
        if _Cost1Amount and (type(_Cost1Amount) ~= "number" or _Cost1Amount < 1) then
            error("API.CreateIOIronMine: _Cost1Amount must be above 0!");
            return;
        end
    end
    if _Cost2Type then
        if GetNameOfKeyInTable(Goods, _Cost2Type) == nil then
            error("API.CreateIOIronMine: _Cost2Type (" ..tostring(_Cost2Type).. ") is wrong!");
            return;
        end
        if _Cost2Amount and (type(_Cost2Amount) ~= "number" or _Cost2Amount < 1) then
            error("API.CreateIOIronMine: _Cost2Amount must be above 0!");
            return;
        end
    end
    AddOnInteractiveMines.Global:CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable);
end
CreateIOIronMine = API.CreateIOIronMine;

---
-- Erstelle eine verschüttete Steinmine.
--
-- <p><b>Alias</b>: CreateIOStoneMine</p>
--
-- @param[type=string]  _Position      Script Entity, die mit Mine ersetzt wird
-- @param[type=number]  _Cost1Type     (optional) Kostenware 1
-- @param[type=number]  _Cost1Amount   (optional) Kostenmenge 1
-- @param[type=number]  _Cost2Type     (optional) Kostenware 2
-- @param[type=number]  _Cost2Amount   (optional) Kostenmenge 2
-- @param[type=boolean] _NotRefillable (optional) Mine wird nach Ausbeutung zerstört
-- @within Anwenderfunktionen
-- @see API.CreateIOMine
--
-- @usage
-- -- Beispiel für eine Mine
-- API.CreateIOMine("mine", Goods.G_Wood, 20)
--
function API.CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)
    if GUI then
        return;
    end
    if not IsExisting(_Position) then
        error("API.CreateIOStoneMine: _Position (" ..tostring(_Position).. ") does not exist!");
        return;
    end
    if _Cost1Type then
        if GetNameOfKeyInTable(Goods, _Cost1Type) == nil then
            error("API.CreateIOStoneMine: _Cost1Type (" ..tostring(_Cost1Type).. ") is wrong!");
            return;
        end
        if _Cost1Amount and (type(_Cost1Amount) ~= "number" or _Cost1Amount < 1) then
            error("API.CreateIOStoneMine: _Cost1Amount must be above 0!");
            return;
        end
    end
    if _Cost2Type then
        if GetNameOfKeyInTable(Goods, _Cost2Type) == nil then
            error("API.CreateIOStoneMine: _Cost2Type (" ..tostring(_Cost2Type).. ") is wrong!");
            return;
        end
        if _Cost2Amount and (type(_Cost2Amount) ~= "number" or _Cost2Amount < 1) then
            error("API.CreateIOStoneMine: _Cost2Amount must be above 0!");
            return;
        end
    end
    AddOnInteractiveMines.Global:CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable);
end
CreateIOStoneMine = API.CreateIOStoneMine;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnInteractiveMines = {
    Global = {
        Data = {
            Mines = {
                Description = {
                    Title = {
                        de = "Mine errichten",
                        en = "Build pit",
                    },
                    Text = {
                        de = "An diesem Ort könnt Ihr eine Mine errichten!",
                        en = "You're able to create a pit at this location!",
                    },
                },
            },
        }
    },
    Local = {
        Data = {},
    },
}

-- Global ----------------------------------------------------------------------

---
-- Initalisiert das AddOn.
-- @within Internal
-- @local
--
function AddOnInteractiveMines.Global:Install()
end

---
-- Erstelle eine Mine eines bestimmten Typs. Es können zudem eine Bedingung
-- und zwei verschiedene Callbacks vereinbart werden.
--
-- @param _Position [string] Script Entity, die mit Mine ersetzt wird
-- @param _Type [number] Typ der Mine
-- @param _Costs [table] (optional) Kostentabelle
-- @param _NotRefillable [boolean] (optional) Die Mine wird weiterhin überwacht
-- @param _Condition [function] (optional) Bedingungsfunktion
-- @param _CreationCallback (optional) Funktion nach Kauf ausführen
-- @param _CallbackDepleted (optional) Funktion nach Ausbeutung ausführen
-- @within Internal
-- @local
--
function AddOnInteractiveMines.Global:CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted)
    -- Objekt austauschen und Model anpassen
    local eID = ReplaceEntity(_Position, Entities.XD_ScriptEntity);
    local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;
    if _Type == Entities.R_StoneMine then
        Model = Models.R_SE_ResorceStone_10;
    end
    Logic.SetVisible(eID, true);
    Logic.SetModel(eID, Model);
    local x, y, z = Logic.EntityGetPos(eID);
    local BlockerID = Logic.CreateEntity(Entities.D_ME_Rock_Set01_B_07, x, y, 0, 0);
    Logic.SetVisible(BlockerID, false);

    CreateObject {
        Name                 = _Position,
        Title                = self.Data.Mines.Description.Title,
        Text                 = self.Data.Mines.Description.Text,
        Type                 = _Type,
        Special              = _NotRefillable,
        Costs                = _Costs,
        InvisibleBlocker     = BlockerID,
        Distance             = 1500,
        Condition            = self.ConditionBuildIOMine,
        CustomCondition      = _Condition,
        CallbackCreate       = _CreationCallback,
        CallbackDepleted     = _CallbackDepleted,
        Callback             = self.ActionBuildIOMine,
    };
end

---
-- Erstelle eine verschüttete Eisenmine.
--
-- @param _Position [string] Script Entity, die mit Mine ersetzt wird
-- @param _Cost1Type [number] (optional) Kostenware 1
-- @param _Cost1Amount [number] (optional) Kostenmenge 1
-- @param _Cost2Type [number] (optional) Kostenware 2
-- @param _Cost2Amount [number] (optional) Kostenmenge 2
-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört
-- @within Internal
-- @local
--
function AddOnInteractiveMines.Global:CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)
    assert(IsExisting(_Position));
    if _Cost1Type then
        assert(API.TraverseTable(_Cost1Type, Goods));
        assert(type(_Cost1Amount) == "number");
    end
    if _Cost2Type then
        assert(API.TraverseTable(_Cost2Type, Goods));
        assert(type(_Cost2Amount) == "number");
    end

    self:CreateIOMine(
        _Position, Entities.R_IronMine,
        {_Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount},
        _NotRefillable
    );
end

---
-- Erstelle eine verschüttete Steinmine.
--
-- @param _Position [string] Script Entity, die mit Mine ersetzt wird
-- @param _Cost1Type [number] (optional) Kostenware 1
-- @param _Cost1Amount [number] (optional) Kostenmenge 1
-- @param _Cost2Type [number] (optional) Kostenware 2
-- @param _Cost2Amount [number] (optional) Kostenmenge 2
-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört
-- @within Internal
-- @local
--
function AddOnInteractiveMines.Global:CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)
    assert(IsExisting(_Position));
    if _Cost1Type then
        assert(API.TraverseTable(_Cost1Type, Goods));
        assert(type(_Cost1Amount) == "number");
    end
    if _Cost2Type then
        assert(API.TraverseTable(_Cost2Type, Goods));
        assert(type(_Cost2Amount) == "number");
    end

    self:CreateIOMine(
        _Position, Entities.R_StoneMine,
        {_Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount},
        _NotRefillable
    );
end

---
-- Testet die Bedingung, unter der die Mine errichtet werden kann.
-- @param _Data Daten des Objektes
-- @return boolean: Bedingung erfüllt
-- @within Internal
-- @local
--
function AddOnInteractiveMines.Global.ConditionBuildIOMine(_IO, _PlayerID, _Data)
    if _Data.CustomCondition then
        return _Data.CustomCondition(_IO, _PlayerID, _Data) == true;
    end
    return true;
end


function AddOnInteractiveMines.Global.ActionBuildIOMine(_IO, _PlayerID, _Data)
    ReplaceEntity(_Data.Name, _Data.Type);
    DestroyEntity(_Data.InvisibleBlocker);
    if type(_Data.CallbackCreate) == "function" then
        _Data.CallbackCreate(_Data);
    end
    StartSimpleJobEx(AddOnInteractiveMines.Global.ControlIOMine, _Data.Name);
end

---
-- Prüft gebaute Minen ob diese ausgebeutet sind. Ist das der Fall
-- werden sie "zerstört" und ggf. das Callback ausgelöst.
-- @param _Mine Zu überwachende Mine
-- @return boolean: Job beendet
-- @within Internal
-- @local
--
function AddOnInteractiveMines.Global.ControlIOMine(_Mine)
    if not IO[_Mine] then
        return true;
    end
    if not IsExisting(_Mine) then
        return true;
    end
    local eID = GetID(_Mine);

    if Logic.GetResourceDoodadGoodAmount(eID) == 0 then
        API.Note(IO[_Mine].Special)
        if IO[_Mine].Special == true then
            local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;
            if IO[_Mine].Type == Entities.R_StoneMine then
                Model = Models.R_ResorceStone_Scaffold_Destroyed;
            end
            eID = ReplaceEntity(eID, Entities.XD_ScriptEntity);
            Logic.SetVisible(eID, true);
            Logic.SetModel(eID, Model);
        end

        if type(IO[_Mine].CallbackDepleted) == "function" then
            IO[_Mine].CallbackDepleted(IO[_Mine]);
        end
        return true;
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterAddOn("AddOnInteractiveMines");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnInteractiveSites                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht es den Spieler auf einem beliebigen Territorium einer Partei
-- ein Gebäude bauen zu lassen.
-- 
-- Die Baustelle muss durch den Helden aktiviert
-- werden. Ein Siedler wird aus dem Lagerhaus kommen und das Gebäude bauen.
-- 
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnInteractiveSites = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Baustelle eines beliebigen Gebäudetyps an der Position.
--
-- Diese Baustelle kann durch einen Helden aktiviert werden. Dann wird ein
-- Siedler zur Baustelle eilen und das Gebäude aufbauen. Es ist egal, ob es
-- sich um ein Territorium des Spielers oder einer KI handelt.
--
-- Es ist dabei zu beachten, dass der Spieler, dem die Baustelle zugeordnet
-- wird, das Territorium besitzt, auf dem er bauen soll. Des weiteren muss
-- er über ein Lagerhaus/Hauptzelt verfügen.
--
-- <p><b>Hinweis:</b> Es kann vorkommen, dass das Model der Baustelle nicht
-- geladen wird. Dann ist der Boden der Baustelle schwarz. Sobald wenigstens
-- ein reguläres Gebäude gebaut wurde, sollte die Textur jedoch vorhanden sein.
-- </p>
--
-- Mögliche Angaben für die Konfiguration:
-- <table border="1">
-- <tr><td><b>Feldname</b></td><td><b>Beschreibung</b></td></tr>
-- <tr><td>Position</td><td>Position für die Baustelle</td></tr>
-- <tr><td>PlayerID</td><td>Besitzer des Gebäudes</td></tr>
-- <tr><td>Type</td><td>Typ des Gebäudes</td></tr>
-- <tr><td>Costs</td><td>(optional) Eigene Gebäudekosten</td></tr>
-- <tr><td>Distance</td><td>(optional) Aktivierungsentfernung</td></tr>
-- reaktivieren</td></tr>
-- <tr><td>Icon</td><td>(optional) Icon des Schalters</td></tr>
-- <tr><td>Title</td><td>(optional) Titel der Beschreibung</td></tr>
-- <tr><td>Text</td><td>(optional) Text der Beschreibung</td></tr>
-- <tr><td>Callback</td><td>(optional) Funktion nach Fertigstellung</td></tr>
-- <tr><td>PlacementFailedHandler</td><td>(optional) Fehlerbenahdlungsfunktion bei
-- nicht platzierter Baustelle. Muss Gebäude ID zurückgeben</td></tr>
-- </table>
--
-- <p><b>Alias</b>: CreateIOBuildingSite</p>
--
-- @param[type=table] _Data Konfiguration des Objektes
-- @within Anwenderfunktionen
--
-- @usage
-- -- Erzeugt eine Baustelle ohne besondere Einstellungen
-- API.CreateIOBuildingSite {
--     Position = "haus",
--     PlayerID = 1,
--     Type     = Entities.B_Bakery
-- };
--
-- -- Baustelle mit Kosten und Aktivierungsdistanz
-- API.CreateIOBuildingSite {
--     Position = "haus",
--     PlayerID = 1,
--     Type     = Entities.B_Bakery,
--     Costs    = {Goods.G_Wood, 4},
--     Distance = 1000
-- };
--
-- -- Baustelle mit Callback und Error Handler
-- API.CreateIOBuildingSite {
--     Position               = "haus",
--     PlayerID               = 1,
--     Type                   = Entities.B_Bakery,
--     Callback               = function(_IO, _PlayerID, _Data)
--         -- Rufe etwas auf, das im Anschluss passieren soll.
--         OnSuccess();
--     end,
--     PlacementFailedHandler = function(_IO, _PlayerID, _Data)
--         -- Rufe etwas auf, das passieren soll, wenn die Baustelle nicht erzeugt wurde.
--         -- Bedenke: Der Error Handler muss dafür sorgen, dass ein Gebäude oder eine Baustelle entsteht.
--         return OnFailure();
--     end,
-- };
--
function API.CreateIOBuildingSite(_Data)
    if GUI then
        return;
    end
    if not IsExisting(_Data.Position) then
        error("API.CreateIOBuildingSite: Position (" ..tostring(_Data.Position).. ") does not exist!");
        return;
    end
    if type(_Data.PlayerID) ~= "number" or _Data.PlayerID < 1 or _Data.PlayerID > 8 then
        error("API.CreateIOBuildingSite: PlayerID is wrong!");
        return;
    end
    if GetNameOfKeyInTable(Entities, _Data.Type) == nil then
        error("API.CreateIOBuildingSite: Type (" ..tostring(_Data.Type).. ") is wrong!");
        return;
    end
    if _Data.Costs and (type(_Data.Costs) ~= "table" or #_Data.Costs %2 ~= 0) then
        error("API.CreateIOBuildingSite: Costs has the wrong format!");
        return;
    end
    if _Data.Distance and (type(_Data.Distance) ~= "number" or _Data.Distance < 100) then
        error("API.CreateIOBuildingSite: Distance (" ..tostring(_Data.Distance).. ") is wrong or too small!");
        return;
    end
    if _Data.Callback and type(_Data.Callback) ~= "function" then
        error("API.CreateIOBuildingSite: Callback must be a function!");
        return;
    end
    if _Data.PlacementFailedHandler and type(_Data.PlacementFailedHandler) ~= "function" then
        error("API.CreateIOBuildingSite: PlacementFailedHandler must be a function!");
        return;
    end
    AddOnInteractiveSites.Global:CreateIOBuildingSite(_Data);
end
CreateIOBuildingSite = API.CreateIOBuildingSite;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnInteractiveSites = {
    Global = {
        Data = {
            ConstructionSite = {
                Sites = {},

                Description = {
                    Title = {
                        de = "Gebäude bauen",
                        en = "Create building",
                    },
                    Text = {
                        de = "Beauftragt den Bau eines Gebäudes. Ein Siedler wird aus"..
                             " dem Lagerhaus kommen und mit dem Bau beginnen.",
                        en = "Order a building. A worker will come out of the"..
                             " storehouse and erect it.",
                    },
                }
            },
        }
    },
    Local = {
        Data = {},
    },
}

-- Global ----------------------------------------------------------------------

function AddOnInteractiveSites.Global:Install()
    Core:AppendFunction(
        "GameCallback_OnBuildingConstructionComplete",
        self.OnConstructionComplete
    );
end

function AddOnInteractiveSites.Global.OnConstructionComplete(_PlayerID, _EntityID)
    local IO = AddOnInteractiveSites.Global.Data.ConstructionSite.Sites[_EntityID];
    if IO ~= nil and IO.CompletedCallback then
        IO.CompletedCallback(IO, _EntityID);
    end
end

function AddOnInteractiveSites.Global:CreateIOBuildingSite(_Data)
    local Costs = _Data.Costs or {Logic.GetEntityTypeFullCost(_Data.Type)};
    local Title = _Data.Title or self.Data.ConstructionSite.Description.Title;
    local Text  = _Data.Text or self.Data.ConstructionSite.Description.Text;
    local eID = GetID(_Data.Position);
    Logic.SetModel(eID, Models.Buildings_B_BuildingPlot_10x10);
    Logic.SetVisible(eID, true);

    CreateObject {
        Name                    = _Data.Position,
        Title                   = Title,
        Text                    = Text,
        Texture                 = _Data.Icon or {14, 10},
        Distance                = _Data.Distance or 1500,
        Type                    = _Data.Type,
        Costs                   = Costs,
        PlayerID                = _Data.PlayerID,
        PlacementFailedHandler  = _Data.PlacementFailedHandler,
        NoReactivate            = true, -- TODO: Reaktivierung funktioniert nicht
        Condition               = function(_IO, _PlayerID, _Data)
            return AddOnInteractiveSites.Global:ConditionConstructionSite(_IO, _PlayerID, _Data);
        end,
        Callback                = function(_IO, _PlayerID, _Data)
            return AddOnInteractiveSites.Global:CallbackIOConstructionSite(_IO, _PlayerID, _Data);
        end,
        CompletedCallback       = _Data.Callback,
    };
end

function AddOnInteractiveSites.Global:CallbackIOConstructionSite(_IO, _PlayerID, _Data)
    local pos  = GetPosition(_Data.Name);
    local eID  = GetID(_Data.Name);
    local ori  = Logic.GetEntityOrientation(eID);
    local site = Logic.CreateConstructionSite(pos.X, pos.Y, ori, _Data.Type, _Data.PlayerID);
    Logic.SetVisible(eID, false);
    if (site == nil) then
        if _Data.PlacementFailedHandler then
            log("AddOnInteractiveSites.Global:CreateIOBuildingSite: Calling handler for failed placement!", LEVEL_WARNING);
            site = _Data.PlacementFailedHandler(_IO, _PlayerID, _Data);
            if site == nil or not IsExisting(site) then
                error("AddOnInteractiveSites.Global:CreateIOBuildingSite: Error handler failed!");
                return;
            end
        else
            log("AddOnInteractiveSites.Global:CreateIOBuildingSite: Creating building instead!", LEVEL_WARNING);
            site = Logic.CreateEntity(_Data.Type, pos.X, pos.Y, ori, _Data.PlayerID);
        end
    end
    self.Data.ConstructionSite.Sites[site] = _Data;
    if not _Data.NoReactivate then
        StartSimpleJobEx(function(_ID)
            self:ControlConstructionSite(_ID)
        end, site);
    end
end

function AddOnInteractiveSites.Global:ConditionConstructionSite(_IO, _PlayerID, _Data)
    local eID = GetID(_Data.Name);
    local tID = GetTerritoryUnderEntity(eID);
    local pID = Logic.GetTerritoryPlayerID(tID);

    if Logic.GetStoreHouse(_Data.PlayerID) == 0 then
        return false;
    end
    if _Data.PlayerID ~= pID then
        return false;
    end
    return true;
end

function AddOnInteractiveSites.Global:ControlConstructionSite(_eID)
    if self.Data.ConstructionSite.Sites[_eID] == nil then
        return true;
    end
    if not IsExisting(_eID) then
        local Data = API.InstanceTable(self.Data.ConstructionSite.Sites[_eID]);
        self:CreateIOBuildingSite(Data);
        return true;
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterAddOn("AddOnInteractiveSites");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnInteractiveTrebuchets                                   # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Der Spieler kann ein Trebuchet mieten. Das Trebuchet fährt als Karren vor,
-- wird "aufgebaut" und kann anschließend benutzt werden.<br> Das Trebuchet
-- fährt ab, wenn die Munition alle ist oder der Spieler das Trebuchet abbaut.
-- <br>Sobald ein Trebuchet zerstört wird oder sein Karren wieder am Lagerhaus
-- ankommt, wird die Baustelle wieder freigegeben.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnInteractiveTrebuchets = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt eine Trebuchet-Baustelle an der Position mit den
-- angegebenen Baukosten.
--
-- Das Trebuchet kann von einem Helden aufgebaut werden. Es wird ein Karren
-- aus dem Lagerhaus zur Baustelle fahren. Erreicht der Karren die Baustelle,
-- wird er durch ein Trebuchet ersetzt.
--
-- Das Trebuchet hat dann 10 Schuss. Sind diese aufgebraucht wird das Trebuchet
-- abgebaut und fährt in das Lagerhaus zurück. Sobald der Karren angekommen
-- ist, kann die Baustelle erneut aktiviert werden.
--
-- <b>Achtung:</b>Das Auffüllen von Trebuchets wird deaktiviert, sobald eine
-- Baustelle erzeugt wird. Es wird NICHT empfohlen dem Spieler beides, normale
-- Trebuchets und Trebuchetbaustellen, zur gleichen Zeit zu geben!
--
-- <p><b>Alias</b>: CreateTrebuchetConstructionSite</p>
--
-- @param[type=string] _Name Skriptname Position
-- @param[type=number] _GoldCost Goldkosten
-- @param[type=number] _WoodCost Holzkosten
-- @within Anwenderfunktionen
--
-- @usage API.CreateTrebuchetConstructionSite("trebuchetSite1", 250, 10);
--
function API.CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateTrebuchetConstructionSite: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    if type(_GoldCost) ~= "number" or _GoldCost < 1 then
        error("API.CreateTrebuchetConstructionSite: _GoldCost (" ..tostring(_GoldCost).. ") is wrong!");
        return;
    end
    if type(_WoodCost) ~= "number" or _WoodCost < 1 then
        error("API.CreateTrebuchetConstructionSite: _WoodCost (" ..tostring(_WoodCost).. ") is wrong!");
        return;
    end
    AddOnInteractiveTrebuchets.Global:CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost);
end
CreateTrebuchetConstructionSite = API.CreateTrebuchetConstructionSite;

---
-- Zerstört eine Trebuchet-Baustelle, aber nicht die Skript Entity.
--
-- Die Baustelle wird in jedem möglichen Status zerstört. Es ist egal, ob das
-- Trebuchet aufgebaut ist, gerade ein Karren unterwegs ist, oder die Baustelle
-- noch nie berührt wurde.
--
-- <p><b>Alias</b>: DestroyTrebuchetConstructionSite</p>
--
-- @param[type=string] _Name Skriptname Position
-- @within Anwenderfunktionen
--
-- @usage API.DestroyTrebuchetConstructionSite("trebuchetSite1");
--
function API.DestroyTrebuchetConstructionSite(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateTrebuchetConstructionSite: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    AddOnInteractiveTrebuchets.Global:DestroyTrebuchetConstructionSite(_Name);
end
DestroyTrebuchetConstructionSite = API.DestroyTrebuchetConstructionSite;

---
-- Gibt die EntityID aufgebaute Trebuchet der Trebuchet-Baustelle zurück.
-- Sollte kein Trebuchet aufgebaut sein, wird 0 zurückgegeben.
--
-- @param[type=string] _Name Skriptname der Trebuchet-Baustelle
-- @return[type=number] EntityID des Trebuchet
-- @within Anwenderfunktionen
--
-- @usage local ID = API.GetTrebuchetByTrebuchetConstructionSite("trebuchetSite1");
--
function API.GetTrebuchetByTrebuchetConstructionSite(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateTrebuchetConstructionSite: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    if not AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[_Name] then
        error("API.GetTrebuchetByTrebuchetConstructionSite: Site (" ..tostring(_Name).. ") is not initalized!");
        return 0;
    end
    return AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[_Name].ConstructedTrebuchet;
end
GetTrebuchet = API.GetTrebuchetByTrebuchetConstructionSite;

---
-- Gibt die EntityID des Anforderungswagens der Trebuchet-Baustelle zurück.
-- Sollte kein Anforderungswagen unterwegs sein, wird 0 zurückgegeben.
--
-- @param[type=string] _Name Skriptname der Trebuchet-Baustelle
-- @return[type=number] EntityID des angeforderten Wagens
-- @within Anwenderfunktionen
--
-- @usage local ID = API.GetReturningCartByTrebuchetConstructionSite("trebuchetSite1");
--
function API.GetReturningCartByTrebuchetConstructionSite(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateTrebuchetConstructionSite: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    if not AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[_Name] then
        error("API.GetReturningCartByTrebuchetConstructionSite: Site (" ..tostring(_Name).. ") is not initalized!");
        return 0;
    end
    return AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[_Name].ReturningCart;
end
GetReturningCart = API.GetReturningCartByTrebuchetConstructionSite;

---
-- Gibt die EntityID des Abreisewagens der Trebuchet-Baustelle zurück. Sollte
-- kein Abreisewagens unterwegs sein, wird 0 zurückgegeben.
--
-- @param[type=string] _Name Skriptname der Trebuchet-Baustelle
-- @return[type=number] EntityID des angeforderten Wagens
-- @within Anwenderfunktionen
--
-- @usage local ID = API.GetConstructionCartByTrebuchetConstructionSite("trebuchetSite1");
--
function API.GetConstructionCartByTrebuchetConstructionSite(_Name)
    if GUI then
        return;
    end
    if not IsExisting(_Name) then
        error("API.CreateTrebuchetConstructionSite: _Name (" ..tostring(_Name).. ") does not exist!");
        return;
    end
    if not AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[_Name] then
        error("API.GetConstructionCartByTrebuchetConstructionSite: Site (" ..tostring(_Name).. ") is not initalized!");
        return 0;
    end
    return AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[_Name].ConstructionCart;
end
GetConstructionCart = API.GetConstructionCartByTrebuchetConstructionSite;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnInteractiveTrebuchets = {
    Global = {
        Data = {
            Trebuchet = {
                Description = {
                    Title = {
                        de = "Trebuchet anfordern",
                        en = "Order trebuchet",
                    },
                    Text = {
                        de = "- Fordert ein Trebuchet aus der Stadt an {cr}- Trebuchet wird gebaut, wenn Wagen Baustelle erreicht {cr}- Fährt zurück, wenn Munition aufgebraucht {cr}- Trebuchet kann manuell zurückgeschickt werden",
                        en = "- Order a trebuchet from your city {cr}- The trebuchet is build after the cart has arrived {cr}- Returns after ammunition is depleted {cr}- The trebuchet can be manually send back to the city",
                    },
                },

                Sites = {},
                NeededKnightTitle = 0,
                IsActive = false,
            },
        }
    },
}

-- Global ----------------------------------------------------------------------

---
-- Initalisiert das AddOn.
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global:Install()
end

---
-- Initialisiert die interaktiven Trebuchet-Baustellen.
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global:TrebuchetActivate()
    if not self.Data.Trebuchet.IsActive then
        GameCallback_QSB_OnDisambleTrebuchet = AddOnInteractiveTrebuchets.Global.OnTrebuchetDisambled;
        GameCallback_QSB_OnErectTrebuchet = function() end;
        StartSimpleJobEx(self.WatchTrebuchetsAndCarts);
        self.Data.Trebuchet.IsActive = true;
    end
end

---
-- Prüft, ob der menschliche Spieler einen ausreichenden Titel
-- hat um Trebuchets zu bauen.
--
-- @return boolean: Titel hoch genug
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global.TrebuchetHasSufficentTitle()
    return Logic.GetKnightTitle(QSB.HumanPlayerID) >= AddOnInteractiveTrebuchets.Global.Data.Trebuchet.NeededKnightTitle;
end

---
-- Setzt den mindestens benötigten Titel um Trebuchets zu bauen.
--
-- @param _KnightTitle Titel
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global:TrebuchetSetNeededKnightTitle(_KnightTitle)
    self.Data.Trebuchet.NeededKnightTitle = _KnightTitle;
end

---
-- Erstellt eine Trebuchet-Baustelle an der Position mit den
-- angegebenen Baukosten.
--
-- @param _Name [string] Skriptname Position
-- @param _GoldCost Goldkosten
-- @param _WoodCost Holzkosten
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global:CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost)
    self:TrebuchetActivate();

    _GoldCost = _GoldCost or 4500;
    _WoodCost = _WoodCost or 35;
    local eID = GetID(_Name);
    Logic.SetModel(eID, Models.Buildings_B_BuildingPlot_8x8);
    Logic.SetVisible(eID, true);

    self.Data.Trebuchet.Sites[_Name] = {
        ConstructedTrebuchet = 0,
        ConstructionCart = 0,
        ReturningCart = 0,
    }

    CreateObject {
        Name                    = _Name,
        Title                   = self.Data.Trebuchet.Description.Title,
        Text                    = self.Data.Trebuchet.Description.Text,
        Costs                   = {Goods.G_Gold, _GoldCost, Goods.G_Wood, _WoodCost},
        Distance                = 1000,
        State                   = 0,
        Condition               = self.TrebuchetHasSufficentTitle,
        Callback                = function(_IO, _PlayerID, _Data)
            AddOnInteractiveTrebuchets.Global:SpawnTrebuchetCart(_PlayerID, _Data.Name);
        end,
    }
end

---
-- Zerstört eine Trebuchet-Baustelle.
--
-- @param _Name [string] Skriptname Position
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global:DestroyTrebuchetConstructionSite(_Name)
    local ConstructionCart = self.Data.Trebuchet.Sites[_Name].ConstructionCart;
    DestroyEntity(ConstructionCart);
    local ConstructedTrebuchet = self.Data.Trebuchet.Sites[_Name].ConstructedTrebuchet;
    DestroyEntity(ConstructedTrebuchet);
    local ReturningCart = self.Data.Trebuchet.Sites[_Name].ReturningCart;
    DestroyEntity(ReturningCart);

    self.Data.Trebuchet.Sites[_Name] = nil;
    Logic.SetVisible(GetID(_Name), false);
    RemoveInteractiveObject(_Name);
end

---
-- Erzeugt einen Trebuchetwagen für die Baustelle.
--
-- @param _PlayerID Besitzer
-- @param _Site     Baustelle
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global:SpawnTrebuchetCart(_PlayerID, _Site)
    local StoreID = Logic.GetStoreHouse(_PlayerID);
    local x,y = Logic.GetBuildingApproachPosition(StoreID);
    local CartID = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, _PlayerID);
    Logic.SetEntitySelectableFlag(CartID, 0);
    self.Data.Trebuchet.Sites[_Site].ConstructionCart = CartID;
end

---
-- Erzeugt das Trebuchet an der Baustelle.
--
-- @param _PlayerID Besitzer
-- @param _Site     Baustelle
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global:SpawnTrebuchet(_PlayerID, _Site)
    local pos = GetPosition(_Site);
    local TrebuchetID = Logic.CreateEntity(Entities.U_Trebuchet, pos.X, pos.Y, 0, _PlayerID);
    self.Data.Trebuchet.Sites[_Site].ConstructedTrebuchet = TrebuchetID;
end

---
-- Baut das Trebuchet zum Wagen zurück und lässt es wieder ins
-- Lagerhaus des Besitzers fahren.
--
-- @param _PlayerID  Besitzer
-- @param _Trebuchet Baustelle
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global:ReturnTrebuchetToStorehouse(_PlayerID, _Trebuchet)
    local x,y,z = Logic.EntityGetPos(_Trebuchet);
    local CartID = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, _PlayerID);
    Logic.SetEntitySelectableFlag(CartID, 0);

    local SiteName;
    for k,v in pairs(self.Data.Trebuchet.Sites) do
        if v.ConstructedTrebuchet == _Trebuchet then
            SiteName = k;
        end
    end
    if SiteName then
        self.Data.Trebuchet.Sites[SiteName].ReturningCart = CartID;
        self.Data.Trebuchet.Sites[SiteName].ConstructedTrebuchet = 0;
        Logic.SetVisible(GetID(SiteName), true);
        DestroyEntity(_Trebuchet);
    else
        DestroyEntity(CartID);
    end
end

---
-- Callback: Ein Trebuchet wird manuell zurückgebaut.
--
-- @param _EntityID Entity-ID des Trebuchet
-- @param _PlayerID Besitzer
-- @param _x        X-Position
-- @param _y        Y-Position
-- @param _z        Z-Position
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global.OnTrebuchetDisambled(_EntityID, _PlayerID, _x, _y, _z)
    AddOnInteractiveTrebuchets.Global:ReturnTrebuchetToStorehouse(_PlayerID, _EntityID);
end

---
-- Steuert die Trebuchet-Mechanik.
-- @within Internal
-- @local
--
function AddOnInteractiveTrebuchets.Global.WatchTrebuchetsAndCarts()
    for k,v in pairs(AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites) do
        local SiteID = GetID(k);

        -- Stufe 1: Karren kommt
        if v.ConstructionCart ~= 0 then
            -- Bauwagen wurde zerstört
            if not IsExisting(v.ConstructionCart) then
                AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[k].ConstructionCart = 0;
                API.InteractiveObjectActivate(k);
            end
            -- Bauwagen bewegt sich nicht zum Ziel
            if not Logic.IsEntityMoving(v.ConstructionCart) then
                local SiteID = GetID(k);
                local x,y,z = Logic.EntityGetPos(SiteID);
                Logic.MoveSettler(v.ConstructionCart, x, y);
            end
            -- Bauwagen ist angekommen
            if IsNear(v.ConstructionCart, k, 500) then
                local x,y,z = Logic.EntityGetPos(SiteID);
                local PlayerID = Logic.EntityGetPlayer(v.ConstructionCart);
                AddOnInteractiveTrebuchets.Global:SpawnTrebuchet(PlayerID, k);
                DestroyEntity(v.ConstructionCart);
                AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[k].ConstructionCart = 0;
                Logic.SetVisible(SiteID, false);
                Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
            end
        end

        -- Stufe 2: Trebuchet steht
        if v.ConstructedTrebuchet ~= 0 then
            -- Trebuchet wurde zerstört
            if not IsExisting(v.ConstructedTrebuchet) then
                AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[k].ConstructedTrebuchet = 0;
                Logic.SetVisible(SiteID, true);
                API.InteractiveObjectActivate(k);
            end
            -- Trebuchet hat keine Munition
            if Logic.GetAmmunitionAmount(v.ConstructedTrebuchet) == 0 and BundleEntitySelection.Local.Data.RefillTrebuchet == false then
                local PlayerID = Logic.EntityGetPlayer(v.ConstructedTrebuchet);
                AddOnInteractiveTrebuchets.Global:ReturnTrebuchetToStorehouse(PlayerID, v.ConstructedTrebuchet);
            end
        end

        -- Stufe 3: Rückweg
        if v.ReturningCart ~= 0 then
            -- Rückkehrwagen wurde zerstört
            if not IsExisting(v.ReturningCart) then
                AddOnInteractiveTrebuchets.Global.Data.Trebuchet.Sites[k].ReturningCart = 0;
                API.InteractiveObjectActivate(k);
            end

            local PlayerID = Logic.EntityGetPlayer(v.ReturningCart);
            local StoreID = Logic.GetStoreHouse(PlayerID);

            -- Rückkehrwagen muss sich zum Ziel bewegen
            if not Logic.IsEntityMoving(v.ReturningCart) then
                local x,y = Logic.GetBuildingApproachPosition(StoreID);
                Logic.MoveSettler(v.ReturningCart, x, y);
            end
            -- Rückkehrwagen kommt an
            if IsNear(v.ReturningCart, StoreID, 1100) then
                local PlayerID = Logic.EntityGetPlayer(v.ConstructionCart);
                DestroyEntity(v.ReturningCart);
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterAddOn("AddOnInteractiveTrebuchets");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnLanguageSelection                                       # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht dem Spieler zu Beginn der Map eine von mehreren Sprachen
-- auszuwählen. Hinterlegte Texte werden automatisch in der ausgewählten
-- Sprache angezeigt.
--
-- <b>Achtung:</b> Du musst für alle Sprachen selbst Texte hinterlegen!
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnLanguageSelection = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert die Sprachauswahl mit den zuvor eingestellten Sprachen.
--
-- <b>Achtung:</b> Du musst für alle Sprachen, die du eingestellt hast, auch
-- Texte schreiben. Außerdem sind für die meisten Features er QSB nur Deutsch
-- und Englisch vorgesehen, weshalb du außer Briefings, Nachrichten und Quests
-- keine anderen Sprachen als Deutsch und Englisch verwenden kannst.
--
-- Quests dürfen erst erstellt werden, sobald der Spieler den Dialog
-- bestätigt. Nach Bestätigung des Dialogs wird Mission_OnLanguageChanged im
-- globalen und lokalen Skript aufgerufen.
--
-- @param[type=boolean] _HideUIOnStart Interface beim Start ausblenden
-- @param[type=boolean] _ShowUIOnEnd   (optional) Interface nach Ende einblenden
-- @within Anwenderfunktionen
--
-- @usage -- Ohne schwarzen Hintergrund
-- API.LanguageSelectionShow();
-- -- Mit schwarzen Hintergrund
-- API.LanguageSelectionShow(true);
-- -- Schwarzen Hintergrund aktiv lassen (z.B. für nachfolgende Briefings)
-- API.LanguageSelectionShow(true, true);
--
function API.LanguageSelectionShow(_HideUIOnStart, _ShowUIOnEnd)
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            "API.LanguageSelectionShow(%s, %s)",
            tostring(_HideUIOnStart == true),
            tostring(_ShowUIOnEnd == true)
        ));
        return;
    end
    AddOnLanguageSelection.Local:StartSelection(_HideUIOnStart, _ShowUIOnEnd);
end

---
-- Löscht die Liste der voreingestellten Sprachen.
--
-- @within Anwenderfunktionen
--
-- @usage API.LanguageSelectionClear();
--
function API.LanguageSelectionClear()
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.LanguageSelectionClear()");
        return;
    end
    AddOnLanguageSelection.Local.Text.Languages = {};
    AddOnLanguageSelection.Local.Data.Languages = {};
end

---
-- Fügt der Liste der Sprachen eine weitere Sprache hinzu.
--
-- @param[type=string] _Short Kurzbezeichnung der Sprache (de, en, fr, ...)
-- @param[type=string] _Name  Anzeigename der Sprache
-- @within Anwenderfunktionen
--
-- @usage API.LanguageSelectionAdd("fr", "Français");
--
function API.LanguageSelectionAdd(_Short, _Name)
    if not GUI then
        Logic.ExecuteInLuaLocalState(string.format(
            [[API.LanguageSelectionAdd("%s", "%s")]],
            _Short,
            _Name
        ));
        return;
    end
    table.insert(AddOnLanguageSelection.Local.Text.Languages, _Name);
    table.insert(AddOnLanguageSelection.Local.Data.Languages, _Short);
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnLanguageSelection = {
    Global = {
        Data = {
            LanguageSelected = false,
        }
    },
    Local = {
        Data = {
            Languages = {"de", "en",},
            LanguageSelected = false,
            HideUIOnStart = false,
            ShowUIOnEnd = false,
            DesiredLanguage = 2,
        },
        Text = {
            Languages = {"Deutsch", "English"},
            Dialog = {
                Title = {
                    de = "Sprache wählen",
                    en = "Select language",
                },
                Text = {
                    de = "Wähle die Sprache aus, in der die Handlung erzählt werden soll.",
                    en = "Choose the language in which the story should be told.",
                }
            }
        }
    },
}

-- Global ------------------------------------------------------------------- --

---
-- Initialisiert das Addon.
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Global:Install()
end

---
-- Wird aufgerufen, wenn der Spieler eine Sprache ausgewählt hat.
-- @param[type=string] _Language Ausgewählte Sprache
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Global:LanguageSelectionFinished(_Language)
    QSB.Language = _Language;
    if Mission_OnLanguageChanged then
        Mission_OnLanguageChanged(_Language);
    end
    AddOnLanguageSelection.Global.Data.LanguageSelected = true;
end

-- Local -------------------------------------------------------------------- --

---
-- Initialisiert das Addon.
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Local:Install()
end

---
-- Ermittelt die bevorzugte Sprache aus der Liste der voreingestellten Sprachen.
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Local:GetDesiredLanguage()
    for i= 1, #self.Data.Languages, 1 do
        if QSB.Language == self.Data.Languages[i] then
            self.Data.DesiredLanguage = i;
        end
    end
end

---
-- Zeigt den Auswahldialog für die Sprache an, sobald möglich.
-- @param[type=boolean] _HideUIOnStart Interface beim Start ausblenden
-- @param[type=boolean] _ShowUIOnEnd   (optional) Interface nach Ende einblenden
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Local:StartSelection(_HideUIOnStart, _ShowUIOnEnd)
    if _HideUIOnStart and _ShowUIOnEnd == nil then
        _ShowUIOnEnd = true;
    end
    self.Data.HideUIOnStart = _HideUIOnStart;
    self.Data.ShowUIOnEnd = _ShowUIOnEnd;
    StartSimpleHiResJobEx(function()
        if not API.IsLoadscreenVisible() then
            AddOnLanguageSelection.Local:StartSelectionInternal();
            return true;
        end
    end);
end

---
-- Startet den Sprachauswahlbildschirm.
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Local:StartSelectionInternal()
    if self.Data.LanguageSelected then
        return;
    end
    
    self:SetBriefingActive();
    if self.Data.HideUIOnStart then
        self:StartCinematicMode();
    end
    self:GetDesiredLanguage();

    API.DialogSelectBox(
        self.Text.Dialog.Title,
        self.Text.Dialog.Text,
        function(_Index)
            local lang = AddOnLanguageSelection.Local.Data.Languages[_Index];
            GUI.SendScriptCommand(string.format([[
                AddOnLanguageSelection.Global:LanguageSelectionFinished("%s");
            ]], lang))
            self:SetBriefingInactive();
            if self.Data.ShowUIOnEnd then
                self:StopCinematicMode();
            end
            QSB.Language = lang;
            if Mission_OnLanguageChanged then
                Mission_OnLanguageChanged(lang);
            end
            self.Data.LanguageSelected = true;
        end,
        self.Text.Languages
    );
end

---
-- Sperrt die Ausführung von Briefings und anderen Effekte.
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Local:SetBriefingActive()
    if BundleBriefingSystem then
        BundleBriefingSystem.Local.Data.BriefingActive = true;
        GUI.SendScriptCommand("BundleBriefingSystem.Global.Data.BriefingActive = true");
    end
end

---
-- Aktiviert die Ausführung von Briefings und anderen Effekte.
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Local:SetBriefingInactive()
    if BundleBriefingSystem then
        BundleBriefingSystem.Local.Data.BriefingActive = false;
        GUI.SendScriptCommand("BundleBriefingSystem.Global.Data.BriefingActive = false");
    end
end

---
-- Deaktiviert das Interface und zeigt schwarzen Hintergrund an.
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Local:StartCinematicMode()
    Core:InterfaceDeactivateNormalInterface();
    Core:InterfaceActivateBlackBackground();
end

---
-- Aktiviert das Interface und blendet den schwarzen Hintergrund aus.
-- @within Internal
-- @local
--
function AddOnLanguageSelection.Local:StopCinematicMode()
    Core:InterfaceActivateNormalInterface();
    Core:InterfaceDeactivateBlackBackground();
end

-- -------------------------------------------------------------------------- --

Core:RegisterAddOn("AddOnLanguageSelection");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnQuestStages                                             # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht das Zusammenfassen mehrerer Quests unter einem Staged Quest.
--
-- Diese Funktionalität kann ausschließlich für im Skript erstellte Quests
-- genutzt werden. Im Assistenten können Stages nicht abgebildet werden!
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnQuestStages = {};

API = API or {};
QSB = QSB or {};

---
-- Die Abschlussarten eines Quest Stage.
--
-- @field Success Phase muss erfolgreich abgeschlossen werden.
-- @field Failure Phase muss fehlschlagen.
-- @field Ignore  Erfolg und Misserfolg werden geleichermaßen akzeptiert.
--
QSB.StageResult = {
    Success = 1,
    Failure = 2,
    Ignore  = 3,
}

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt eine Reihe aufeinanderfolgender Aufträge, zusammengefasst under
-- einem übergeordneten Auftrag.
--
-- Die erzeugten Aufträge (Stages) starten aufeinander folgend, sobald der
-- übergeordnete Auftrag (Staged Quest) aktiv ist. Der nachfolgende Stage
-- startet, sobald der Vorgänger abgeschlossen ist. Das erwartete Ergebnis
-- kann gesetzt werden und ist per Default auf Erfolg gesetzt. Wenn ein Stage
-- abgeschlossen wird und nicht das erwartete Ergebnis hat, dann schlägt
-- der StagedQuest fehl. Der Staged Quest wird erfolgreich abgeschlossen, sobald
-- der letzte Stage beendet ist.
--
-- <b>Hinweis</b>: Staged Quests eignen sich nur für lineare Abläufe. Es kann
-- keine Verzweigungen innerhalb des Ablaufes geben. Wenn verzweigt werden
-- soll, müssen mehrere Staged Quests paralel laufen!
--
-- Es ist nicht vorgesehen, dass Staged Quests sichtbar sind oder Texte anzeigen.
-- Es ist trotzdem möglich, <u>sollte aber unterlassen werden</u>. 
--
-- Es ist nicht notwendig einen Trigger für die Stage zu setzen. Der
-- Trigger wird automatisch generiert. Es können aber zusätzliche Trigger
-- angegeben werden. Wird ein Briefing im Vorgänger verwendet, wird der
-- Trigger Trigger_Briefing verwendet, sonst ein OnQuest Trigger. Je nach
-- eingestellten Ergebnis wird entsprechend verknüpft.
--
-- Staged Quests können auch ineinander verschachtelt werden. Man kann also
-- innerhalb einer Questreihe eine untergeordnete Questreige angeben.
--
-- <b>Alias</b>: AddStagedQuest
--
-- @param[type=table] _Data Daten des Quest
-- @return[type=string] Name des Staged Quest oder nil bei Fehler
-- @within Anwenderfunktionen
--
-- @usage API.CreateStagedQuest {
--     Name        = "StagedQuest",
--     Stages      = {
--         {
--             Suggestion  = "Wir benötigen einen höheren Titel!",
--
--             Goal_KnightTitle("Mayor"),
--         },
--         {
--             -- Mit dem Typ Ignore wird Fehlschlag ignoriert und der nächste
--             -- Quest startet nach diesem Quest.
--             Result      = QSB.StageResult.Ignore,
--
--             Suggestion  = "Wir benötigen außerdem mehr Asche! Und das sofort...",
--             Success     = "Geschafft!",
--             Failure     = "Versagt!",
--             Time        = 3 * 60,
--
--             Goal_Produce("G_Gold", 5000),
--
--             -- Staged Quest wird gewonnen. Der Nachfolger startet nicht mehr.
--             Reward_QuestSuccess("StagedQuest"),
--         },
--         {
--             Suggestion  = "Dann versuchen wir es mit Eisen...",
--             Success     = "Geschafft!",
--             Failure     = "Versagt!",
--             Time        = 3 * 60,
--
--             Goal_Produce("G_Iron", 50),
--         }
--     },
--
--     -- Wenn ein Quest nicht das erwartete Ergebnis hat, Fehlschlag.
--     Reprisal_Defeat(),
--
--     -- Wenn alles erfüllt wird, ist das Spiel gewonnen.
--     Reward_VictoryWithParty(),
-- };
--
function API.CreateStagedQuest(_Data)
    if GUI or type(_Data) ~= "table" then
        return;
    end
    if _Data.Stages == nil or #_Data.Stages == 0 then
        error(string.format("API.CreateStagedQuest: Staged quest '%s' is missing it's stages!", tostring(_Data.Name)));
        return;
    end
    return AddOnQuestStages.Global:CreateStagedQuest(_Data);
end
AddStagedQuest = API.CreateStagedQuest;

---
-- Gibt den Index des aktuell aktiven Stages eines Staged Quest zurück.
--
-- Ist ein Staged Quest bereits abgeschlossen wird immer der Index des letzten
-- Stage zurückgegeben.
--
-- <b>Alias</b>: GetQuestStage
--
-- @param[type=string] _QuestName Name des Quest
-- @return[type=number] Relativer Fortschritt (0 ... 1)
-- @within Anwenderfunktionen
--
-- @usage local CurrentStage = API.GetCurrentQuestStage("MyQuest");
--
function API.GetCurrentQuestStage(_QuestName)
    if GUI then
        return 0;
    end
    local Quest = Quests[GetQuestID(_QuestName)];
    if not API.IsValidQuest(_QuestName) then
        error(string.format("API.GetCurrentQuestStage: Quest '%s' does not exist!", tostring(_QuestName)));
        return 0;
    end
    if AddOnQuestStages.Global.Data.StagesForQuest[_QuestName] == nil then
        error(string.format("API.GetCurrentQuestStage: Quest '%s' is not a staged quest!", tostring(_QuestName)));
        return 0;
    end
    return AddOnQuestStages.Global:GetCurrentQuestStage(_QuestName);
end
GetQuestStage = API.GetCurrentQuestStage;

---
-- Gibt die Anzahl der Stages eines Staged Quest zurück.
--
-- <b>Alias</b>: CountQuestStages
--
-- @param[type=string] _QuestName Name des Quest
-- @return[type=number] Relativer Fortschritt (0 ... 1)
-- @within Anwenderfunktionen
-- @usage local Stages = API.GetAmountOfQuestStages("MyQuest");
--
function API.GetAmountOfQuestStages(_QuestName)
    if GUI then
        return 0;
    end
    if not API.IsValidQuest(_QuestName) then
        error(string.format("API.GetAmountOfQuestStages: Quest '%s' does not exist!", tostring(_QuestName)));
        return 0;
    end
    if AddOnQuestStages.Global.Data.StagesForQuest[_QuestName] == nil then
        error(string.format("API.GetAmountOfQuestStages: Quest '%s' is not a staged quest!", tostring(_QuestName)));
        return 0;
    end
    return AddOnQuestStages.Global:GetAmountOfQuestStages(_QuestName);
end
CountQuestStages = API.GetAmountOfQuestStages;

---
-- Gibt den Fortschritt eines Staged Quest zurück.
--
-- Kann der Fortschritt nicht bestimmt werden, wird 0 zurückgegeben.
--
-- <b>Alias</b>: GetQuestProgress
--
-- @param[type=string] _QuestName Name des Quest
-- @return[type=number] Relativer Fortschritt (0 ... 1)
-- @within Anwenderfunktionen
--
-- @usage -- Fortschritt ermitteln
-- local Progress = API.GetStagedQuestProgress("MyQuest");
-- -- Fortschritt in % ermitteln
-- local Progress = API.Round(API.GetStagedQuestProgress("MyQuest") * 100, 0);
--
function API.GetStagedQuestProgress(_QuestName)
    if GUI then
        return 0;
    end
    if not API.IsValidQuest(_QuestName) then
        error(string.format("API.GetStagedQuestProgress: Quest '%s' does not exist!", tostring(_QuestName)));
        return 0;
    end
    if AddOnQuestStages.Global.Data.StagesForQuest[_QuestName] == nil then
        error(string.format("API.GetStagedQuestProgress: Quest '%s' is not a staged quest!", tostring(_QuestName)));
        return 0;
    end
    -- Es wäre theoretisch möglich durch Veränderung der Daten hier eine
    -- Division durch 0 herbeizuführen. Da es aber nicht möglich ist, einen
    -- Staged Quest ohne Stages zu erzeugen, wird das hier vernachlässigt.
    return API.GetCurrentQuestStage(_QuestName) / API.GetAmountOfQuestStages(_QuestName);
end
GetQuestProgress = API.GetStagedQuestProgress;

---
-- Spult einen Staged Quest um einen Stage vor.
--
-- Im Erfolgsfall wird eine Zahl größer 0 zurückgegeben. Tritt ein
-- Fehler auf stattdessen 0.
--
-- <b>Alias</b>: ForwardStagedQuest
--
-- @param[type=string] _QuestName  Name Staged Quest
-- @param[type=number] _Result     (Optional) Resultat des Stage
-- @return[type=number] Index des Stage
-- @within Anwenderfunktionen
--
function API.ForwardStagedQuest(_QuestName, _Result)
    if GUI then
        return;
    end
    if not API.IsValidQuest(_QuestName) then
        error(string.format("API.ForwardStagedQuest: Quest '%s' does not exist!", tostring(_QuestName)));
        return 0;
    end
    if AddOnQuestStages.Global.Data.StagesForQuest[_QuestName] == nil then
        error(string.format("API.ForwardStagedQuest: Quest '%s' is not a staged quest!", tostring(_QuestName)));
        return 0;
    end
    return AddOnQuestStages.Global:ForwardStagedQuest(_QuestName, _Result);
end
ForwardStagedQuest = API.ForwardStagedQuest;

---
-- Setzt einen Staged Quest um einen Stage zurück.
--
-- Im Erfolgsfall wird eine Zahl größer 0 zurückgegeben. Tritt ein
-- Fehler auf stattdessen 0.
--
-- <b>Alias</b>: RevertStagedQuest
--
-- @param[type=string] _QuestName  Name Staged Quest
-- @return[type=number] Index des Stage
-- @within Anwenderfunktionen
--
function API.RevertStagedQuest(_QuestName)
    if GUI then
        return;
    end
    if not API.IsValidQuest(_QuestName) then
        error(string.format("API.RevertStagedQuest: Quest '%s' does not exist!", tostring(_QuestName)));
        return 0;
    end
    if AddOnQuestStages.Global.Data.StagesForQuest[_QuestName] == nil then
        error(string.format("API.RevertStagedQuest: Quest '%s' is not a staged quest!", tostring(_QuestName)));
        return 0;
    end
    return AddOnQuestStages.Global:RevertStagedQuest(_QuestName);
end
RevertStagedQuest = API.RevertStagedQuest;

---
-- Gibt den Skriptnamen des Stage auf dem Index zurück.
--
-- <b>Alias</b>: GetSubQuestName
--
-- Wird kein Stage gefunden, wird nil zurückgegeben
--
-- @param[type=string] _QuestName  Name Staged Quest
-- @return[type=string] Quest Name
-- @within Anwenderfunktionen
--
function API.GetSubQuestName(_QuestName, _Index)
    if GUI then
        return;
    end
    if AddOnQuestStages.Global.Data.StagesForQuest[_QuestName] then
        if AddOnQuestStages.Global.Data.StagesForQuest[_QuestName][_Index] then
            return AddOnQuestStages.Global.Data.StagesForQuest[_QuestName][_Index].Name;
        end
    end
    return nil;
end
GetSubQuestName = API.GetSubQuestName;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnQuestStages = {
    Global =  {
        Data = {
            StagesForQuest = {}
        },
    },
}

-- Global ----------------------------------------------------------------------

function AddOnQuestStages.Global:Install()
    self:OverrideMethods();
end

---
-- Erstellt einen Staged Quest mit seinen Stages.
--
-- @param[type=table] _Data Beschreibung
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:CreateStagedQuest(_Data)   
    if not _Data.Stages then
        return;
    end
    -- Behavior zum Prüfen der Quest States der Stages.
    table.insert(
        _Data,
        Goal_MapScriptFunction(self:GetCheckStagesInlineGoal(_Data.Name))
    )
    -- Quest erstellen
    local Name = API.CreateQuest(_Data);
    if not Name then
        return;
    end
    -- Unsichtbarkeit erzwingen
    Quests[GetQuestID(Name)].Visible = false;
    -- Stages erstellen/verlinken
    self.Data.StagesForQuest[Name] = {};
    for i= 1, #_Data.Stages, 1 do
        self:CreateQuestStage(_Data.Stages[i], Name, i);
    end
    return Name;
end

---
-- Gibt den Index des aktuell aktiven Stage zurück.
--
-- Wenn der Staged Quest bereits beendet ist, ist der aktuelle Stage immer der
-- letzte Stage des Quest.
--
-- @param[type=string] _QuestName Name des Staged Quest
-- @return[type=number] Aktiver Stage
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:GetCurrentQuestStage(_QuestName)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest ~= nil and self.Data.StagesForQuest[_QuestName] ~= nil then
        if Quest.State ~= QuestState.Over then
            for i= 1, #self.Data.StagesForQuest[_QuestName], 1 do
                if Quests[GetQuestID(self.Data.StagesForQuest[_QuestName][i].Name)].State == QuestState.Active then
                    return i;
                end
            end
            return 0;
        end
        return #self.Data.StagesForQuest[_QuestName];
    end
    return 0;
end

---
-- Zählt wievele Stages zum Staged Quest zugeordnet sind.
--
-- @param[type=string] _QuestName  Name des Staged Quest
-- @return[type=number] Anzahl Stages
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:GetAmountOfQuestStages(_QuestName)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest ~= nil and self.Data.StagesForQuest[_QuestName] ~= nil then
        return #self.Data.StagesForQuest[_QuestName];
    end
    return 0;
end

---
-- Gibt den Fortschritt des Staged Quest anhand der bereits abgeschlossenen
-- Stages zurück.
--
-- @param[type=string] _QuestName  Name des Staged Quest
-- @return[type=number] Fortschritt in Prozent (0 ... 1)
-- @return[type=number] Aktueller Stage
-- @return[type=number] Höchst möglicher State
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:GetStagedQuestProgress(_QuestName)
    local StageAmount  = self:GetAmountOfQuestStages(_QuestName);
    if StageAmount == 0 then
        return 0, 0, 0;
    end
    local CurrentStage = self:GetCurrentQuestStage(_QuestName);
    return CurrentStage / StageAmount, CurrentStage, StageAmount;
end

---
-- Spult einen Staged Quest um einen Stage vor.
--
-- @param[type=string] _QuestName   Name des Staged Quest
-- @param[type=number] _StageResult (Optional) Resultat des Stage
-- @return[type=number] Index des Stage
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:ForwardStagedQuest(_QuestName, _StageResult)
    local D, C, M = self:GetStagedQuestProgress(_QuestName);
    if M > 0 and C+1 <= M then
        local Current = self.Data.StagesForQuest[_QuestName][C].Name;
        local Next    = self.Data.StagesForQuest[_QuestName][C+1].Name;
        -- Quest gewinnen, wenn das gewünschte Ergebnis Erfolg oder egal ist.
        if self.Data.StagesForQuest[_QuestName][C].Result == QSB.StageResult.Success
        or self.Data.StagesForQuest[_QuestName][C].Result == QSB.StageResult.Ignore
        or _StageResult == QSB.StageResult.Success then
            API.WinQuest(Current, true);
        end
        -- Quest verlieren, wenn das gewünschte Ergebnis Niederlage ist.
        if self.Data.StagesForQuest[_QuestName][C].Result == QSB.StageResult.Failure
        or _StageResult == QSB.StageResult.Failure then
            API.FailQuest(Current, true);
        end
        -- Nächste Quest starten
        API.StartQuest(Next, true);
        return C+1;
    end
    return 0;
end

---
-- Setzt einen Staged Quest um einen Stage zurück.
--
-- @param[type=string] _QuestName  Name des Staged Quest
-- @return[type=number] Index des Stage
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:RevertStagedQuest(_QuestName)
    local D, C, M = self:GetStagedQuestProgress(_QuestName);
    if M > 0 and C-1 > 0 then
        local Current  = self.Data.StagesForQuest[_QuestName][C].Name;
        local Previous = self.Data.StagesForQuest[_QuestName][C-1].Name;
        API.StopQuest(Current, true);
        API.RestartQuest(Previous, true);
        API.RestartQuest(Current, true);
        return C-1;
    end
    return 0;
end

---
-- Erstellt das Behavior für die Prüfung der Stage.
--
-- @param[type=string] _QuestName  Name des Staged Quest
-- @return[type=function] Behavior
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:GetCheckStagesInlineGoal(_QuestName)
    return 
    function ()
        local StageList = self.Data.StagesForQuest[_QuestName];
        for i= 1, #StageList, 1 do
            local StageQuest = Quests[GetQuestID(StageList[i].Name)];
            -- Nicht existierender Stage bedeutet Fehlschlag
            if not StageQuest then
                return false;
            end
            -- Nicht erwartetes Resultat eines Stage bedeutet Fehlschlag,
            if StageQuest.State == QuestState.Over and StageQuest.Result ~= QuestResult.Interrupted then
                if StageList[i].Result == QSB.StageResult.Success and StageQuest.Result ~= QuestResult.Success then
                    self:AbortFollowingStages(_QuestName);
                    return false;
                end
                if StageList[i].Result == QSB.StageResult.Failure and StageQuest.Result ~= QuestResult.Failure then
                    self:AbortFollowingStages(_QuestName);
                    return false;
                end
            end
        end
        -- Erfolg, wenn letzter Stage beendet ist.
        local StageQuest = Quests[GetQuestID(StageList[#StageList].Name)];
        if StageQuest.State == QuestState.Over and StageQuest.Result ~= QuestResult.Interrupted then
            return true;
        end
    end;
end

---
-- 
--
-- @param[type=string] _QuestName  Name des Staged Quest
-- @return[type=function] Behavior
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:AbortFollowingStages(_QuestName)
    local Current = API.GetCurrentQuestStage(_QuestName);
    local Maximum = API.GetAmountOfQuestStages(_QuestName);
    for i= 1, #self.Data.StagesForQuest[_QuestName], 1 do
        API.StopQuest(self.Data.StagesForQuest[_QuestName][i].Name, true);
    end
end

---
-- Erstellt einen Stage aus der übergebenen Beschreibung.
--
-- @param[type=table]  _Data      Stage Daten
-- @param[type=string] _QuestName Name des Staged Quest
-- @param[type=number] _Index     Index des Stages
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:CreateQuestStage(_Data, _QuestName, _Index)
    local Name = _Data.Name or _QuestName.. "@Stage" .._Index;
    local Parent = Quests[GetQuestID(_QuestName)];

    local QuestDescription = {
        Name        = Name,
        Stages      = _Data.Stages,
        Result      = _Data.Result or QSB.StageResult.Success,
        Sender      = _Data.Sender or Parent.SendingPlayer,
        Receiver    = _Data.Receiver or Parent.ReceivingPlayer,
        Time        = _Data.Time,
        Suggestion  = _Data.Suggestion,
        Success     = _Data.Success,
        Failure     = _Data.Failure,
        Description = _Data.Description,
        Loop        = _Data.Loop,
        Callback    = _Data.Callback,
    };
    for i= 1, #_Data do
        table.insert(QuestDescription, _Data[i]);
    end

    local Waittime = 0 + ((_Data.Suggestion ~= nil and 6) or 0);
    if _Index == 1 then
        table.insert(QuestDescription, Trigger_OnQuestActive(_QuestName, Waittime));
    else
        local PrevStageData = self.Data.StagesForQuest[_QuestName][_Index -1];
        local PrevQuestData = Quests[GetQuestID(PrevStageData.Name)];
        Waittime = Waittime + (((PrevQuestData[15] ~= nil or PrevQuestData[15] ~= nil) and 6) or 0);
        local QuestBriefingType = self:ContainsBriefing(PrevStageData);
        if QuestBriefingType > 0 then
            -- Einschränkung für Briefing Trigger bestimmen.
            local BriefingTriggerType = "All";
            if PrevStageData.Result == QSB.StageResult.Success and QuestBriefingType == 1 then
                BriefingTriggerType = "Success";
            elseif PrevStageData.Result == QSB.StageResult.Failure and QuestBriefingType ==  2 then
                BriefingTriggerType = "Failure";
            end
            table.insert(QuestDescription, Trigger_Briefing(PrevStageData.Name, BriefingTriggerType, Waittime));
        else
            -- Bestimmen, welcher Trigger genutzt wird.
            if PrevStageData.Result == QSB.StageResult.Success then
                table.insert(QuestDescription, Trigger_OnQuestSuccess(PrevStageData.Name, Waittime));
            elseif PrevStageData.Result == QSB.StageResult.Failure then
                table.insert(QuestDescription, Trigger_OnQuestFailure(PrevStageData.Name, Waittime));
            else
                table.insert(QuestDescription, Trigger_OnQuestOver(PrevStageData.Name, Waittime));
            end
        end
    end

    if QuestDescription.Stages then
        self:CreateStagedQuest(QuestDescription);
    else
        local QuestName = API.CreateQuest(QuestDescription);
        local Quest = Quests[GetQuestID(QuestName)];
        if Quest then
            Quests[GetQuestID(QuestName)].SkipFunction = _Data.Skip;
        end
    end
    table.insert(self.Data.StagesForQuest[_QuestName], QuestDescription);
end

---
-- Pfüft, ob ein Briefing in den übergebenen Questdaten vorhanden ist.
--
-- @param[type=table]  _Description Quest Daten
-- @return[type=number] Briefing Typ
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:ContainsBriefing(_Description)
    if BundleBriefingSystem then
        for i= 1, #_Description, 1 do
            if _Description[i].Name then
                if _Description[i].Name == "Reward_Briefing" then
                    return 1;
                elseif _Description[i].Name == "Reprisal_Briefing" then
                    return 2;
                end
            end
        end
    end
    return 0;
end

---
-- Überschreibt das Mapping der Konsolenbefehle des Debugs.
--
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:OverrideMethods()
    table.insert(AddOnQuestDebug.Global.Data.DebugCommands, {
        "forward", self.SetQuestState, 1
    });
    table.insert(AddOnQuestDebug.Global.Data.DebugCommands, {
        "revert",  self.SetQuestState, 2
    });

    -- FailQuest überschreiben
    API.FailQuest_Orig_AddOnQuestStages = API.FailQuest;
    API.FailQuest = function(_QuestName, _Verbose)
        local StageAmount  = AddOnQuestStages.Global:GetAmountOfQuestStages(_QuestName);
        
        if StageAmount > 0 then
            for k, v in pairs(AddOnQuestStages.Global.Data.StagesForQuest[_QuestName]) do
                API.StopQuest_Orig_AddOnQuestStages(v.Name, true);
            end
        end
        API.FailQuest_Orig_AddOnQuestStages(_QuestName, _Verbose);
    end
    FailQuestByName = API.FailQuest;

    -- RestartQuest überschreiben
    API.RestartQuest_Orig_AddOnQuestStages = API.RestartQuest;
    API.RestartQuest = function(_QuestName, _Verbose)
        local StageAmount  = AddOnQuestStages.Global:GetAmountOfQuestStages(_QuestName);
        
        if StageAmount > 0 then
            for k, v in pairs(AddOnQuestStages.Global.Data.StagesForQuest[_QuestName]) do
                API.StopQuest_Orig_AddOnQuestStages(v.Name, true);
                API.RestartQuest_Orig_AddOnQuestStages(v.Name, true);
            end
        end
        API.RestartQuest_Orig_AddOnQuestStages(_QuestName, _Verbose);
    end
    RestartQuestByName = API.RestartQuest;

    -- StartQuest überschreiben
    API.StartQuest_Orig_AddOnQuestStages = API.StartQuest;
    API.StartQuest = function(_QuestName, _Verbose)
        local StageAmount  = AddOnQuestStages.Global:GetAmountOfQuestStages(_QuestName);
        
        if StageAmount > 0 then
            for k, v in pairs(AddOnQuestStages.Global.Data.StagesForQuest[_QuestName]) do
                API.StopQuest_Orig_AddOnQuestStages(v.Name, true);
            end
            API.StartQuest_Orig_AddOnQuestStages(
                AddOnQuestStages.Global.Data.StagesForQuest[_QuestName][1].Name,
                _Verbose
            );
        end
        API.StartQuest_Orig_AddOnQuestStages(_QuestName, _Verbose);
    end
    StartQuestByName = API.StartQuest;

    -- StopQuest überschreiben
    API.StopQuest_Orig_AddOnQuestStages = API.StopQuest;
    API.StopQuest = function(_QuestName, _Verbose)
        local StageAmount  = AddOnQuestStages.Global:GetAmountOfQuestStages(_QuestName);
        
        if StageAmount > 0 then
            for k, v in pairs(AddOnQuestStages.Global.Data.StagesForQuest[_QuestName]) do
                API.StopQuest_Orig_AddOnQuestStages(v.Name, true);
            end
        end
        API.StopQuest_Orig_AddOnQuestStages(_QuestName, _Verbose);
    end
    StopQuestByName = API.StopQuest;

    -- WinQuest überschreiben
    API.WinQuest_Orig_AddOnQuestStages = API.WinQuest;
    API.WinQuest = function(_QuestName, _Verbose)
        local StageAmount  = AddOnQuestStages.Global:GetAmountOfQuestStages(_QuestName);
        
        if StageAmount > 0 then
            for k, v in pairs(AddOnQuestStages.Global.Data.StagesForQuest[_QuestName]) do
                API.StopQuest_Orig_AddOnQuestStages(v.Name, true);
            end
        end
        API.WinQuest_Orig_AddOnQuestStages(_QuestName, _Verbose);
    end
    WinQuestByName = API.WinQuest;
end

---
-- Überschreibt das Mapping der Konsolenbefehle des Debugs.
--
-- @param[type=table]   _Data Befehl
-- @param[type=boolean] _Flag Index
-- @within Internal
-- @local
--
function AddOnQuestStages.Global.SetQuestState(_Data, _Flag)
    local FoundQuests = AddOnQuestDebug.Global.FindQuestNames(_Data[2], true);
    if #FoundQuests ~= 1 then
        API.Note("Unable to find quest containing '" .._Data[2].. "'");
        return "Unable to find quest containing '" .._Data[2].. "'";
    end
    if _Flag == 1 then
        if API.ForwardStagedQuest(FoundQuests[1]) > 0 then
            API.Note("forwarded quest '" ..FoundQuests[1].. "'");
            return "forwarded quest '" ..FoundQuests[1].. "'";
        end
    elseif _Flag == 2 then
        if API.RevertStagedQuest(FoundQuests[1]) > 0 then
            API.Note("reverted quest '" ..FoundQuests[1].. "'");
            return "reverted quest '" ..FoundQuests[1].. "'";
        end
    end
end

---
-- Bricht den Slave Quest des Random Request ab.
-- @param[type=table] _Quest     Quest Data
-- @within Internal
-- @local
--
function AddOnQuestStages.Global:OnQuestSkipped(_Quest)
    if self.Data.StagesForQuest[_Quest.Identifier] then
        for k, v in pairs(self.Data.StagesForQuest[_Quest.Identifier]) do
            API.SkipSingleQuest(v.Name);
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterAddOn("AddOnQuestStages");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnRandomRequests                                          # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle stellt zufällige Aufgaben durch NPC-Spieler bereit.
--
-- Es gibt verschiedene Typen von zufälligen Aufträgen. Es wird versucht, immer
-- einen einzigartigen Auftrag für den jeweiligen Auftraggeber zu erzeugen.
-- Wenn kein Auftrag erzeugt werden kann, wird der Spieler aufgefordert 2000
-- Gold zu bezahlen.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnRandomRequests = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --


-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnRandomRequests = {
    Global = {
        Data = {
            DeliverGoodTypes = {
                "G_Wood", "G_Iron", "G_Stone", "G_Carcass", "G_Herb", "G_Wool",
                "G_Honeycomb", "G_Grain", "G_Milk", "G_RawFish", "G_Bread",
                "G_Cheese", "G_Sausage", "G_SmokedFish", "G_Broom", 
                "G_Medicine", "G_Soap", "G_Beer", "G_Sword", "G_Bow"
            },
            ConstructTypes = {
                "B_Bakery", "B_Dairy", "B_Butcher", "B_SmokeHouse", 
                "B_Soapmaker", "B_Pharmacy", "B_BroomMaker", "B_Baths",
                "B_Tavern", "B_Theatre", "B_Weaver", "B_Tanner",
                "B_Blacksmith", "B_CandleMaker", "B_Carpenter",
                "B_BannerMaker", "B_SwordSmith", "B_BowMaker", "B_Barracks",
                "B_BarracksArchers", "B_SiegeEngineWorkshop",
            },
            ConstructTypesRdO = {
                "B_Beautification_Brazier", "B_Beautification_Pillar",
                "B_Beautification_Shrine", "B_Beautification_StoneBench",
                "B_Beautification_Sundial", "B_Beautification_TriumphalArch",
                "B_Beautification_Vase", "B_Beautification_VictoryColumn",
                "B_Cistern",
            },
            RandomQuestNameCounter = 0;
            TerritoriesUsedForClaimQuest = {},
            TerritoriesUsedForRefillQuests = {},
            UsedBehaviorsPerTitle = {},
            TerritoryPositions = {},
            PrevRandomTypeList = {},

            Text = {
                Suggestion = {
                    {de = "Ihr müsst Euer Können unter Beweis stellen!",
                     en = "Please show us what you are capable of!"},
                    {de = "Bei diesem Problem benötigen wir Eure Unterstützung!",
                     en = "This problem is driving us nuts! Please help us!",},
                    {de = "Euer Volk braucht Eure Hilfe! Werdet Ihr uns helfen?",
                     en = "Your pepole demand your attantion. Will you help them?",},
                },
                Success = {
                    {de = "Wir möchten Euch von Herzen für Eure Hilfe danken!",
                     en = "Let us thank you from the bottem of out hearts!",},
                    {de = "Ihr habt bewiesen, dass man Euch vertrauen kann!",
                     en = "You have proven the trust we have in your, Milord!",},
                    {de = "Gott segne Euch! Wir sind gerettet!",
                     en = "God be praised! You saved us all!",},
                },
                Failure = {
                    {de = "Wir haben Euch vertraut! Mich deucht Euer Wort ist nichts wert!",
                     en = "We trusted you! So that is what your words are worth! Nothing!",},
                    {de = "Anführer! Es sind viele an der Zahl doch taugen alle wenig!",
                     en = "Leaders! They are many but they can't even tie their shoes!",},
                    {de = "Ein Herrscher wollt Ihr sein? Lernt das Volk zu schätzen!",
                     en = "You call yourself a ruler? Go and remember the needs of the pepole!",},
                },
            }
        },
    },
    Local = {
        Data = {}
    },
}

-- Global ----------------------------------------------------------------------

---
-- Initalisiert das AddOn.
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:Install()
end

---
-- Erzeugt einen zufälligen Slave Quest anhand der Einstellungen im Quest.
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:CreateSlaveQuest(_Behavior, _Quest)
    if not _Behavior.SlaveQuest then
        local QuestGoals, QuestTypes = self:GetPossibleBehaviors(_Behavior, _Quest);
        -- Fallback
        if #QuestGoals == 0 then
            local Amount = math.random(250, 300 + (100 * Logic.GetKnightTitle(_Quest.ReceivingPlayer)));
            QuestGoals[#QuestGoals+1] = {"Goal_Deliver", "G_Gold", Amount};
        end
        -- Behavior speichern
        local SelectedIndex = math.random(1, #QuestGoals);
        local SelectedGoal = QuestGoals[SelectedIndex];
        table.insert(self.Data.PrevRandomTypeList, QuestTypes[SelectedIndex]);
        if #self.Data.PrevRandomTypeList > 5 then
            table.remove(self.Data.PrevRandomTypeList, 1);
        end
        -- Slave Quest vorbereiten
        if SelectedGoal[1] == "Goal_ActivateObject" then
            API.InteractiveObjectActivate(SelectedGoal[2]);
        elseif SelectedGoal[1] == "Goal_SatisfyNeed" then
            API.SetNeedSatisfaction(Needs.Medicine, 0.0, _Quest.SendingPlayer);
        elseif SelectedGoal[1] == "Goal_Refill" then
            self.Data.TerritoriesUsedForRefillQuests[SelectedGoal[2]] = true;
            API.SetResourceAmount(SelectedGoal[2], 0, 250);
        end
        local FunctionName = table.remove(SelectedGoal, 1);

        self.Data.RandomQuestNameCounter = self.Data.RandomQuestNameCounter +1;
        local QuestName = API.CreateQuest {
            Name        = "RandomRequest_Player" .._Quest.SendingPlayer.. "_" ..self.Data.RandomQuestNameCounter;
            Suggestion  = _Behavior.OptionalSuggestion or self.Data.Text.Suggestion[math.random(1, 3)],
            Success     = _Behavior.OptionalSuccess or self.Data.Text.Success[math.random(1, 3)],
            Failure     = _Behavior.OptionalFailure or self.Data.Text.Failure[math.random(1, 3)],
            Receiver    = _Quest.ReceivingPlayer,
            Sender      = _Quest.SendingPlayer,
            Time        = _Behavior.TimeLimit,

            _G[FunctionName](unpack(SelectedGoal)),
            Trigger_Time(Logic.GetTime() +5),
        };
        _Behavior.SlaveQuest = Quests[GetQuestID(QuestName)];
    end
end

---
-- Gibt eine Liste mit Behavior zurück, die für den Random Quest verfügbar
-- sind. Es wird eines der Behavior ausgewählt.
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Liste der Behavior
-- @return[type=table] Liste der Typen
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetPossibleBehaviors(_Behavior, _Quest)
    local QuestGoals = {};
    local QuestTypes = {};

    if _Behavior.TypeConstruct then
        if not API.TraverseTable("TypeConstruct", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetConstructBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeConstruct";
        end
    end
    if _Behavior.TypeRefill then
        if not API.TraverseTable("TypeRefill", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetRefillBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeRefill";
        end
    end
    if _Behavior.TypeObject then
        if not API.TraverseTable("TypeObject", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetObjectBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeObject";
        end
    end
    if _Behavior.TypeCureSettlers then
        if not API.TraverseTable("TypeCureSettlers", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetCureSettlersBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeCureSettlers";
        end
    end
    if _Behavior.TypeFind then
        if not API.TraverseTable("TypeFind", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetFindBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeFind";
        end
    end
    if _Behavior.TypeHuntPredators then
        if not API.TraverseTable("TypeHuntPredators", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetHuntPredatorBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeHuntPredators";
        end
    end
    if _Behavior.TypeDeliverGoods then
        if not API.TraverseTable("TypeDeliverGoods", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetDeliverGoodsBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeDeliverGoods";
        end
    end
    if _Behavior.TypeDeliverGold then
        if not API.TraverseTable("TypeDeliverGold", self.Data.PrevRandomTypeList) then
            local Amount = math.random(250, 300 + (100 * Logic.GetKnightTitle(_Quest.ReceivingPlayer)));
            QuestGoals[#QuestGoals+1] = {"Goal_Deliver", "G_Gold", Amount};
            QuestTypes[#QuestTypes+1] = "TypeDeliverGold";
        end
    end
    if _Behavior.TypeClaim then
        if not API.TraverseTable("TypeClaim", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetClaimTerritoryBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeClaim";
        end
    end
    if _Behavior.TypeKnightTitle then
        if not API.TraverseTable("TypeKnightTitle", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetKnightTitleBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeKnightTitle";
        end
    end
    if _Behavior.TypeReputation then
        if not API.TraverseTable("TypeReputation", self.Data.PrevRandomTypeList) then
            local Reputation = 15 + (13 * Logic.GetKnightTitle(_Quest.ReceivingPlayer));
            QuestGoals[#QuestGoals+1] = {"Goal_CityReputation", Reputation};
            QuestTypes[#QuestTypes+1] = "TypeReputation";
        end
    end
    if _Behavior.TypeBuildWall then
        if not API.TraverseTable("TypeBuildWall", self.Data.PrevRandomTypeList) then
            QuestGoals[#QuestGoals+1] = self:GetBuildWallBehavior(_Behavior, _Quest);
            QuestTypes[#QuestTypes+1] = "TypeBuildWall";
        end
    end
    return QuestGoals, QuestTypes;
end

---
-- Bricht den Slave Quest des Random Request ab.
-- @param[type=table] _Quest     Quest Data
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:OnQuestSkipped(_Quest)
    for k, v in pairs(_Quest.Objectives) do
        if  type(v) == "table" 
        and v.Type == Objective.Custom2 
        and v.Data
        and v.Data[1]
        and v.Data[1].Name:find("Goal_RandomRequest")
        and v.Data[1].SlaveQuest then
            v.Data[1].SlaveQuest:Interrupt();
        end
    end
end

-- Behaviors ---------------------------------------------------------------- --

---
-- Erstellt ein Goal_Create, das den Spieler dazu bringt ein zufälliges
-- Gebäude auf dem Heimatterritorium zu bauen.
--
-- <b>Hinweis</b>: Auswahl hängt vom aktuellen Titel ab. Jedes Gebäude wird
-- nur einmal ausgewählt und ist für den Rest des Spiels gesperrt.
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetConstructBehavior(_Behavior, _Quest)
    local AllTerritories = self:GetTerritoriesOfPlayer(_Quest.ReceivingPlayer);
    if #AllTerritories == 0 then
        return;
    end

    local Type;
    local TerritoryID;
    local Amount;

    -- Gebäude ermitteln
    local Buildings = {};
    local PossibleBuildings = API.InstanceTable(self.Data.ConstructTypes);
    if g_GameExtraNo > 0 then
        PossibleBuildings = Array_Append(PossibleBuildings, API.InstanceTable(self.Data.ConstructTypesRdO));
    end
    for k, v in pairs(PossibleBuildings) do
        local ProductType = Logic.GetProductOfBuildingType(Entities[v]);
        if API.CanPlayerCurrentlyProduceGood(QSB.HumanPlayerID, ProductType) then
            table.insert(Buildings, v);
        end
    end
    if #Buildings == 0 then
        return;
    end
    Type = Buildings[math.random(1, #Buildings)];
    -- Territorium ermitteln
    TerritoryID = GetTerritoryUnderEntity(Logic.GetStoreHouse(_Quest.ReceivingPlayer));
    if TerritoryID == 0 then
        return;
    end
    -- Menge bestimmen
    -- (Anzahl an vorhandenen Gebäuden + 1 neues)
    local EntitiesOfType = GetPlayerEntities(_Quest.ReceivingPlayer, Entities[Type]);
    for i= #EntitiesOfType, 1, -1 do
        if GetTerritoryUnderEntity(EntitiesOfType[i]) ~= TerritoryID then
            table.remove(EntitiesOfType, i);
        end
    end
    Amount = #EntitiesOfType +1;
    -- Behavior erzeugen
    return {"Goal_Create", Type, Amount, TerritoryID};
end

---
-- Erstellt ein Goal_ActivateObject für ein Objekt auf dem Gebiet des
-- Auftraggeber. Der Spieler muss dieses Objekt dann aktivieren.
--
-- Auswählbare Objekte müssen den Namen IORR tragen und fortlauend nummeriert
-- sein. Außerdem müssen es Entities vom Typ I_X_* sein.
--
-- <b>Hinweis</b>: Jedes Objekt wird nur einmal ausgewählt. Tigerhöhlen 
-- erzeugen Raubtierspawnpunkte!
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetObjectBehavior(_Behavior, _Quest)
    local KnightTitle = Logic.GetKnightTitle(_Quest.ReceivingPlayer);

    -- Objekte finden
    local Objects = {};
    local Index = 1;
    while (true) do
        local Name = "IORR" ..Index;
        if not IsExisting(Name) then
            break;
        end
        if string.find(Logic.GetEntityTypeName(Logic.GetEntityType(GetID(Name))), "I_X_") 
        and Logic.GetTerritoryPlayerID(GetTerritoryUnderEntity(GetID(Name))) == _Quest.SendingPlayer then
            table.insert(Objects, Name);
        end
        Index = Index +1;
    end

    -- Behavior erzeugen
    if #Objects > 0 then
        local Name = Objects[math.random(1, #Objects)];
        local Type = Logic.GetEntityType(GetID(Name));
        local TypeName = Logic.GetEntityTypeName(Type);
        local PlayerID = _Quest.SendingPlayer;
        local Costs;
        local Reward;
        local Action;

        -- Signalfeuer entzünden
        if TypeName == "I_X_BigFire_Base" then
            Costs = {Goods.G_Wood, 20 + (3*KnightTitle)};
            Action = function(_Data)
                local Orientation = Logic.GetEntityOrientation(GetID(_Data.Name));
                local Position = GetPosition(_Data.Name);
                Logic.CreateEntity(Entities.D_X_BigFire_Fire, Position.X, Position.Y, Orientation, 0);
                Logic.SetVisible(GetID(_Data.Name), false);
            end
        elseif TypeName == "I_X_SignalFire_Base" then
            Costs = {Goods.G_Wood, 30 + (3*KnightTitle)};
            Action = function(_Data)
                local Orientation = Logic.GetEntityOrientation(GetID(_Data.Name));
                local Position = GetPosition(_Data.Name);
                Logic.CreateEntity(Entities.D_X_SignalFire_Fire, Position.X, Position.Y, Orientation, 0);
                Logic.SetVisible(GetID(_Data.Name), false);
            end
        elseif TypeName == "I_X_Holy_Cow" then
            Costs = {Goods.G_Grain, 30 + (5*KnightTitle)};
        -- Gefangenen freikaufen
        elseif TypeName:find("Prison") then
            PlayerID = _Quest.ReceivingPlayer;
            Costs = {Goods.G_Gold, 250 + (50*KnightTitle)};
            Action = function(_Data)
                local Pos  = API.GetRelativePosition(_Data.Name, 200, -90);
                local Type = API.GetRandomSettlerType();
                local ID   = Logic.CreateEntityOnUnblockedLand(Type, Pos.X, Pos.Y, 0, _Data.Owner);
                Logic.SetTaskList(ID, TaskLists.TL_WAIT_THEN_WALK);
            end
        -- Faulen Harzer finden
        elseif TypeName == "I_X_NPC_Decay_Hut" then
            Action = function(_Data)
                local Pos  = API.GetRelativePosition(_Data.Name, 200, -90);
                local Type = API.GetRandomSettlerType();
                local ID   = Logic.CreateEntityOnUnblockedLand(Type, Pos.X, Pos.Y, 0, _Data.Owner);
                Logic.SetTaskList(ID, TaskLists.TL_WAIT_THEN_WALK);
            end
        -- Khana-Tempel entzünden
        elseif TypeName == "I_X_KhanaTemple" then
            Costs = {Goods.G_Honeycomb, 30 + (3*KnightTitle)};
            Action = function(_Data)
                local Orientation = Logic.GetOrientation(GetID(_Data.Name));
                local Position    = GetPosition(_Data.Name);
                Logic.CreateEntity(Entities.B_KhanaTemple, Position.X, Position.Y, Orientation, _Data.PlayerID);
                Logic.SetVisible(GetID(_Data.Name), false);
            end
        -- Ein Brunnen wird repariert
        elseif TypeName == "I_X_Well_Destroyed" then
            Costs = {Goods.G_Stone, 20 + (3*KnightTitle)};
            Action = function(_Data)
                local Position = GetPosition(_Data.Name);
                local Orientation = Logic.GetEntityOrientation(GetID(_Data.Name));
                Logic.CreateEntity(Entities.D_NA_Well_Repaired, Position.X, Position.Y, Orientation, 0);
                Logic.SetVisible(GetID(_Data.Name), false);
            end
        -- Tigerhöle plündern, aber... ;)
        elseif TypeName == "I_X_TigerCave" then
            Reward = {Goods.G_Gems, 20 + (5*KnightTitle)};
            Action = function(_Data)
                local Pos  = API.GetRelativePosition(_Data.Name, 300, -90);
                local ID   = Logic.CreateEntityOnUnblockedLand(Entities.S_TigerPack_AS, Pos.X, Pos.Y, 0, 0);
            end
        -- Alle anderen Typen enthalten einfach Gold
        else
            Reward = {Goods.G_Gold, 150 + (35*KnightTitle)};
        end

        -- Objekt erzeugen
        API.CreateObject{
            Name        = Name,
            Distance    = 1500,
            Waittime    = 5,
            Reward      = Reward,
            Costs       = Costs,
            PlayerID    = PlayerID,
            Callback    = Action,
        };
        API.InteractiveObjectDeactivate(Name);
        -- Behavior erzeugen
        return {"Goal_ActivateObject", Name};
    end
end

---
-- Erstellt ein Goal_SatisfyNeed für den Auftraggeber und macht alle seine
-- Siedler krank. Der Spieler muss sich dann was einfallen lassen...
--
-- <b>Hinweis</b>: Dieses Behavior kann nur auftauchen, wenn die Zielpartei
-- keine Apotheke hat und man schon Handelsrechte hat. Außerdem auch nicht,
-- wenn die Partei Medizin verkauft.
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetCureSettlersBehavior(_Behavior, _Quest)
    local KnightTitle = Logic.GetKnightTitle(_Quest.ReceivingPlayer);
    local Pharmacies = GetPlayerEntities(_Quest.SendingPlayer, Entities.B_Pharmacy);
    if self:CanGoodBeSetAsGoal(_Quest.SendingPlayer, _Quest.ReceivingPlayer, Goods.G_Medicine)
    or #Pharmacies == 0 or GetDiplomacyState(_Quest.SendingPlayer, _Quest.ReceivingPlayer) > 0 then
        local CityBuildings  = {Logic.GetPlayerEntitiesInCategory(_Quest.SendingPlayer, EntityCategories.CityBuilding)};
        local OuterBuildings = {Logic.GetPlayerEntitiesInCategory(_Quest.SendingPlayer, EntityCategories.OuterRimBuilding)};
        local AllBuildings = Array_Append(CityBuildings, OuterBuildings);
        if #AllBuildings > 0 then
            return {"Goal_SatisfyNeed", _Quest.SendingPlayer, "Medicine"};
        end
    end
end

---
-- Erstellt ein Goal_CollectValuables das den Spieler 5 Gegenstände einer
-- anderen Partei finden lässt. Diese Gegenstände haben ein zufälliges
-- Model (Hammer, Sense, Messer, Sack, Kiste).
--
-- <b>Hinweis</b>: Das Behavior kann für jede Partei nur einmal pro erreichtem
-- Titel des Spielers auftreten. Es wird nicht auftreten, wenn die fordernde
-- Partei nicht mindestens 5 Gebäude hat.
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetFindBehavior(_Behavior, _Quest)
    local SH1ID = Logic.GetStoreHouse(_Quest.ReceivingPlayer);
    local SH2ID = Logic.GetStoreHouse(_Quest.SendingPlayer);
    if not CanEntityReachTarget(_Quest.ReceivingPlayer, SH1ID, SH2ID, nil, PlayerSectorTypes.Military) then
        return;
    end
    local KnightTitle = Logic.GetKnightTitle(_Quest.ReceivingPlayer);
    local FindAmount = 5;
    local EntitiesToFind = self:GetRandomBuildingsForFindQuest(_Quest.SendingPlayer, FindAmount);
    if #EntitiesToFind >= FindAmount then
        local Positions = {};
        for i= 1, FindAmount, 1 do
            table.insert(Positions, self:GetPositionNearBuilding(EntitiesToFind[i]));
        end
        return {"Goal_CollectValuables", Positions, "-", 0};
    end
end

---
-- Erstellt ein Goal_Refill das den Spieler eine Mine auffüllen lässt. Es wird
-- eine Mine ausgewählt und per Skript geleert.
--
-- <b>Hinweis</b>: Dieses Behavior kann nur dann auftauchen, wenn der
-- Zielspieler noch nicht benutzte Minen auf seinem Territorium hat.
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetRefillBehavior(_Behavior, _Quest)
    local AllMines = Array_Append(
        self:GetWorldEntitiesOnPlayersTerritories(Entities.R_IronMine, _Quest.SendingPlayer),
        self:GetWorldEntitiesOnPlayersTerritories(Entities.R_StoneMine, _Quest.SendingPlayer)
    );
    for i= 1, #AllMines, 1 do
        if not self.Data.TerritoriesUsedForRefillQuests[AllMines[i]] then
            return {"Goal_Refill", AllMines[i]};
        end
    end
end

---
-- Erstellt ein Goal_DestroySpawnedEntities das den Spieler fordert Raubtiere
-- am nächst gelegenen Spawnpoint zu erledigen.
--
-- <b>Hinweis</b>: Dieses Behavior kann nur dann auftauchen, wenn es noch nicht
-- verwendete Spawnpoints gibt.
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetHuntPredatorBehavior(_Behavior, _Quest)
    local SpawnPoint = self:GetClosestPredatorSpawnByQuest(_Behavior, _Quest);
    if SpawnPoint == nil then
        return;
    end
    local MaxCapacity = Logic.RespawnResourceGetMaxCapacity(SpawnPoint);
    return {"Goal_DestroySpawnedEntities", SpawnPoint, MaxCapacity, false};
end

---
-- Erstellt Goal_KnightTitle für den Random Quest.
--
-- <b>Hinweis</b>: Dieses Behavior kann nur dann auftauchen, wenn der Spieler
-- noch einen höheren Titel erreichen kann. Außerdem wird jeder Titel nur
-- genau einmal gefordert.
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetKnightTitleBehavior(_Behavior, _Quest)
    if Logic.GetKnightTitle(_Quest.ReceivingPlayer) < KnightTitles.Archduke then
        local PossibleTitles = {"Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"};
        local NextTitleID = Logic.GetKnightTitle(_Quest.ReceivingPlayer)+1;
        local NextTitle = PossibleTitles[NextTitleID];
        local GoodsToCheck = {};

        -- Check Titel
        if not NextTitleID or IsKnightTitleLockedForPlayer(_Quest.ReceivingPlayer, NextTitleID) then
            return;
        end
        -- Check Category durch Abbruch ... sonst zu komplex und mich
        -- bezahlt ja niemand für den Scheiß. :P
        if KnightTitleRequirements[NextTitleID].Category then
            return;
        end
        -- Check Güter
        if KnightTitleRequirements[NextTitleID].Goods then
            for k, v in pairs(KnightTitleRequirements[NextTitleID].Goods) do
                table.insert(GoodsToCheck, v[1]);
            end
        end
        -- Check Consume Güter
        if KnightTitleRequirements[NextTitleID].Consume then
            for k, v in pairs(KnightTitleRequirements[NextTitleID].Consume) do
                table.insert(GoodsToCheck, v[1]);
            end
        end
        -- Check Gebäude
        if KnightTitleRequirements[NextTitleID].Entities then
            for k, v in pairs(KnightTitleRequirements[NextTitleID].Entities) do
                local ProductType = Logic.GetProductOfBuildingType(v[1]);
                table.insert(GoodsToCheck, API.GetResourceOfProduct(v[1]));
            end
        end

        -- Nun ermittelte Rohstoffe auf Produzierbarkeit prüfen
        for k, v in pairs(GoodsToCheck) do
            if not API.CanPlayerCurrentlyProduceGood(QSB.HumanPlayerID, v) then
                return;
            end
        end
        -- Check Products seperat
        if KnightTitleRequirements[NextTitleID].Products then
            for k, v in pairs(KnightTitleRequirements[NextTitleID].Products) do
                local AtLeastOneCanBeProduces = false;
                for _,g in ipairs{Logic.GetGoodTypesInGoodCategory(v[1])} do
                    if API.CanPlayerCurrentlyProduceGood(QSB.HumanPlayerID, g) then
                        AtLeastOneCanBeProduces = true;
                    end
                end
                if not AtLeastOneCanBeProduces then
                    return;
                end
            end
        end
        -- Behavior erzeugen
        return {"Goal_KnightTitle", NextTitle};
    end 
end

---
-- Erstellt Goal_BuildWall für den Random Quest.
--
-- <b>Hinweis</b>: Dieses Behavior kann nur dann auftauchen, wenn der Spieler
-- mindestens einen Feind hat.
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetBuildWallBehavior(_Behavior, _Quest)
    local FirstEnemy;
    for i= 1, 8, 1 do
        if i ~= _Quest.SendingPlayer and i ~= _Quest.ReceivingPlayer and DiplomaticEntity.GetRelationBetween(i, _Quest.ReceivingPlayer) == DiplomacyStates.Enemy then
            FirstEnemy = i;
            break;
        end
    end
    if FirstEnemy then
        local SPStorehouse = Logic.GetStoreHouse(_Quest.SendingPlayer);
        local RPStorehouse = Logic.GetStoreHouse(_Quest.ReceivingPlayer);
        return {"Goal_BuildWall", FirstEnemy, RPStorehouse, SPStorehouse};
    end
end

---
-- Erstellt Goal_Claim für den Random Quest. Nur Territorien ohne Besitzer
-- (Spieler 0) werden berücksichtigt.
--
-- <b>Hinweis</b>: Dieses Behavior kann nur auftauchen, wenn es mindestens 1
-- neutrales Territorium gibt.
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetClaimTerritoryBehavior(_Behavior, _Quest)
    local AllTerritories = self:GetTerritoriesOfPlayer(0);
    for i= #AllTerritories, 1, -1 do
        if self.Data.TerritoriesUsedForClaimQuest[AllTerritories[i]] then
            table.remove(AllTerritories, i);
        end
    end
    for i= #AllTerritories, 1, -1 do
        if not self:IsTerritoryReachable(_Quest.ReceivingPlayer, AllTerritories[i]) then
            table.remove(AllTerritories, i);
        end
    end
    if #AllTerritories > 0 then
        local Territory = AllTerritories[math.random(1, #AllTerritories)];
        self.Data.TerritoriesUsedForClaimQuest[Territory] = true;
        return {"Goal_Claim", AllTerritories[math.random(1, #AllTerritories)]};
    end
end

---
-- Erstellt Goal_Deliver (Rohstoffe) für den Random Quest.
--
-- <b>Hinweis</b>: Es können nur Waren auftauchen, die nicht auf der Blacklist
-- der Zielpartei stehen. Vorsicht bei verbotenen Technologien!
--
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=table] Behavior
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetDeliverGoodsBehavior(_Behavior, _Quest)
    local Receiver = _Quest.ReceivingPlayer;
    local Sender   = _Quest.SendingPlayer;
    -- Freie Güter selektieren
    local GoodTypes = {};
    for k, v in pairs(self.Data.DeliverGoodTypes) do
        if self:CanGoodBeSetAsGoal(Sender, Receiver, Goods[v]) then
            table.insert(GoodTypes, v);
        end
    end
    -- Ware ermitteln
    if #GoodTypes == 0 then
        return;
    end
    local SelectedGood = GoodTypes[math.random(1, #GoodTypes)];
    -- Menge ermitteln
    local IsResource = Logic.GetGoodCategoryForGoodType(Goods[SelectedGood]) == GoodCategories.GC_Resource;
    local IsGold = Goods[SelectedGood] == Goods.G_Gold;
    local Amount = math.random(250, 300 + (100 * Logic.GetKnightTitle(Receiver)));
    if not IsGold then
        Amount = math.random(25, 50);
        if not IsResource then
            Amount = math.random(9, 18);
        end
    end
    return {"Goal_Deliver", SelectedGood, Amount};
end 

-- Helper ------------------------------------------------------------------- --


---
-- Bestimmt eine zufällige Position am Gebäude.
-- @param[type=number] _BuildingID ID des Gebäudes
-- @return[type=table] Position beim Gebäude
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetPositionNearBuilding(_BuildingID)
    local Position = {X= 0, Y= 0, Z= 0};
    if IsExisting(_BuildingID) then
        local RelPos = GetPosition(_BuildingID);
        RelPos.X = RelPos.X + math.random(-200, 200);
        RelPos.Y = RelPos.Y + math.random(-200, 200);

        local ID = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, RelPos.X, RelPos.Y, 0, 0);
        local x, y, z = Logic.EntityGetPos(ID);
        DestroyEntity(ID);

        Position.X = x;
        Position.Y = y;
        Position.Z = z;
    end
    return Position;
end

---
-- Bestimmt eine zufällige Position am Gebäude.
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Amount   Menge an Gebäuden
-- @return[type=table] Position beim Gebäude
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetRandomBuildingsForFindQuest(_PlayerID, _Amount)
    local Buildings = {};
    local AllBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.AttackableBuilding)};
    if #AllBuildings >= _Amount then
        while #Buildings < _Amount do
            local ID = table.remove(AllBuildings, math.random(1, #AllBuildings));
            if not API.TraverseTable(ID, Buildings) then
                table.insert(Buildings, ID);
            end
        end
    end
    return Buildings;
end

---
-- Ermittelt den nächsten Spawnpoint für Raubtiere zum Auftraggeber.
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @return[type=number] ID des Spawnpoint
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetClosestPredatorSpawnByQuest(_Behavior, _Quest)
    local FoundSpawnPoints = {};
    local PredatorSpawnPointTypes = {
        "S_Bear", "S_Bear_Black", "S_BearBlack", "S_LionPack_NA", 
        "S_PolarBear_NE", "S_TigerPack_AS", "S_WolfPack",
    };
    -- Select all
    for i= 1, #PredatorSpawnPointTypes, 1 do
        if Entities[PredatorSpawnPointTypes[i]] then
            local Result = {Logic.GetEntities(Entities[PredatorSpawnPointTypes[i]], 48)};
            if table.remove(Result, 1) > 0 then
                FoundSpawnPoints = Array_Append(FoundSpawnPoints, Result);
            end
        end
    end
    -- Remove already used
    for i= #FoundSpawnPoints, 1, -1 do
        table.remove(FoundSpawnPoints, i);
    end
    -- Find nearest
    if #FoundSpawnPoints > 0 then
        return API.GetEntityNearby(Logic.GetStoreHouse(_Quest.SendingPlayer), FoundSpawnPoints);
    end
end

---
-- Gibt alle Territorien des Spielers zurück. Spieler 0 ist ebenfalls möglich.
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=table] Liste der Territorien
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetTerritoriesOfPlayer(_PlayerID)
    local FoundTerritories = {};
    local AllTerritories = {Logic.GetTerritories()};
    for i= 1, #AllTerritories, 1 do
        if AllTerritories[i] ~= 0 and Logic.GetTerritoryPlayerID(AllTerritories[i]) == _PlayerID then
            table.insert(FoundTerritories, AllTerritories[i]);
        end
    end
    return FoundTerritories;
end

---
-- Prüft, ob eine Ware für ein Goal_Deliver verwendet werden kann.
-- @param[type=number] _SenderID   Sendender Spieler
-- @param[type=number] _ReceiverID Empfangender Spieler
-- @param[type=number] _Good       Warentyp
-- @return[type=boolean] Ware kann benutzt werden.
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:CanGoodBeSetAsGoal(_SenderID, _ReceiverID, _Good)
    if not API.CanPlayerCurrentlyProduceGood(_ReceiverID, _Good) then
        return false;
    end
    if not API.HasPlayerAccessToResource(_ReceiverID, _Good, true) then
        return false;
    end
    if MerchantSystem.TradeBlackList[_SenderID] then
        for k, v in pairs(MerchantSystem.TradeBlackList[_SenderID]) do
            if v == _Good then
                return false;
            end
        end
    end
    return true;
end

---
-- Gibt alle Entities des Typs in allen Territorien eines Spielers zurück.
-- Spieler 0 ist ebenfalls möglich.
-- @param[type=number] _Type     Entity Type
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=table] Liste der Entities
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetWorldEntitiesOnPlayersTerritories(_Type, _PlayerID)
    local Result = {};
    local AllEntitiesOfType = {Logic.GetEntities(_Type, 48)};
    local AllTerritories = self:GetTerritoriesOfPlayer(_PlayerID);
    for i= 1, #AllEntitiesOfType, 1 do
        for j= 1, #AllTerritories, 1 do
            if GetTerritoryUnderEntity(AllEntitiesOfType[i]) == AllTerritories[j] then
                local x, y   = Logic.GetEntityPosition(AllEntitiesOfType[i]);
                local TestID = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, x, y, 0, 0);
                local SH1ID  = Logic.GetStoreHouse(_PlayerID);
                if CanEntityReachTarget(_PlayerID, SH1ID, TestID, nil, PlayerSectorTypes.Military) then
                    table.insert(Result, AllEntitiesOfType[i]);
                end
                DestroyEntity(TestID);
            end
        end
    end
    return Result;
end

---
-- Prüft, ob das Territrium erreicht werden kann.
-- @param[type=number] _PlayerID    ID des Spielers
-- @param[type=number] _TerritoryID ID des Territoriums
-- @return[type=boolean] Territorium ist erreichbar
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:IsTerritoryReachable(_PlayerID, _TerritoryID)
    if self.Data.TerritoryPositions[_TerritoryID] then
        local TestID = Logic.CreateEntityOnUnblockedLand(
            Entities.XD_ScriptEntity,
            self.Data.TerritoryPositions[_TerritoryID].X,
            self.Data.TerritoryPositions[_TerritoryID].Y,
            0,
            0
        );
        local SH1ID = Logic.GetStoreHouse(_PlayerID);
        if CanEntityReachTarget(_PlayerID, SH1ID, TestID, nil, PlayerSectorTypes.Military) then
            DestroyEntity(TestID);
            return true;
        end
        DestroyEntity(TestID);
    end
    return false;
end

-- Local ----------------------------------------------------------------------

---
-- Initalisiert das AddOn.
-- @within Internal
-- @local
--
function AddOnRandomRequests.Local:Install()
    self:SaveTerritoryPosition();
end

---
-- Speichert die Position der Territorien im globalen Skript.
-- @within Internal
-- @local
--
function AddOnRandomRequests.Local:SaveTerritoryPosition()
    local Territories = {Logic.GetTerritories()};
    for i= 1, #Territories, 1 do
        local x, y = GUI.ComputeTerritoryPosition(Territories[i]);
        GUI.SendScriptCommand(string.format([[
            AddOnRandomRequests.Global.Data.TerritoryPositions[%d] = {
                X = %f, Y = %f
            }
        ]], Territories[i], x * 1.0, y * 1.0))
    end
end

-- -------------------------------------------------------------------------- --

---
-- Wählt einen zufälligen Auftrag für den Spieler aus. Über die Parameter kann
-- bestimmt werden, welche Typen von Aufträgen erscheinen können. Dieses
-- Behavior sollte in versteckten Quests benutzt werden.
--
-- Tribute und Warenanforderungen steigen in der Menge mit höherem Titel
-- des Auftragnehmers.
--
-- Dem Spieler können entweder keine Wiederholungen, eine feste Anzahl an
-- Wiederholungen oder unendliche Wiederholungen gewährt werden. Das Behavior
-- scheitert nur dann endgültig, wenn keine Versuche übrig sind.
--
-- <b>Wichtig</b>:
-- <ul>
-- <li>Die Option <i>_Goods</i> kann Rohstoffe wählen, die der Spieler wegen
-- Ausgeblendetem Baumenü u.ä. nicht erlangen kann! In diesem Fall muss die
-- Ware Auf die Blacklist des Auftraggebers gesetzt werden!</li>
-- <li>Die Option _Object benötigt interaktive Objekte, die "IORR" heißen und
-- von 1 bis n fortlaufend nummeriert sind.</li>
-- <li>Die Option _Object erzeugt u.U. Raubtierspawnpoints (Tigerhöhle)!</li>
-- </ul>
--
-- <b>Hinweis</b>: Das Behavior erzeugt einen weiteren Quest mit dem zufällig
-- gewählten Ziel. Somit ist es mit den Tribut-Quests vergleichbar. Wird
-- Random Requests neu gestartet wird ein neuer Zufalls-Quest erstellt.
--
-- <b>Hinweis</b>: Es kann vorkommen, das bestimmte Auftragsarten unter gewissen
-- Voraussetzungen fälschlich sofort als erfolgreich abgeschlossen gelten. (z.B.
-- Monsun während Build Wall)
--
-- @param[type=boolean] _Goods      Ziel: Waren liefern
-- @param[type=boolean] _Gold       Ziel: Tribut bezahlen
-- @param[type=boolean] _Claim      Ziel: Territorium erobern
-- @param[type=boolean] _Title      Ziel: Nächst höherer Titel
-- @param[type=boolean] _Reputation Ziel: Ruf der Stadt
-- @param[type=boolean] _Walls      Ziel: Stadt mit einer Mauer schützen
-- @param[type=boolean] _Predator   Ziel: Raubtiere vernichten
-- @param[type=boolean] _Mine       Ziel: Verschüttete Mine auffüllen
-- @param[type=boolean] _Find       Ziel: Gegenstände suchen
-- @param[type=boolean] _Cure       Ziel: Kranke Siedler heilen
-- @param[type=boolean] _Object     Ziel: Zufällig gewähltes Objekt aktivieren
-- @param[type=boolean] _Build      Ziel: Zufällig gewähltes Gebäude bauen
-- @param[type=number]  _Time       Zeit bis zur Niederlage (0 = aus)
-- @param[type=number]  _Repeat     Wiederholungen (-1 = endlos, 0 = aus)
-- @param[type=string]  _Suggestion (optional) Startnachricht
-- @param[type=string]  _Success    (optional) Erfolgsnachricht
-- @param[type=string]  _Failure    (optional) Fehlschlagnachricht
--
-- @within Goal
--
function Goal_RandomRequest(...)
    return b_Goal_RandomRequest:new(...);
end

b_Goal_RandomRequest = {
    Name = "Goal_RandomRequest",
    Description = {
        en = "Goal: Der Spieler erhält einen zufällig generierten Auftrag, der erfüllt werden muss. Über die Parameter wird bestimmt, welche Typen von Aufträgen möglich sind. Tipp: Für versteckten Quest nutzen!",
        de = "Ziel: The player receives an randomly generated quest that he needs to complete. Define which types of quest possibly appear by setting the parameters. Tip: Use this quest as invisible quest!",
    },
    Parameter = {
        { ParameterType.Custom,  en = "Deliver goods",                  de = "Waren liefern" },
        { ParameterType.Custom,  en = "Pay tribute",                    de = "Tribut entrichten" },
        { ParameterType.Custom,  en = "Claim territory",                de = "Territorium beanspruchen" },
        { ParameterType.Custom,  en = "Knight title",                   de = "Titel erreichen" },
        { ParameterType.Custom,  en = "City reputation",                de = "Ruf der Stadt" },
        { ParameterType.Custom,  en = "Build rampart",                  de = "Festung bauen" },
        { ParameterType.Custom,  en = "Hunt predators",                 de = "Raubtiere vertreiben" },
        { ParameterType.Custom,  en = "Refill mines",                   de = "Minen auffüllen" },
        { ParameterType.Custom,  en = "Find lost objects",              de = "Verlorene Gegenstände finden" },
        { ParameterType.Custom,  en = "Cure sick settlers",             de = "Kranke Siedler heilen" },
        { ParameterType.Custom,  en = "Activate object",                de = "Interaktives Object benutzen" },
        { ParameterType.Custom,  en = "Construct building",             de = "Gebäude bauen" },
        { ParameterType.Number,  en = "Time limit (0 = off)",           de = "Leitlimit (0 = aus)" },
        { ParameterType.Number,  en = "Trials (-1 = endless, 0 = off)", de = "Wiederholungen (-1 = endlos, 0 = aus)" },
        { ParameterType.Default, en = "(optional) Mission text",        de = "(optional) Auftragsnachricht" },
        { ParameterType.Default, en = "(optional) Success text",        de = "(optional) Erfolgsnachricht" },
        { ParameterType.Default, en = "(optional) Failure text",        de = "(optional) Fehlschlagsnachricht" },
    },
}

function b_Goal_RandomRequest:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_RandomRequest:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TypeDeliverGoods = API.ToBoolean(_Parameter);
    elseif (_Index == 1) then
        self.TypeDeliverGold = API.ToBoolean(_Parameter);
    elseif (_Index == 2) then
        self.TypeClaim = API.ToBoolean(_Parameter);
    elseif (_Index == 3) then
        self.TypeKnightTitle = API.ToBoolean(_Parameter);
    elseif (_Index == 4) then
        self.TypeReputation = API.ToBoolean(_Parameter);
    elseif (_Index == 5) then
        self.TypeBuildWall = API.ToBoolean(_Parameter);
    elseif (_Index == 6) then
        self.TypeHuntPredators = API.ToBoolean(_Parameter);
    elseif (_Index == 7) then
        self.TypeRefill = API.ToBoolean(_Parameter);
    elseif (_Index == 8) then
        self.TypeFind = API.ToBoolean(_Parameter);
    elseif (_Index == 9) then
        self.TypeCureSettlers = API.ToBoolean(_Parameter);
    elseif (_Index == 10) then
        self.TypeObject = API.ToBoolean(_Parameter);
    elseif (_Index == 11) then
        self.TypeConstruct = API.ToBoolean(_Parameter);
    elseif (_Index == 12) then
        self.TimeLimit = _Parameter * 1;
    elseif (_Index == 13) then
        self.Trials = _Parameter * 1;
        self.TrialsCounter = self.Trials;
    elseif (_Index == 14) then
        if _Parameter and _Parameter ~= "" then
            self.OptionalSuggestion = _Parameter;
        end
    elseif (_Index == 15) then
        if _Parameter and _Parameter ~= "" then
            self.OptionalSuccess = _Parameter;
        end
    elseif (_Index == 16) then
        if _Parameter and _Parameter ~= "" then
            self.OptionalFailure = _Parameter;
        end
    end
end

function b_Goal_RandomRequest:GetCustomData(_Index)
    return {"true", "false"};
end

function b_Goal_RandomRequest:CustomFunction(_Quest)
    AddOnRandomRequests.Global:CreateSlaveQuest(self, _Quest);
    if self.SlaveQuest then
        if self.SlaveQuest.State == QuestState.Over then
            self:ResetSlave(_Quest);
            if self.TrialsCounter == -1 then
                if self.SlaveQuest.Result == QuestResult.Success then
                    return true;
                end
                self.SlaveQuest = nil;
            elseif self.TrialsCounter > 0 then
                if self.SlaveQuest.Result == QuestResult.Success then
                    return true;
                end
                self.TrialsCounter = self.TrialsCounter -1;
                if self.TrialsCounter == 0 then
                    if self.SlaveQuest.Result == QuestResult.Failure then
                        return false;
                    end
                end
                self.SlaveQuest = nil;
            else
                if self.SlaveQuest.Result == QuestResult.Success then
                    return true;
                end
                if self.SlaveQuest.Result == QuestResult.Failure then
                    return false;
                end
            end
        end
    end
end

function b_Goal_RandomRequest:ResetSlave(_Quest)
    if self.SlaveQuest.Result == QuestResult.Failure then
        local SlaveBehavior = self.SlaveQuest.Objectives[1];
        if SlaveBehavior.Type == Objective.Object then
            API.InteractiveObjectDeactivate(SlaveBehavior.Data[1][1]);
        elseif SlaveBehavior.Type == Objective.SatisfyNeed then
            API.SetNeedSatisfaction(Needs.Medicine, 1.0, _Quest.SendingPlayer);
        elseif SlaveBehavior.Type == Objective.Refill then
            API.SetResourceAmount(SlaveBehavior.Data[1], 250, 250);
        elseif SlaveBehavior.Type == Objective.Custom2 then
            if SlaveBehavior.Reset then
                SlaveBehavior:Reset(_Quest);
            else
                if SlaveBehavior.Interrupt then
                    SlaveBehavior:Interrupt(_Quest);
                end
            end
        end
    end
end

function b_Goal_RandomRequest:Reset(_Quest)
    self:Interrupt(_Quest);
    self.TrialsCounter = self.Trials;
    self.SlaveQuest = nil;
end

function b_Goal_RandomRequest:Interrupt(_Quest)
    if self.SlaveQuest and self.SlaveQuest.State == QuestState.Active then
        API.StopQuest(self.SlaveQuest.Identifier, true);
    end
    if _Quest.PredatorMarker and Logic.IsEffectRegistered(_Quest.PredatorMarker) then
        Logic.DestroyEffect(_Quest.PredatorMarker);
        _Quest.PredatorMarker = nil;
    end
end

function b_Goal_RandomRequest:Debug(_Quest)
    if (type(self.TimeLimit) ~= "number" or self.TimeLimit < 0) then 
        error(_Quest.Identifier.. ": " ..self.Name.. ": Time limit must be a number and at least 0!");
        return true;
    end
    if (type(self.Trials) ~= "number") then 
        error(_Quest.Identifier.. ": " ..self.Name.. ": Trials must be a numeric value!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_RandomRequest);

-- -------------------------------------------------------------------------- --

Core:RegisterAddOn("AddOnRandomRequests");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnQuestNotes                                              # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Modul erlaubt das Speichern und Anzeigen von Zusatzinformationen zu
-- Quests. Die Informationen werden mit Klick auf den Informationsbutton neben
-- dem Portrait angezeigt. Dadurch ist es möglich, dem Spieler erweiterte Hilfe
-- zu geben oder ihn nach und nach Informationen zusammen tragen zu lassen, die
-- für die Erfüllung der Mission benötigt werden.
--
-- Per Default werden die Informationen als Message angezeigt. Sollte das Bundle
-- für Dialogfenster aktiv sein, wird stattdessen ein Textfenster verwendet.
-- Die Aktion für die Anzeige kann jedoch frei konfiguriert werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnQuestNotes = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Setzt die Funktion für Zusatzinformationen. Wird kein Questname angegeben,
-- wird der Default für alle Quests gesetzt.
-- Die Funktion wird beim Klick auf den Info-Button ausgeführt und sollte den
-- Text anzeigen. Eine speziell für einen Quest gesetzte Funktion ersetzt das
-- für alle Quests eingestellte Standardverhalten.
--
-- Die Funktion erhält folgende Parameter:
-- <table border="1">
-- <tr><td><b>Parameter</b></td><td><b>Typ</b></td><td><b>Beschreibung</b></td></tr>
-- <tr><td>QuestID</td><td>number</td><td>ID der Quest</td></tr>
-- <tr><td>Information</td><td>string</td><td>Zusationformationen für den Quest</td></tr>
-- </table>
--
-- @param[type=function] _Function  Aktion beim Klick
-- @param[type=string]   _QuestName (Optional) Name des Quest
-- @within Anwenderfunktionen
--
-- @usage
-- API.SetQuestNoteDisplayAction("MyQuest", SomeSpecializedActionFunction);
--
function API.SetQuestNoteDisplayAction(_Function, _QuestName)
    if GUI then
        return;
    end
    if not _QuestName then
        AddOnQuestNotes.Global.Data.ShowInfo.Default = _Function;
    else
        AddOnQuestNotes.Global.Data.ShowInfo[_QuestName] = _Function;
    end
end

---
-- Aktiviert oder Deaktiviert die Verfügbarkeit der Zusatzinformationen für den
-- übergebenen Quest.
--
-- <b>Hinweis</b>: Die Sichtbarkeit der Zusatzinformationen für einzelne Quests
-- ist generell aktiviert und muss explizit deaktiviert werden.
--
-- @param[type=string]  _Quest Name des Quest
-- @param[type=boolean] _Flag  Zusatzinfos aktivieren
-- @within Anwenderfunktionen
--
-- @usage
-- -- Deaktivieren
-- API.SetQuestNoteEnabled("MyQuest", false);
-- -- Aktivieren
-- API.SetQuestNoteEnabled("MyQuest", true);
--
function API.SetQuestNoteEnabled(_Quest, _Flag)
    if GUI then
        return;
    end
    local Quest = Quests[GetQuestID(_Quest)];
    if Quest then
        Quest.QuestNotes = _Flag == true;
    end
end

---
-- Fugt eine Zusatzinformation für diesen Quests hinzu.
--
-- <b>Hinweis</b>: Die erzeugte ID ist immer eindeutig für alle Einträge,
-- ungeachtet ob sie einem Quest zugeordnet sind oder nicht.
--
-- <b>Hinweis</b>: Der Questname kann durch nil ersetzt werden. In diesem Fall
-- erscheint der Eintrag bei <i>allen</i> sichtbaren Quests. Und das so lange,
-- bis er wieder gelöscht wird.
--
-- @param[type=string] _Quest Questname
-- @param              _Text  Text der Zusatzinfo
-- @return[type=number] ID des neuen Eintrags
-- @within Anwenderfunktionen
--
-- @usage
-- local NewEntryID = API.AddQuestNote("MyQuest", "Wichtige Information zum Anzeigen");
--
function API.AddQuestNote(_Quest, _Text)
    -- Add entry
    AddOnQuestNotes.Global.Data.Journal.ID = AddOnQuestNotes.Global.Data.Journal.ID +1;
    table.insert(AddOnQuestNotes.Global.Data.Journal, {
        ID = AddOnQuestNotes.Global.Data.Journal.ID,
        Quest = _Quest,
        Rank = 0,
        _Text
    });
    -- Local reference
    local Index = #AddOnQuestNotes.Global.Data.Journal;
    Logic.ExecuteInLuaLocalState(string.format(
        [[AddOnQuestNotes.Local.Data.Journal[%d] = %s]],
        Index,
        API.ConvertTableToString(AddOnQuestNotes.Global.Data.Journal[Index])
    ));
    return AddOnQuestNotes.Global.Data.Journal.ID;
end

---
-- Ändert den Text einer Zusatzinformation.
--
-- <b>Hinweis</b>: Der neue Text bezieht sich auf den Eintrag mit der ID. Ist
-- der Eintrag für alle Quests sichtbar, wird er in allen Quests geändert.
-- Kopien eines Eintrags werden nicht berücksichtigt.
--
-- @param[type=number] _ID   ID des Eintrag
-- @param              _Text Neuer Text
-- @within Anwenderfunktionen
--
-- @usage
-- API.AlterQuestNoteEntry(SomeEntryID, "Das ist der neue Text");
--
function API.AlterQuestNoteEntry(_ID, _Text)
    for i= #AddOnQuestNotes.Global.Data.Journal, 1, -1 do
        if AddOnQuestNotes.Global.Data.Journal[i].ID == _ID then
            AddOnQuestNotes.Global.Data.Journal[i][1] = _Text;
            Logic.ExecuteInLuaLocalState(string.format(
                [[AddOnQuestNotes.Local.Data.Journal[%d] = %s]],
                i,
                API.ConvertTableToString(AddOnQuestNotes.Global.Data.Journal[i])
            ));
            return;
        end
    end
end

---
-- Hebt einen Eintrag aus den Zusatzinformationen als wichtig hervor oder
-- setzt ihn zurück.
--
-- <b>Hinweis</b>: Wichtige Einträge erscheinen immer als erstes und sind durch
-- rote Färbung hervorgehoben. Eigene Farben in einer Nachricht beeinträchtigen
-- die rote hervorhebung.
--
-- @param[type=number]  _ID        ID des Eintrag
-- @param[type=boolean] _Important Wichtig Markierung
-- @within Anwenderfunktionen
--
-- @usage
-- API.HighlightQuestNoteEntry(SomeEntryID, true);
--
function API.HighlightQuestNoteEntry(_ID, _Important)
    for i= #AddOnQuestNotes.Global.Data.Journal, 1, -1 do
        if AddOnQuestNotes.Global.Data.Journal[i].ID == _ID then
            AddOnQuestNotes.Global.Data.Journal[i].Rank = (_Important == true and 1) or 0;
            Logic.ExecuteInLuaLocalState(string.format(
                [[AddOnQuestNotes.Local.Data.Journal[%d].Rank = %d]],
                i,
                (_Important == true and 1) or 0
            ));
            return;
        end
    end
end

---
-- Kopiert einen Eintrag als neuen Eintrag in einen anderen Quest.
--
-- @param[type=number] _ID    ID des Eintrag
-- @param[type=string] _Quest Name des neuen Quest
-- @within Anwenderfunktionen
--
-- @usage
-- local NewEntryID = API.CopyQuestNoteEntry(SomeEntryID, "MyOtherQuest");
--
function API.CopyQuestNoteEntry(_ID, _Quest)
    for i= #AddOnQuestNotes.Global.Data.Journal, 1, -1 do
        if AddOnQuestNotes.Global.Data.Journal[i].ID == _ID and AddOnQuestNotes.Global.Data.Journal[i].Quest ~= nil then
            if AddOnQuestNotes.Global.Data.Journal[i].Quest ~= _Quest then
                -- Create entry
                AddOnQuestNotes.Global.Data.Journal.ID = AddOnQuestNotes.Global.Data.Journal.ID +1;
                table.insert(AddOnQuestNotes.Global.Data.Journal, {
                    ID = AddOnQuestNotes.Global.Data.Journal.ID,
                    Quest = _Quest,
                    Rank = AddOnQuestNotes.Global.Data.Journal[i].Rank,
                    AddOnQuestNotes.Global.Data.Journal[i][1]
                });
                -- Local reference
                local Index = #AddOnQuestNotes.Global.Data.Journal;
                Logic.ExecuteInLuaLocalState(string.format(
                    [[AddOnQuestNotes.Local.Data.Journal[%d] = %s]],
                    Index,
                    API.ConvertTableToString(AddOnQuestNotes.Global.Data.Journal[Index])
                ));
                return AddOnQuestNotes.Global.Data.Journal.ID;
            end
        end
    end
end

---
-- Entfernt einen Eintrag aus den Zusatzinformationen.
--
-- @param[type=number] _ID ID des Eintrag
-- @within Anwenderfunktionen
--
-- @usage
-- API.DeleteQuestNoteEntry(SomeEntryID);
--
function API.DeleteQuestNoteEntry(_ID)
    for i= #AddOnQuestNotes.Global.Data.Journal, 1, -1 do
        if AddOnQuestNotes.Global.Data.Journal[i].ID == _ID then
            AddOnQuestNotes.Global.Data.Journal[i].Deleted = true;
            Logic.ExecuteInLuaLocalState(string.format(
                [[AddOnQuestNotes.Local.Data.Journal[%d].Deleted = true]],
                i
            ));
            return;
        end
    end
end

---
-- Stellt einen gelöschten Eintrag in den Zusatzinformationen wieder her.
--
-- @param[type=number] _ID ID des Eintrag
-- @within Anwenderfunktionen
--
-- @usage
-- API.RestoreQuestNoteEntry(SomeEntryID);
--
function API.RestoreQuestNoteEntry(_ID)
    for i= #AddOnQuestNotes.Global.Data.Journal, 1, -1 do
        if AddOnQuestNotes.Global.Data.Journal[i].ID == _ID then
            AddOnQuestNotes.Global.Data.Journal[i].Deleted = false;
            Logic.ExecuteInLuaLocalState(string.format(
                [[AddOnQuestNotes.Local.Data.Journal[%d].Deleted = false]],
                i
            ));
            return;
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnQuestNotes = {
    Global =  {
        Data = {
            ShowInfo   = {},
            Journal    = {ID = 0},
            TextColor  = "{white}",
            TextWindow = false,
        },
    },
    Local =  {
        Data = {
            Journal  = {},
            NextButton = "/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/TutorialNextButton",
            NextButtonIcon = {16, 10},
            ShowJournal = true,
        },
    },

    Text = {
        Next  = {de = "Notizen anzeigen", en = "Show Notebook"},
        Title = {de = "Notizbuch", en = "Notebook"}
    },
}

-- Global ----------------------------------------------------------------------

function AddOnQuestNotes.Global:Install()
    self:CreateDefaultActionLambda();
    self.Data.TextWindow = BundleDialogWindows ~= nil;
    self.Data.TextColor  = (BundleDialogWindows ~= nil and "{tooltip}") or "{white}",

    API.AddSaveGameAction(function()
        Logic.ExecuteInLuaLocalState("AddOnQuestNotes.Local:OverrideStringKeys()");
    end);
end

function AddOnQuestNotes.Global:CreateDefaultActionLambda()
    self.Data.ShowInfo.Default = function(_Quest, _Text)
        if not self.Data.TextWindow then
            Logic.ExecuteInLuaLocalState(string.format(
                [[GUI.ClearNotes(); API.Note("%s");]],
                _Text
            ));
        else
            Logic.ExecuteInLuaLocalState(string.format([[
                if not QSB.TextWindow.Data.Shown then
                    local Text = API.ConvertPlaceholders(API.Localize("%s"));
                    QSB.TextWindow:New(API.Localize(AddOnQuestNotes.Text.Title), Text):SetPause(false):Show();
                end
            ]], _Text));
        end
    end
end

function AddOnQuestNotes.Global:DisplayQuestNote(_QuestID)
    local Quest = Quests[_QuestID];
    if Quest and Quest.QuestNotes then
        local Journal = self:GetQuestNotesSorted();
        local Info = "";
        for i= 1, #Journal, 1 do
            if not Journal[i].Quest or GetQuestID(Journal[i].Quest) == _QuestID then
                if not Journal[i].Deleted then
                    local Text = API.ConvertPlaceholders(API.Localize(Journal[i][1]));
                    if Journal[i].Rank == 1 then
                        Text = "{scarlet}" .. Text .. self.Data.TextColor;
                    end
                    Info = Info .. ((Info ~= "" and "{cr}") or "") .. Text;
                end
            end
        end
        if AddOnQuestNotes.Global.Data.ShowInfo[Quest.Identifier] then
            AddOnQuestNotes.Global.Data.ShowInfo[Quest.Identifier](_QuestID, Info);
        else
            AddOnQuestNotes.Global.Data.ShowInfo.Default(_QuestID, Info);
        end
    end
end

function AddOnQuestNotes.Global:GetQuestNotesSorted()
    local Journal = {};
    for i= 1, #AddOnQuestNotes.Global.Data.Journal, 1 do
        if AddOnQuestNotes.Global.Data.Journal[i].Rank == 0 then
            table.insert(Journal, AddOnQuestNotes.Global.Data.Journal[i]);
        end
        if AddOnQuestNotes.Global.Data.Journal[i].Rank == 1 then
            local Index = 1;
            for j= 1, #Journal, 1 do
                if Journal[j].Rank == 1 then
                    Index = Index +1;
                end
            end
            table.insert(Journal, Index, AddOnQuestNotes.Global.Data.Journal[i]);
        end
    end
    return Journal;
end

-- Local -----------------------------------------------------------------------

function AddOnQuestNotes.Local:Install()
    self:OverrideUpdateVoiceMessage();
    self:OverrideTutorialNext();
    self:OverrideStringKeys();
end

function AddOnQuestNotes.Local:OverrideUpdateVoiceMessage()
    GUI_Interaction.UpdateVoiceMessage_Orig_AddOnQuestNotes = GUI_Interaction.UpdateVoiceMessage;
    GUI_Interaction.UpdateVoiceMessage = function()
        GUI_Interaction.UpdateVoiceMessage_Orig_AddOnQuestNotes();
        if not QuestLog.IsQuestLogShown() then
            if AddOnQuestNotes.Local:IsShowingQuestNoteButton(g_Interaction.CurrentMessageQuestIndex) then
                XGUIEng.ShowWidget(AddOnQuestNotes.Local.Data.NextButton, 1);
                SetIcon(
                    AddOnQuestNotes.Local.Data.NextButton,
                    AddOnQuestNotes.Local.Data.NextButtonIcon
                );
            else
                XGUIEng.ShowWidget(AddOnQuestNotes.Local.Data.NextButton, 0);
            end
        end
    end
end

function AddOnQuestNotes.Local:IsShowingQuestNoteButton(_ID)
    if not g_Interaction.CurrentMessageQuestIndex then
        return false;
    end
    local Quest = Quests[_ID];
    if  type(Quest) == "table"
    and AddOnQuestNotes.Local.Data.ShowJournal 
    and Quest.QuestNotes 
    and #AddOnQuestNotes.Local.Data.Journal > 0 then
        for i= #AddOnQuestNotes.Local.Data.Journal, 1, -1 do
            if  AddOnQuestNotes.Local.Data.Journal[i].Deleted ~= true
            and (AddOnQuestNotes.Local.Data.Journal[i].Quest == nil or 
                 AddOnQuestNotes.Local.Data.Journal[i].Quest == Quest.Identifier) then
                return true;
            end
        end
    end
    return false;
end

function AddOnQuestNotes.Local:OverrideTutorialNext()
    GUI_Interaction.TutorialNext_Orig_AddOnQuestNotes = GUI_Interaction.TutorialNext;
    GUI_Interaction.TutorialNext = function()
        if g_Interaction.CurrentMessageQuestIndex then
            GUI.SendScriptCommand(string.format(
                [[AddOnQuestNotes.Global:DisplayQuestNote(%d)]],
                g_Interaction.CurrentMessageQuestIndex
            ));
        end
    end
end

function AddOnQuestNotes.Local:OverrideStringKeys()
    GetStringTableText_Orig_AddOnQuestNotes = XGUIEng.GetStringTableText;
    XGUIEng.GetStringTableText = function(_key)
        if _key == "UI_ObjectNames/TutorialNextButton" then
            return API.Localize(AddOnQuestNotes.Text.Next);
        end
        return GetStringTableText_Orig_AddOnQuestNotes(_key);
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterAddOn("AddOnQuestNotes");

-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia Selfload                                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

if not MapEditor and not GUI then
    local MapTypeFolder = "externalmap";
    local MapType, Campaign = Framework.GetCurrentMapTypeAndCampaignName();
    if MapType ~= 3 then
        MapTypeFolder = "development";
    end

    gvMission = gvMission or {};
    gvMission.ContentPath = "maps/" ..MapTypeFolder.. "/" ..Framework.GetCurrentMapName() .. "/";
    gvMission.MusicRootPath = "music/";
    gvMission.PlaylistRootPath = "config/sound/";

    if Mission_LoadFiles then
        local Files = Mission_LoadFiles();
        if Files then
            for i= 1, #Files, 1 do
                Script.Load(Files[i]);
            end
        end
    end
    API.Install();
    if BundleKnightTitleRequirements then
        InitKnightTitleTables();
    end

    Logic.ExecuteInLuaLocalState([[
        gvMission = gvMission or {};
        gvMission.GlobalVariables = Logic.CreateReferenceToTableInGlobaLuaState("gvMission");
        gvMission.ContentPath = "maps/]] ..MapTypeFolder.. [[/" ..Framework.GetCurrentMapName() .. "/";
        gvMission.MusicRootPath = "music/";
        gvMission.PlaylistRootPath = "config/sound/";

        Script.Load(gvMission.ContentPath.. "questsystembehavior.lua");
        if Mission_LoadFiles then
            local Files = Mission_LoadFiles();
            if Files then
                for i= 1, #Files, 1 do
                    Script.Load(Files[i]);
                end
            end
        end
        API.Install();
        if BundleKnightTitleRequirements then
            InitKnightTitleTables();
        end
        if Mission_LocalOnQsbLoaded then
            Mission_LocalOnQsbLoaded();
        end
    ]]);
end

